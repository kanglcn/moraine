[
  {
    "objectID": "Introduction/software_architecture.html",
    "href": "Introduction/software_architecture.html",
    "title": "Software Architecture",
    "section": "",
    "text": "Unlike most InSAR processing software (e.g., StamPS, MintPy) that have designated processing workflow, Moraine only provides a collection of Python functions or commands. The reason is, in real application, there is no perfect workflow that always generate satisfactory deformation result. Especially when the coherence is not good and atmospheric artifact is strong. One needs to try a lot of different methods but they are generally implented in different packages. Even worse, the workflow-based software are encapsulated too much and generally no detailed documentation is provided. It is really frustrating when users need to save intermediate data from one software and prepared them in a designated format and structure required by another software. Sometimes it is necessarry to read a lot of source code to understand what are the output, what are their data structure and what kind of inputs are needed as their typical workflows is not followed. So, instead of providing a standard workflow, Moraine is designed as a collection of functions that implement specific InSAR processing techniques (e.g. calculate the dispersion index, do phase linking) and users are encouraged to make their own workflow that are suitable for their case. We provide the necessary infrastructure and your role is to be innovative! To make it easier, Moraine provides detailed documentation for each function that explain the usage. We also provide the tutorials section that provide some typical workflow for your reference. In case users want to try methods that are not implemented in Moraine, the input and output are well explained in the documentation of every Moraine functions.\nAlthough we provide detailed documentation and reference workflow, we still admit this software is not that easy that users only need to run from the first step to the last step. It doesn’t mean we don’t value user-friendliness, but it shouldn’t come at the expense of flexibility and creativity.",
    "crumbs": [
      "Introduction",
      "Software Architecture"
    ]
  },
  {
    "objectID": "Introduction/software_architecture.html#software-design",
    "href": "Introduction/software_architecture.html#software-design",
    "title": "Software Architecture",
    "section": "",
    "text": "Unlike most InSAR processing software (e.g., StamPS, MintPy) that have designated processing workflow, Moraine only provides a collection of Python functions or commands. The reason is, in real application, there is no perfect workflow that always generate satisfactory deformation result. Especially when the coherence is not good and atmospheric artifact is strong. One needs to try a lot of different methods but they are generally implented in different packages. Even worse, the workflow-based software are encapsulated too much and generally no detailed documentation is provided. It is really frustrating when users need to save intermediate data from one software and prepared them in a designated format and structure required by another software. Sometimes it is necessarry to read a lot of source code to understand what are the output, what are their data structure and what kind of inputs are needed as their typical workflows is not followed. So, instead of providing a standard workflow, Moraine is designed as a collection of functions that implement specific InSAR processing techniques (e.g. calculate the dispersion index, do phase linking) and users are encouraged to make their own workflow that are suitable for their case. We provide the necessary infrastructure and your role is to be innovative! To make it easier, Moraine provides detailed documentation for each function that explain the usage. We also provide the tutorials section that provide some typical workflow for your reference. In case users want to try methods that are not implemented in Moraine, the input and output are well explained in the documentation of every Moraine functions.\nAlthough we provide detailed documentation and reference workflow, we still admit this software is not that easy that users only need to run from the first step to the last step. It doesn’t mean we don’t value user-friendliness, but it shouldn’t come at the expense of flexibility and creativity.",
    "crumbs": [
      "Introduction",
      "Software Architecture"
    ]
  },
  {
    "objectID": "Introduction/software_architecture.html#software-structure",
    "href": "Introduction/software_architecture.html#software-structure",
    "title": "Software Architecture",
    "section": "Software Structure",
    "text": "Software Structure\nMost of the functions in this package provide 2 kind of API, the array-based API and the file-based API. The inputs and output of array-based functions generally are numpy or cupy arrays (Simply, cupy is a package that provides same functions as numpy but runs on GPU), while inputs and outputs of file-based functions are string of path to the array stored in disk. InSAR techniques that can be greatly accelerated with parallel processing are implented in cupy or numba for better performance. The file-based functions are not simple wrapper of the array-based functions. Since Moraine aims at big data processing, most array-based functions may not be used due to the memory limitation. However, the file-based functions support chunkwise processing with the help of dask, and mulit-GPU processing is also supported.\nTo make it simpler, we call the file-based functions CLI (command line interface) (The name is just a convention, we don’t provide the commands that can be runned from the terminal.), the array-based API API. The API and CLI functions are arranged in different namespace: moraine.* and moraine.cli.*. The CLI functions support logging if logger is created.",
    "crumbs": [
      "Introduction",
      "Software Architecture"
    ]
  },
  {
    "objectID": "Introduction/software_architecture.html#data-format",
    "href": "Introduction/software_architecture.html#data-format",
    "title": "Software Architecture",
    "section": "Data format",
    "text": "Data format\nMost of the stored data in this package is in the zarr format, which is a file storage format for chunked, compressed, N-dimensional arrays. The figure below shows how the structure of zarr data. The reading and writing speed is fast since the data volume is compressed. Before compressing, the data are divided into chunks to be more flexiable for dask parallel operation. Generally, the file name is xxxxxx.zarr. You will find it is indeed a directory in the file system. But just treat it as a single file in use.\n\n\n\nimga\n\n\nNote that the sturcture of dask array is similar. Each chunk of a big dask array is just a numpy or cupy array. Independent operations on every chunks are automatically parallelized.\nIn this software, there are mainly two kind of dataset. One is stack of raster data, another is stack of point cloud data. The raster dataset are divided into chunks both azimuth dimension and range dimension. The point cloud dataset are divided into chunks along the spatial dimension. These two chunksize needs to be determined by the user. The chunksize in high dims are automatically determined. Users don’t need to care about it.\nChunksize affect the performance of the program. Unproper chunksize slows down the processing speed or even crash the program. Using too small chunksize makes too much inter-process communication and slows down the program. Too big chunksize may crash the program due to mamory limit. For raster data, it is good to make sure range chunksize of the last chunk is same as others. And it is prefered to divide raster data along azimuth direction rather than range direction.",
    "crumbs": [
      "Introduction",
      "Software Architecture"
    ]
  },
  {
    "objectID": "Introduction/software_architecture.html#an-example",
    "href": "Introduction/software_architecture.html#an-example",
    "title": "Software Architecture",
    "section": "An example",
    "text": "An example\nHere we provide an simple example. The API function moraine.emi implemented the EMI phase linking method and moraine.cli.emi is the file-based API of it.\nImport them first:\n\nimport moraine as mr\nimport moraine.cli as mc\nfrom nbdev.showdoc import show_doc # this is just a function to show the document\n\n\nsource\n\nemi\n\n emi (coh:numpy.ndarray, ref:int=0)\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ncoh\nndarray\n\ncomplex coherence metrix,dtype cupy.complex\n\n\nref\nint\n0\nindex of reference image in the phase history output, optional. Default: 0\n\n\nReturns\ntuple\n\nestimated phase history ph, dtype complex; quality (minimum eigvalue, dtype float)\n\n\n\n\nsource\n\n\nemi\n\n emi (coh:str, ph:str, emi_quality:str, ref:int=0, chunks:int=None,\n      cuda:bool=False, processes=None, n_workers=None,\n      threads_per_worker=None, rmm_pool_size=0.9, **dask_cluster_arg)\n\nPhase linking with EMI estimator.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ncoh\nstr\n\ncoherence matrix\n\n\nph\nstr\n\noutput, wrapped phase\n\n\nemi_quality\nstr\n\noutput, pixel quality\n\n\nref\nint\n0\nreference image for phase\n\n\nchunks\nint\nNone\n# chunk size of output zarr dataset, optional. Default: same as coh.\n\n\ncuda\nbool\nFalse\nif use cuda for processing, false by default\n\n\nprocesses\nNoneType\nNone\nuse process for dask worker over thread, the default is False for cpu, only applied if cuda==False\n\n\nn_workers\nNoneType\nNone\nnumber of dask worker, the default is 1 for cpu, number of GPU for cuda\n\n\nthreads_per_worker\nNoneType\nNone\nnumber of threads per dask worker, the default is 2 for cpu, only applied if cuda==False\n\n\nrmm_pool_size\nfloat\n0.9\nset the rmm pool size, only applied when cuda==True\n\n\ndask_cluster_arg\nVAR_KEYWORD\n\n\n\n\n\nTo apply the emi API funtion:\n\nimport zarr\nimport numpy as np\nfrom moraine.utils_ import is_cuda_available\nif is_cuda_available():\n    import cupy as cp\n\n\ncoh_zarr = zarr.open('./software_architecture/ds_can_coh.zarr/','r')\n\n\ncoh_zarr,coh_zarr.shape,coh_zarr.chunks,coh_zarr.dtype\n\n(&lt;zarr.core.Array (740397, 17, 17) complex64 read-only&gt;,\n (740397, 17, 17),\n (200000, 17, 17),\n dtype('complex64'))\n\n\nIt is coherence matrix for 740397 selected DS candidate and there are 17 SAR images. So the coherence matrix for one pixel is 17 \\(\\times\\) 17. The coherence matrix is stored in 4 chunks and each chunks stores data for 200000 DS candidate. (The last chunk only have 140397 DS candidate).\n\n!ls -al ./software_architecture/ds_can_coh.zarr/ #It is a directory indeed!\n\ntotal 1570400\ndrwxrwxr-x 2 kangl kangl      4096 Sep 28  2023 .\ndrwxrwxr-x 5 kangl kangl      4096 Apr 28 20:27 ..\n-rw-rw-r-- 1 kangl kangl 434775676 Sep 28  2023 0.0.0\n-rw-rw-r-- 1 kangl kangl 432578417 Sep 28  2023 1.0.0\n-rw-rw-r-- 1 kangl kangl 434846911 Sep 28  2023 2.0.0\n-rw-rw-r-- 1 kangl kangl 305857416 Sep 28  2023 3.0.0\n-rw-rw-r-- 1 kangl kangl       398 Sep 28  2023 .zarray\n\n\n\ncoh = coh_zarr[:] # read as numpy array\n\n\nif is_cuda_available():\n    coh = cp.asarray(coh) # convert to cupy array\n\n\ncoh.shape\n\n(740397, 17, 17)\n\n\n\n# The processing is really fast!\nif is_cuda_available():\n    ph,emi_quality = mr.emi(coh)\n\nCPU times: user 1.45 s, sys: 202 ms, total: 1.65 s\nWall time: 1.65 s\n\n\nNow we apply the CLI function:\n\nlogger = mc.get_logger()\n\n\nif is_cuda_available():\n    mc.emi('./software_architecture/ds_can_coh.zarr/',\n           './software_architecture/ds_can_ph.zarr',\n           './software_architecture/ds_can_emi_quality.zarr',)\n\n2024-04-30 22:49:13 - log_args - INFO - running function: emi\n2024-04-30 22:49:13 - log_args - INFO - fetching args:\n2024-04-30 22:49:13 - log_args - INFO - coh = './software_architecture/ds_can_coh.zarr/'\n2024-04-30 22:49:13 - log_args - INFO - ph = './software_architecture/ds_can_ph.zarr'\n2024-04-30 22:49:13 - log_args - INFO - emi_quality = './software_architecture/ds_can_emi_quality.zarr'\n2024-04-30 22:49:13 - log_args - INFO - ref = 0\n2024-04-30 22:49:13 - log_args - INFO - chunks = None\n2024-04-30 22:49:13 - log_args - INFO - fetching args done.\n2024-04-30 22:49:13 - zarr_info - INFO - ./software_architecture/ds_can_coh.zarr/ zarray shape: (740397, 17, 17)\n2024-04-30 22:49:13 - zarr_info - INFO - ./software_architecture/ds_can_coh.zarr/ zarray chunks: (200000, 17, 17)\n2024-04-30 22:49:13 - zarr_info - INFO - ./software_architecture/ds_can_coh.zarr/ zarray dtype: complex64\n2024-04-30 22:49:13 - emi - INFO - starting dask CUDA local cluster.\n2024-04-30 22:49:16 - emi - INFO - dask local CUDA cluster started.\n2024-04-30 22:49:16 - darr_info - INFO - coh dask array shape: (740397, 17, 17)\n2024-04-30 22:49:16 - darr_info - INFO - coh dask array chunksize: (200000, 17, 17)\n2024-04-30 22:49:16 - darr_info - INFO - coh dask array dtype: complex64\n2024-04-30 22:49:16 - emi - INFO - phase linking with EMI.\n2024-04-30 22:49:16 - emi - INFO - got ph and emi_quality.\n2024-04-30 22:49:16 - darr_info - INFO - ph dask array shape: (740397, 17)\n2024-04-30 22:49:16 - darr_info - INFO - ph dask array chunksize: (200000, 17)\n2024-04-30 22:49:16 - darr_info - INFO - ph dask array dtype: complex64\n2024-04-30 22:49:16 - darr_info - INFO - emi_quality dask array shape: (740397,)\n2024-04-30 22:49:16 - darr_info - INFO - emi_quality dask array chunksize: (200000,)\n2024-04-30 22:49:16 - darr_info - INFO - emi_quality dask array dtype: float32\n2024-04-30 22:49:16 - emi - INFO - rechunk ph\n2024-04-30 22:49:16 - darr_info - INFO - ph dask array shape: (740397, 17)\n2024-04-30 22:49:16 - darr_info - INFO - ph dask array chunksize: (200000, 17)\n2024-04-30 22:49:16 - darr_info - INFO - ph dask array dtype: complex64\n2024-04-30 22:49:16 - emi - INFO - saving ph and emi_quality.\n2024-04-30 22:49:16 - emi - INFO - computing graph setted. doing all the computing.\n2024-04-30 22:49:21 - emi - INFO - computing finished.leted |  5.2s\n2024-04-30 22:49:22 - emi - INFO - dask cluster closed.\nCPU times: user 578 ms, sys: 304 ms, total: 883 ms\nWall time: 8.61 s\n\n\nThe CLI function is slower than the API function since it needs to read and write the data and set up the dask CUDA cluster.\nThe CLI also include functions for simple data manipulation (e.g. array slicing and point clouds merging). As it is very easy to do them for numpy/cupy arrays, these CLI do not have corresponding API.",
    "crumbs": [
      "Introduction",
      "Software Architecture"
    ]
  },
  {
    "objectID": "API/coord_.html",
    "href": "API/coord_.html",
    "title": "moraine",
    "section": "",
    "text": "source\n\nCoord\n\n Coord (x0, dx, nx, y0, dy, ny)\n\nutils for digitize raster and point cloud data, in a pyramid. The coord is defined as the continuous coordinates, e.g., longitude & latitude. The index is defined as the digitized index, (0,0,nx-1,ny-1).\n\ncoord = Coord(1.8,0.2,10,-1.2,0.2,10)\n\npc = np.random.rand(5,3,2)\nx = np.array([1.91,1.88,1.87,3.43,2.8])\ny = np.array([-1.11,-1.09,-0.81,-0.4,0.11])\ngix = coord.coords2gixs(np.stack((y,x),axis=-1))\nnp.testing.assert_array_equal(gix, np.stack(([0,1,2,4,7],[1,0,0,8,5]),axis=-1))\n# pc.shape, pc, gix\n\n\nras = coord.rasterize(pc,gix)\niidx = coord.rasterize_iidx(gix)\nassert ras.shape[2:] == pc.shape[1:]\nassert iidx.shape == (10,10)\n_ras = pc[iidx]\n_ras[iidx==-1] = np.nan\nnp.testing.assert_array_equal(_ras, ras)\n\n\nras = np.zeros((2,2))\nras\n\narray([[0., 0.],\n       [0., 0.]])\n\n\n\nras[[0,0],[0,0]] = [1,2]\nras # fill in the lastest value\n\narray([[2., 0.],\n       [0., 0.]])"
  },
  {
    "objectID": "API/gamma_.html",
    "href": "API/gamma_.html",
    "title": "gamma",
    "section": "",
    "text": "source\n\nread_gamma_image\n\n read_gamma_image (imag:str, width:int, dtype:str='float', y0:int=0,\n                   ny:int=None)\n\nread gamma image into numpy array.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nimag\nstr\n\ngamma raster data\n\n\nwidth\nint\n\ndata width\n\n\ndtype\nstr\nfloat\ndata format, only ‘float’, ‘fcomplex’, ‘double’ and ‘int’ are supported.\n\n\ny0\nint\n0\nline number to start reading\n\n\nny\nint\nNone\nnumber of lines to read, default: to the last line\n\n\n\n\nsource\n\n\nread_gamma_pdata\n\n read_gamma_pdata (imag:str, dtype:str='float')\n\nread gamma image into numpy array.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nimag\nstr\n\ngamma point cloud data\n\n\ndtype\nstr\nfloat\ndata format, only ‘float’, ‘fcomplex’, ‘double’ and ‘int’ are supported.\n\n\n\n\nsource\n\n\nwrite_gamma_image\n\n write_gamma_image (imag, path)\n\n\nsource\n\n\nread_gamma_plist\n\n read_gamma_plist (plist:str, dtype='int')\n\n\nsource\n\n\nwrite_gamma_plist\n\n write_gamma_plist (imag, path)"
  },
  {
    "objectID": "API/tnet.html",
    "href": "API/tnet.html",
    "title": "Temporal Network",
    "section": "",
    "text": "source\n\nTempNet\n\n TempNet (image_pairs, check_if_valid=True)\n\nInitialize self. See help(type(self)) for accurate signature.\nUsage:\nCreate a temporal network by specifing the number of images and the temporal bandwidth (the maximum number of images to be paired with one image):\n\ntnet = TempNet.from_bandwidth(5,2)\n\n\ntnet.image_pairs\n\narray([[0, 1],\n       [0, 2],\n       [1, 2],\n       [1, 3],\n       [2, 3],\n       [2, 4],\n       [3, 4]], dtype=int32)\n\n\nOr, you can specify your own image pairs:\n\ntnet = TempNet(np.stack(([0,1,2,3],[1,2,3,4]),axis=-1))\ntnet.image_pairs\n\narray([[0, 1],\n       [1, 2],\n       [2, 3],\n       [3, 4]], dtype=int32)\n\n\n\ntnet.image_pairs_idx(ref=1,sec=2)\n\nnp.int64(1)\n\n\n\ntnet.image_pairs_idx(ref=[1,2],sec=[2,3])\n\narray([1, 2])\n\n\n\nsource\n\n\nnimage_from_npair\n\n nimage_from_npair (npair)\n\ninfer number of images from number of pairs assuming all pairs are selected.\n\nnimage_from_npair(6)\n\n4",
    "crumbs": [
      "API",
      "Temporal Network"
    ]
  },
  {
    "objectID": "API/plot.html",
    "href": "API/plot.html",
    "title": "plot",
    "section": "",
    "text": "Note\n\n\n\nNote that the plotting functions here make use of dynamic updates, which require a running Jupyter server. When viewed statically (as this documentation website), the plots will not update fully when you zoom.\n\n\n\nimport holoviews as hv\nimport numpy as np\nimport zarr\nfrom holoviews import opts\nfrom bokeh.models import WheelZoomTool\n\n\nhv.extension('bokeh')\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n  \n  \n\n\n\n\n\n\n\n\nⓘ\n\n\n\n\n\nsource\n\nras_plot\n\n ras_plot (data:str, post_proc:Callable=None, n_kdim:int=None,\n           bounds:tuple=None, level_increase=0)\n\nplot rendered stack of ras tiles.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ndata\nstr\n\ndirectory to the rendered ras pyramid\n\n\npost_proc\nCallable\nNone\nfunction for the post processing, can be None, ‘intf_0’, ‘intf_seq’, ‘intf_all’ or user-defined function\n\n\nn_kdim\nint\nNone\nnumber of key dimensions, can only be 0 or 1 or 2, ndim of raster dataset -2 by default\n\n\nbounds\ntuple\nNone\nbounding box (x0, y0, x_max, y_max)\n\n\nlevel_increase\nint\n0\namount of zoom level increase for more clear point show and faster responds time\n\n\n\nUsage:\n\nrslc_ = '../../data/rslc.zarr/'\nrslc = zarr.open(rslc_,mode='r')[:]\n\n\nintf_plot = ras_plot(np.angle(rslc[...,2]*rslc[...,0].conj()))\n\n\nintf_plot = intf_plot.redim(x=hv.Dimension('r', label='Range'), y=hv.Dimension('az',label='Azimuth'), z=hv.Dimension('Phase',range=(-np.pi,np.pi)))\n\n\nintf_plot.opts(opts.Image(cmap='colorwheel',width=600, height=400, colorbar=True,\n                          invert_yaxis=True,\n                          default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],active_tools=['wheel_zoom']))\n\n\n\n\n\n  \n\n\n\n\nras_plot can also take stack of raster images. It will return DynamicMap with keys. Here we define a function to generate interferograms with the first SLC as reference:\n\ndef intf_0(data, xslice, yslice,i):\n    return np.angle(data[yslice,xslice,0]*data[yslice,xslice,i].conj())\n\n\nintf_plot = ras_plot(rslc,post_proc=intf_0, level_increase=0)\n\nWe have a set of convenient predefined post_proc functions, e.g., intf_0, intf_seq, intf_all. The above code equals to:\n\nintf_plot = ras_plot(rslc,post_proc='intf_0', level_increase=0)\n\nAdd annotations:\n\ndates = [\"20210802\", \"20210816\", \"20210830\", \"20210913\", \"20211011\", \"20211025\", \"20220606\", \"20220620\",\n         \"20220704\", \"20220718\", \"20220801\", \"20220815\", \"20220829\", \"20220912\", \"20220926\", \"20221010\",\n         \"20221024\",]\nintf_plot = intf_plot.redim(i=hv.Dimension('i', label='Interferogram', range=(0,16), value_format=(lambda i: dates[0]+'_'+dates[i])),\n                            x=hv.Dimension('r', label='Range'), y=hv.Dimension('az',label='Azimuth'), z=hv.Dimension('Phase',range=(-np.pi,np.pi)))\n\nSpecify plotting options and plot:\n\nhv.output(widget_location='bottom')\nintf_plot.opts(opts.Image(cmap='colorwheel',width=600, height=400, colorbar=True,\n                          invert_yaxis=True,\n                          default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],active_tools=['wheel_zoom']))\n\n\n\n\n\n  \n\n\n\n\nOr the intensity:\n\ndef intensity(data, xslice, yslice,i):\n    return np.log(np.abs(data[yslice,xslice,i])**2)\n\nint_plot = ras_plot(rslc,post_proc=intensity)\nint_plot = int_plot.redim(i=hv.Dimension('i', label='Intensity', range=(1,16), value_format=(lambda i: dates[i])),\n                          x=hv.Dimension('r', label='Range'), y=hv.Dimension('az',label='Azimuth'), z=hv.Dimension('Intensity'))\nint_plot.opts(opts.Image(cmap='gray',width=600, height=600, colorbar=True,\n                         invert_yaxis=True, default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],\n                         active_tools=['wheel_zoom']))\n\n\n\n\n\n  \n\n\n\n\nWe can also plot sequential interferograms. In this case, we only plot 26 interferograms.\n\ndef intf_seq(data, xslice, yslice,i):\n    return np.angle(data[yslice,xslice,i]*data[yslice,xslice,i+1].conj())\nintf_plot = ras_plot(rslc,post_proc=intf_seq)\n# or\nintf_plot = ras_plot(rslc,post_proc='intf_seq')\n\nintf_plot = intf_plot.redim(i=hv.Dimension('i', label='Interferogram', range=(0,15), value_format=(lambda i: dates[i]+'_'+dates[i+1])),\n                            x=hv.Dimension('r', label='Range'), y=hv.Dimension('az',label='Azimuth'), z=hv.Dimension('Phase',range=(-np.pi,np.pi)))\nintf_plot.opts(opts.Image(cmap='colorwheel',width=600, height=600, colorbar=True,\n                          invert_yaxis=True, default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],\n                          active_tools=['wheel_zoom']))\n\n\n\n\n\n  \n\n\n\n\nThe n_kdim don’t have to be data.ndim-2. Here is an example to show all interferograms.\n\ndef intf_all(data, xslice, yslice,i,j): # we have 2 kdims here\n    return np.angle(data[yslice,xslice,i]*data[yslice,xslice,j].conj())\n\n\nintf_plot = ras_plot(rslc,post_proc=intf_all,n_kdim=2,level_increase=0)\n# or\nintf_plot = ras_plot(rslc,post_proc='intf_all',n_kdim=2,level_increase=0)\n\nAdd annotations:\n\nintf_plot = intf_plot.redim(i=hv.Dimension('i', label='Reference Image', range=(0,16), value_format=(lambda i: dates[i])),\n                            j=hv.Dimension('j', label='Secondary Image', range=(0,16), value_format=(lambda i: dates[i])),\n                            x=hv.Dimension('r', label='Range'), y=hv.Dimension('az',label='Azimuth'), z=hv.Dimension('Phase',range=(-np.pi,np.pi)))\n\nSpecify plotting options and plot:\n\nhv.output(widget_location='bottom')\nintf_plot.opts(opts.Image(cmap='colorwheel',frame_width=500, frame_height=600, colorbar=True,\n                          invert_yaxis=True,\n                          default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],active_tools=['wheel_zoom']))\n\n\n\n\n\n  \n\n\n\n\n\nsource\n\n\npc_plot\n\n pc_plot (data:numpy.ndarray, y:numpy.ndarray, x:numpy.ndarray,\n          ras_resolution:float=20, post_proc_pc:Callable=None,\n          n_kdim:int=None, rtree=None, level_increase=0)\n\nplot rendered point cloud pyramid on the fly\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ndata\nndarray\n\npc dataset\n\n\ny\nndarray\n\ny coordinate\n\n\nx\nndarray\n\nx coordinate\n\n\nras_resolution\nfloat\n20\nminimum resolution of rendered raster data in the pyramid\n\n\npost_proc_pc\nCallable\nNone\nfunction for the post processing\n\n\nn_kdim\nint\nNone\nnumber of key dimensions, can only be 0 or 1 or 2, ndim of point cloud dataset -1 by default\n\n\nrtree\nNoneType\nNone\nrtree, if not provide, will be automatically generated but may slow the program\n\n\nlevel_increase\nint\n0\namount of zoom level increase for more clear point show and faster responds time\n\n\n\npc_plot take the rendered point cloud dataset as the input and return a Holoviews DynamicMap. When the zoom level is -1, it plot the the raw point cloud data. When the zoom level is 0 or over 0, it plot the rasterized images. Just as ras_plot, it accept post processing functions for both point cloud data and raster data to be plot. It is the user’s duty to esure the post processing fuctions coincide with each other. It also accept n_kdim to set number of kdims for returned DynamicMap.\nHere is an example to plot the amplitude dispersion index:\n\nps_can_adi = zarr.open('../CLI/ps/ps_can_adi.zarr/',mode='r')[:]\nps_can_rslc = zarr.open('../CLI/ps/ps_can_rslc.zarr/',mode='r')[:]\nps_can_x = zarr.open('../CLI/ps/ps_can_e.zarr/',mode='r')[:]\nps_can_y = zarr.open('../CLI/ps/ps_can_n.zarr/',mode='r')[:]\n\n\nadi_plot = pc_plot(ps_can_adi,ps_can_y,ps_can_x,level_increase=1)\n\nAdd annotations:\n\nadi_plot = adi_plot.redim(x=hv.Dimension('lon', label='Longitude'), y=hv.Dimension('lat',label='Latitude'),\n                          z=hv.Dimension('adi',label='Amplitude Dispersion Index',range=(0,0.3))\n                         )\n\nSpecify plotting options and plot:\n\nadi_plot.opts(opts.Image(cmap='fire',width=600, height=400, colorbar=True,\n                         # invert_yaxis=True, \n                         default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],\n                         active_tools=['wheel_zoom']\n                        ),\n              opts.Points(color='adi', cmap='fire',width=600, height=400, colorbar=True,\n                         # invert_yaxis=True, \n                         default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],\n                         active_tools=['wheel_zoom']\n                        )\n             )\n\n\n\n\n\n  \n\n\n\n\nAdd the optical image as the background:\n\nhv.element.tiles.EsriImagery()*adi_plot\n\n\n\n\n\n  \n\n\n\n\nNote that, for displaying data over tiles, the data have to be projected to the Web Mercator Projection.\nAs ras_plot, pc_plot can also take stack of point cloud dataset. It will return DynamicMap with keys. Here we define a function to generate interferograms with the first SLC as reference:\n\ndef intf_0_pc(data,idx_array,i):\n    return np.angle(data[idx_array,0]*data[idx_array,i].conj())\n\n\nintf_plot = pc_plot(ps_can_rslc, ps_can_y, ps_can_x, post_proc_pc=intf_0_pc, level_increase=1)\n# or\nintf_plot = pc_plot(ps_can_rslc, ps_can_y, ps_can_x, post_proc_pc='intf_0', level_increase=1)\n\nAdd annotations:\n\ndates = [\"20210802\", \"20210816\", \"20210830\", \"20210913\", \"20211011\", \"20211025\", \"20220606\", \"20220620\",\n         \"20220704\", \"20220718\", \"20220801\", \"20220815\", \"20220829\", \"20220912\", \"20220926\", \"20221010\",\n         \"20221024\",]\nintf_plot = intf_plot.redim(i=hv.Dimension('i', label='Interferogram', range=(0,16), value_format=(lambda i: dates[0]+'_'+dates[i])),\n                            x=hv.Dimension('lon', label='Longitude'), y=hv.Dimension('lat',label='Latitude'), z=hv.Dimension('Phase',range=(-np.pi,np.pi)))\n\nSpecify plotting options and plot:\n\nhv.output(widget_location='bottom')\nintf_plot.opts(opts.Image(cmap='colorwheel',width=600, height=400, colorbar=True,\n                          default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],\n                          active_tools=['wheel_zoom']\n                         ),\n              opts.Points(color='Phase', cmap='colorwheel',width=600, height=400, colorbar=True,\n                         # invert_yaxis=True, \n                         default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],\n                         active_tools=['wheel_zoom']\n                        )\n              )\n\n\n\n\n\n  \n\n\n\n\nThe n_kdim don’t have to be data.ndim-1. Here is an example to show all interferograms.\n\ndef intf_pc(data, idx,i,j): # we have 2 kdims here\n    return np.angle(data[idx,i]*data[idx,j].conj())\n\n\nintf_plot = pc_plot(ps_can_rslc, ps_can_y, ps_can_x, post_proc_pc=intf_pc,n_kdim=2,level_increase=0)\n# or\nintf_plot = pc_plot(ps_can_rslc, ps_can_y, ps_can_x, post_proc_pc='intf_all',n_kdim=2,level_increase=0)\n\nAdd annotations:\n\nintf_plot = intf_plot.redim(i=hv.Dimension('i', label='Reference Image', range=(0,16), value_format=(lambda i: dates[i])),\n                            j=hv.Dimension('j', label='Secondary Image', range=(0,16), value_format=(lambda i: dates[i])),\n                            x=hv.Dimension('r', label='Range'), y=hv.Dimension('az',label='Azimuth'), z=hv.Dimension('Phase',range=(-np.pi,np.pi)))\n\nSpecify plotting options and plot:\n\nhv.output(widget_location='bottom')\nintf_plot.opts(opts.Image(cmap='colorwheel',width=600, height=400, colorbar=True,\n                          default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],\n                          active_tools=['wheel_zoom']\n                         ),\n              opts.Points(color='Phase', cmap='colorwheel',width=600, height=400, colorbar=True,\n                         # invert_yaxis=True, \n                         default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],\n                         active_tools=['wheel_zoom']\n                        )\n              )",
    "crumbs": [
      "API",
      "plot"
    ]
  },
  {
    "objectID": "API/calamp.html",
    "href": "API/calamp.html",
    "title": "calamp",
    "section": "",
    "text": "import zarr\nfrom matplotlib import pyplot as plt\nimport colorcet\nfrom moraine.utils_ import is_cuda_available\n\n\nsource\n\nrslc2amp\n\n rslc2amp (rslc:numpy.ndarray)\n\ncalculation the amplitude from SLC/SLC stack\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nrslc\nndarray\nrslc, 2D/3D numpy array or cupy array\n\n\nReturns\nndarray\namplitude, 2D/3D numpy array or cupy array\n\n\n\nUsage:\n\nrslc = zarr.open('../CLI/raw/rslc.zarr/',mode='r')[:,:,1]\namp = rslc2amp(rslc)\namp_ = np.abs(rslc)\nnp.testing.assert_array_almost_equal(amp,amp_,decimal=4)\nif is_cuda_available():\n    amp_gpu = rslc2amp(cp.asarray(rslc))\n    np.testing.assert_array_almost_equal(amp,amp_gpu.get(),decimal=4)\n\n\nsource\n\n\ncalamp\n\n calamp (amp:numpy.ndarray)\n\ncalculation the calibrated amplitude from amplitude of one single SLC\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\namp\nndarray\namplitude, 2D numpy array or cupy array\n\n\nReturns\nndarray\ncalibrated amplitude, 2D numpy array or cupy array\n\n\n\n\nrslc = zarr.open('../CLI/raw/rslc.zarr/',mode='r')[:,:,0]\namp = np.abs(rslc)\namp_caled = calamp(amp)\nif is_cuda_available():\n    amp_gpu = cp.asarray(amp)\n    amp_caled_gpu = calamp(amp_gpu)\n    np.testing.assert_array_almost_equal(amp_caled,amp_caled_gpu.get(),decimal=3)\n    # np.testing.assert_array_almost_equal(amp/np.nanmean(amp),amp_caled_gpu.get())\n\n\nfig, ax = plt.subplots(1,1,figsize=(10,10))\npcm = ax.imshow(np.log(amp_caled))\nax.set(title='Calibrated Amplitude in log scale',xlabel='Range Index',ylabel='Azimuth Index')\nfig.colorbar(pcm)\nfig.show()",
    "crumbs": [
      "API",
      "calamp"
    ]
  },
  {
    "objectID": "API/pc.html",
    "href": "API/pc.html",
    "title": "pc",
    "section": "",
    "text": "Two kind of indices are supported. One is called grid index or gix. gix is expressed as sorted int32 array with shape (n_points,2). gix[:,0] is their azimuth indices and gix[:,1] is the range indices. gix is first sorted in azimuth indices and then sorted in range indices. Here is an example:\narray([[0, 2],\n       [1, 0],\n       [1, 3],\n       [3, 2]], dtype=int32)\nThe advantage of gix is that it is directly connected to the original raster indices. While the disadvantage is it does not maintain locality, i.e., two points that are geographical close to each other may not be close to each other in the storage which makes data query (e.g., find all points that within a bounding box) inefficient.\nTo solve that, another kind indices called hillbert index or hix is introduced. hix is expressed as sorted int64 array with shape (n_point,). Note that hix is calculated by gix.\n\n\n\n\n\n\nWarning\n\n\n\nhix of two point cloud datasets calculated with different grids are not compatitable.\n\n\n\n\n\n\n\n\nWarning\n\n\n\nOnly the input idx of pc_sort, pc_hix, pc_gix can be unsorted indices, idx in other functions have to be sorted.\n\n\nPlease see pc_hix for how to generate hix.\n\nimport numpy as np\nfrom moraine.utils_ import is_cuda_available\nif is_cuda_available():\n    import cupy as cp\nfrom matplotlib import pyplot as plt\n\n\nsource\n\npc_hix\n\n pc_hix (gix, shape:tuple)\n\nCompute the hillbert index for point cloud data.\n\n\n\n\nType\nDetails\n\n\n\n\ngix\n\ngrid index\n\n\nshape\ntuple\n(nlines, width)\n\n\nReturns\nndarray\n\n\n\n\nusage:\n\ngix = np.random.choice(np.arange(100*100,dtype=np.int32),size=1000,replace=False)\ngix.sort()\ngix = np.stack(np.unravel_index(gix,shape=(100,100)),axis=-1).astype(np.int32)\nhix = pc_hix(gix, (100,100))\n\n\nplt.scatter(gix[:,1], gix[:,0], c=hix)\nplt.colorbar()\nplt.show()\n\n\n\n\n\n\n\n\nHillbert index have a very useful locality property:\n\nPoints with hillbert indexes close to an index will be geometrically close to the point corresponding to that index.\n\nThis enable fast data query of billions of points. See rtree for data query.\n\nsource\n\n\npc_gix\n\n pc_gix (hix, shape:tuple)\n\nconvert hillbert index to grid index.\n\n\n\n\nType\nDetails\n\n\n\n\nhix\n\nhillbert index\n\n\nshape\ntuple\n(nlines, width)\n\n\nReturns\nndarray\n\n\n\n\n\ngix = np.random.choice(np.arange(100*100,dtype=np.int32),size=1000,replace=False)\ngix.sort()\ngix = np.stack(np.unravel_index(gix,shape=(100,100)),axis=-1).astype(np.int32)\nhix = pc_hix(gix, (100,100))\ngix_ = pc_gix(hix, (100,100))\nnp.testing.assert_array_equal(gix,gix_)\n\n\nsource\n\n\npc_sort\n\n pc_sort (idx:numpy.ndarray, shape:tuple=None)\n\nGet the indices that sort the input.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nidx\nndarray\n\nunsorted gix (2D) or hix(1D)\n\n\nshape\ntuple\nNone\n(nline, width), faster if provided for grid index input\n\n\nReturns\nndarray\n\nindices that sort input\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nOnly the input idx of pc_sort, pc_hix and pc_gix can be unsorted indices, idx in other functions have to be sorted.\n\n\n\ngix = np.stack(([0,1,5,3,4,3],[3,5,2,4,6,8]),axis=-1)\nkey = pc_sort(gix,shape=(6,9))\nnp.testing.assert_equal(gix[key],np.stack(([0,1,3,3,4,5],[3,5,4,8,6,2]),axis=-1))\n\n\nhix = np.array([0,1,5,4,3])\nkey = pc_sort(hix)\nnp.testing.assert_equal(hix[key],np.array([0,1,3,4,5]))\n\n\nsource\n\n\npc2ras\n\n pc2ras (idx:numpy.ndarray, pc_data:numpy.ndarray, shape:tuple)\n\nconvert point cloud data to original raster, filled with nan\n\n\n\n\nType\nDetails\n\n\n\n\nidx\nndarray\ngix or hix array\n\n\npc_data\nndarray\ndata, 1D or more\n\n\nshape\ntuple\nimage shape\n\n\n\n\n# usage:\na = np.arange(1000*50,dtype=np.float32).reshape(1000,50)\ngix = np.random.choice(np.arange(100*50,dtype=np.int32),size=1000,replace=False)\ngix.sort()\ngix = np.stack(np.unravel_index(gix,shape=(100,50)),axis=-1).astype(np.int32)\na_raster = pc2ras(gix,a,shape=(100,50))\nnp.testing.assert_array_equal(a_raster[gix[:,0],gix[:,1]],a)\n# or:\nhix = pc_hix(gix,shape=(100,50))\nkey = pc_sort(hix)\na_raster_ = pc2ras(hix[key],a[key],shape=(100,50))\nnp.testing.assert_array_equal(a_raster,a_raster_)\n\n\nsource\n\n\nras2pc\n\n ras2pc (ras, gix)\n\n\nsource\n\n\npc_union\n\n pc_union (idx1:numpy.ndarray, idx2:numpy.ndarray, shape:tuple=None)\n\nGet the union of two point cloud dataset. For points at their intersection, prefer idx1 rather than idx2\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nidx1\nndarray\n\nint array, grid index or hillbert index of the first point cloud\n\n\nidx2\nndarray\n\nint array, grid index or hillbert index of the second point cloud\n\n\nshape\ntuple\nNone\nimage shape, faster if provided for grid index input\n\n\nReturns\ntuple\n\nthe union index idx; index of the point in output union index that originally in the first point cloud inv_iidx;index of the point in output union index that only exist in the second point cloud inv_iidx2;index of the point in the second input index that are not in the first input point cloud\n\n\n\nUsage:\n\nif is_cuda_available():\n    ras = cp.array([[4,3,8,3],\n                    [4,7,2,6],\n                    [9,0,3,7],\n                    [1,4,2,6]])\n    gix1 = cp.stack((cp.array([0,0,1,1,2,3]),\n                     cp.array([2,3,0,3,1,2])),axis=-1,).astype(cp.int32)\n    gix2 = cp.stack((cp.array([0,0,1,2,2,3]),\n                     cp.array([0,3,1,1,3,1])),axis=-1,).astype(cp.int32)\n    pc_data1 = cp.array([3,2,5,4,32,2])\n    pc_data2 = cp.array([3,5,6,2,1,4])\n    \n    gix, inv_iidx1, inv_iidx2, iidx2 = pc_union(gix1,gix2, shape=(4,4))\n\nWith all the returns in pc_union, it is very easy to construct the union data:\n\nif is_cuda_available():\n    pc_data = cp.empty((gix.shape[0],*pc_data1.shape[1:]),dtype=pc_data1.dtype)\n    pc_data[inv_iidx1] = pc_data1\n    pc_data[inv_iidx2] = pc_data2[iidx2]\n\n    np.testing.assert_equal(cp.asnumpy(pc_data),np.array([3,3,2,5,6,4,32,1,4,2]))\n    np.testing.assert_equal(cp.asnumpy(ras[gix[:,0],gix[:,1]]),np.array([4,8,3,4,7,6,0,7,4,2]))\n\nFor data with hix:\n\nif is_cuda_available():\n    hix1 = cp.array([2,4,6,8,10],dtype=np.int64)\n    hix2 = cp.array([1,2,3,6,9],dtype=np.int64)\n    pc_data1 = cp.array([3,2,5,4,32])\n    pc_data2 = cp.array([3,5,6,2,1])\n    \n    hix, inv_iidx1, inv_iidx2, iidx2 = pc_union(hix1,hix2)\n    \n    pc_data = cp.empty((hix.shape[-1],*pc_data1.shape[1:]),dtype=pc_data1.dtype)\n    pc_data[inv_iidx1] = pc_data1\n    pc_data[inv_iidx2] = pc_data2[iidx2]\n    \n    np.testing.assert_equal(cp.asnumpy(pc_data),np.array([3,3,6,2,5,4,1,32]))\n\n\nsource\n\n\npc_intersect\n\n pc_intersect (idx1:numpy.ndarray, idx2:numpy.ndarray, shape:tuple=None)\n\nGet the intersection of two point cloud dataset.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nidx1\nndarray\n\nint array, grid index or hillbert index of the first point cloud\n\n\nidx2\nndarray\n\nint array, grid index or hillbert index of the second point cloud\n\n\nshape\ntuple\nNone\nimage shape, faster if provided for grid index input\n\n\nReturns\ntuple\n\n\n\n\n\n\nif is_cuda_available():\n    ras = cp.array([[4,3,8,3],\n                    [4,7,2,6],\n                    [9,0,3,7],\n                    [1,4,2,6]])\n    gix1 = cp.stack((cp.array([0,0,1,1,2,3]),\n                     cp.array([2,3,0,3,1,2])),axis=-1,).astype(cp.int32)\n    gix2 = cp.stack((cp.array([0,0,1,2,2,3]),\n                     cp.array([0,3,1,1,3,1])),axis=-1,).astype(cp.int32)\n    pc_data1 = cp.array([3,2,5,4,32,2])\n    pc_data2 = cp.array([3,5,6,2,1,4])\n    \n    gix, iidx1, iidx2 = pc_intersect(gix1,gix2,shape=(4,4))\n    pc_data_int1 = pc_data1[iidx1]\n    pc_data_int2 = pc_data2[iidx2]\n    \n    np.testing.assert_equal(cp.asnumpy(gix),np.array([[0,3],\n                                                      [2,1]]))\n    np.testing.assert_equal(cp.asnumpy(ras[(gix[:,0],gix[:,1])]),np.array([3,0]))\n    np.testing.assert_equal(cp.asnumpy(pc_data_int1),np.array([2,32]))\n    np.testing.assert_equal(cp.asnumpy(pc_data_int2),np.array([5,2]))\n\n\nif is_cuda_available():\n    hix1 = cp.array([2,3,4,7,9,14], dtype=np.int64)\n    hix2 = cp.array([0,3,5,9,11,13],dtype=np.int64)\n    pc_data1 = cp.array([3,2,5,4,32,2])\n    pc_data2 = cp.array([3,5,6,2,1,4])\n    \n    hix, iidx1, iidx2 = pc_intersect(hix1,hix2)\n    pc_data_int1 = pc_data1[iidx1]\n    pc_data_int2 = pc_data2[iidx2]\n    \n    np.testing.assert_equal(cp.asnumpy(hix),np.array([3,9]))\n    np.testing.assert_equal(cp.asnumpy(pc_data_int1),np.array([2,32]))\n    np.testing.assert_equal(cp.asnumpy(pc_data_int2),np.array([5,2]))\n\n\nsource\n\n\npc_diff\n\n pc_diff (idx1:numpy.ndarray, idx2:numpy.ndarray, shape:tuple=None)\n\nGet the point cloud in idx1 that are not in idx2.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nidx1\nndarray\n\nint array, grid index or hillbert index of the first point cloud\n\n\nidx2\nndarray\n\nint array, grid index or hillbert index of the second point cloud\n\n\nshape\ntuple\nNone\nimage shape, faster if provided for grid index input\n\n\nReturns\ntuple\n\nthe diff index idx,index of the point in first point cloud index that do not exist in the second point cloud,\n\n\n\n\nif is_cuda_available():\n    gix1 = cp.stack((cp.array([0,0,1,1,2,3]),\n                     cp.array([2,3,0,3,1,2])),axis=-1,).astype(cp.int32)\n    gix2 = cp.stack((cp.array([0,0,1,2,2,3]),\n                     cp.array([0,3,1,1,3,1])),axis=-1,).astype(cp.int32)\n    \n    gix, iidx1 = pc_diff(gix1,gix2, shape=(4,4))\n    pc_data_diff = pc_data1[iidx1]\n    \n    np.testing.assert_equal(cp.asnumpy(gix),np.stack(([0,1,1,3],[2,0,3,2]),axis=-1))\n    np.testing.assert_equal(cp.asnumpy(iidx1),np.array([0,2,3,5]))\n\n\nif is_cuda_available():\n    hix1 = cp.array([2,3,4,7,9,14], dtype=np.int64)\n    hix2 = cp.array([0,3,5,9,11,13],dtype=np.int64)\n    \n    hix, iidx1 = pc_diff(hix1,hix2)\n    pc_data_diff = pc_data1[iidx1]\n    \n    np.testing.assert_equal(cp.asnumpy(hix),np.array([2,4,7,14]))\n    np.testing.assert_equal(cp.asnumpy(iidx1),np.array([0,2,3,5]))",
    "crumbs": [
      "API",
      "pc"
    ]
  },
  {
    "objectID": "API/utils_.html",
    "href": "API/utils_.html",
    "title": "utils",
    "section": "",
    "text": "source\n\nis_cuda_available\n\n is_cuda_available ()\n\n\nsource\n\n\nget_n_cpus_avail\n\n get_n_cpus_avail ()\n\n\nsource\n\n\nget_array_module\n\n get_array_module (array)"
  },
  {
    "objectID": "API/dl.html",
    "href": "API/dl.html",
    "title": "dl",
    "section": "",
    "text": "source\n\ndownload_dl_model\n\n download_dl_model (models:str|list=None, path:str=None)\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nmodels\nstr | list\nNone\ndeep learning models to be downloaded, all available models by default\n\n\npath\nstr\nNone\ndirectory to save these models, inside installed Moraine package by default\n\n\n\nDeep learning models have to be installed before use, download them by:\n\ndownload_dl_model()\n\nDownloading https://raw.githubusercontent.com/kanglcn/n2f/refs/heads/main/n2f.onnx to /work/projects/jinwook/radarlab/kangl/moraine/moraine/dl_model/n2f.onnx\nFile '/work/projects/jinwook/radarlab/kangl/moraine/moraine/dl_model/n2f.onnx' downloaded successfully.\nDownloading https://raw.githubusercontent.com/kanglcn/n2f/refs/heads/main/n2fs3d.onnx to /work/projects/jinwook/radarlab/kangl/moraine/moraine/dl_model/n2fs3d.onnx\nFile '/work/projects/jinwook/radarlab/kangl/moraine/moraine/dl_model/n2fs3d.onnx' downloaded successfully.\nDownloading https://raw.githubusercontent.com/kanglcn/n2ft/refs/heads/main/n2ft.onnx to /work/projects/jinwook/radarlab/kangl/moraine/moraine/dl_model/n2ft.onnx\nFile '/work/projects/jinwook/radarlab/kangl/moraine/moraine/dl_model/n2ft.onnx' downloaded successfully.\nDownloading https://raw.githubusercontent.com/kanglcn/n2ft/refs/heads/main/n2ft.onnx.data to /work/projects/jinwook/radarlab/kangl/moraine/moraine/dl_model/n2ft.onnx.data\nFile '/work/projects/jinwook/radarlab/kangl/moraine/moraine/dl_model/n2ft.onnx.data' downloaded successfully.\n\n\n\nsource\n\n\nn2f\n\n n2f (intf:numpy.ndarray, chunks:tuple=None, depths:tuple=(0, 0),\n      model:str=None)\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nintf\nndarray\n\ninterferogram, 2d np.complex64 or cp.complex64\n\n\nchunks\ntuple\nNone\nchunksize, intf.shape by default\n\n\ndepths\ntuple\n(0, 0)\nwidth of the boundary\n\n\nmodel\nstr\nNone\npath to the model in onnx format, use the model comes with this package by default\n\n\n\nUsage:\n\nimport zarr\nimport numpy as np\nimport holoviews as hv\nhv.extension('bokeh')\nhv.output(widget_location='bottom')\nfrom bokeh.models import WheelZoomTool\nfrom holoviews import opts\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n  \n  \n\n\n\n\n\n\n\n\nⓘ\n\n\n\n\n\nrslc_zarr = zarr.open('../CLI/raw/rslc.zarr/',mode='r')\nintf = rslc_zarr[:,:,7]*rslc_zarr[:,:,13].conj()\n\n\nintf.shape\n\n(2500, 1834)\n\n\n\nfiltered_intf = n2f(intf,depths=(10,10))\n\nCPU times: user 3min 56s, sys: 40.6 s, total: 4min 36s\nWall time: 4.16 s\n\n\n\nraw_intf_plot = mr.ras_plot(np.angle(intf))\nfiltered_intf_plot = mr.ras_plot(np.angle(filtered_intf))\n(raw_intf_plot+filtered_intf_plot).opts(\n    opts.Image(\n        cmap='colorwheel',width=600, height=600, colorbar=True,invert_yaxis=True,\n        default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],\n        active_tools=['wheel_zoom'])\n)\n\n\n\n\n\n  \n\n\n\n\n\nsource\n\n\nn2fs3d\n\n n2fs3d (adi:numpy.ndarray, intf:numpy.ndarray, chunks:tuple=None,\n         depths:tuple=(0, 0), model:str=None)\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nadi\nndarray\n\namplitude dispersion index, 2d np.float32 or cp.float32\n\n\nintf\nndarray\n\ninterferogram, 2d np.complex64 or cp.complex64\n\n\nchunks\ntuple\nNone\nchunksize, intf.shape by default\n\n\ndepths\ntuple\n(0, 0)\nwidth of the boundary\n\n\nmodel\nstr\nNone\npath to the model in onnx format, use the model comes with this package by default\n\n\n\nUsage:\n\nimport zarr\nimport numpy as np\nimport holoviews as hv\nhv.extension('bokeh')\nhv.output(widget_location='bottom')\nfrom bokeh.models import WheelZoomTool\nfrom holoviews import opts\n\n\n\n\n\n\n\n\n\n\n\nrslc_zarr = zarr.open('../CLI/raw/rslc.zarr/',mode='r')\nintf = rslc_zarr[:,:,7]*rslc_zarr[:,:,13].conj()\nadi = zarr.open('../CLI/ps/adi.zarr/',mode='r')[:]\n\n\nfiltered_intf = n2fs3d(adi,intf,depths=(200,200))\n\nCPU times: user 3min 52s, sys: 40 s, total: 4min 32s\nWall time: 4.11 s\n\n\n\nif is_cuda_available():\n    intf_cp = cp.asarray(intf)\n    adi_cp = cp.asarray(adi)\n    filtered_intf_cp = n2fs3d(adi_cp,intf_cp)\n\nCPU times: user 3.35 s, sys: 222 ms, total: 3.57 s\nWall time: 474 ms\n\n\n\nsource\n\n\nn2ft\n\n n2ft (x:numpy.ndarray, y:numpy.ndarray, intf:numpy.ndarray,\n       chunks:int=None, k:int=128, model:str=None, cuda:bool=False)\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nx\nndarray\n\nx coordinate, e.g., longitude, shape (n,) np.floating\n\n\ny\nndarray\n\ny coordinate, e.g., latitude, shape (n,) np.floating\n\n\nintf\nndarray\n\ninterferogram, shape(n,) np.complex64\n\n\nchunks\nint\nNone\nchunksize, intf.shape[0] by default\n\n\nk\nint\n128\nhalo size for chunkwise processing\n\n\nmodel\nstr\nNone\npath to the model in onnx format, use the model comes with this package by default\n\n\ncuda\nbool\nFalse\nuse gpu for inference\n\n\n\nUsage:\n\nimport zarr\n\n\nbase = '../Tutorials/CLI/ps_processing/'\nps_can_rslc_zarr = zarr.open(base+'hix/ps_can_rslc.zarr/',mode='r')\nps_can_y = zarr.open(base+'hix/ps_can_n.zarr',mode='r')[:]\nps_can_x = zarr.open(base+'hix/ps_can_e.zarr',mode='r')[:]\nps_can_lon = zarr.open(base+'hix/ps_can_lon.zarr',mode='r')[:]\nps_can_lat = zarr.open(base+'hix/ps_can_lat.zarr',mode='r')[:]\nps_can_intf = ps_can_rslc_zarr[:,10]*ps_can_rslc_zarr[:,13].conj()\n\n\nout = n2ft(ps_can_lon, ps_can_lat, ps_can_intf,)\n\nCPU times: user 1min 31s, sys: 9.88 s, total: 1min 41s\nWall time: 3.51 s\n\n\n\nout = n2ft(ps_can_lon, ps_can_lat, ps_can_intf,cuda=True)\n\nCPU times: user 15.5 s, sys: 272 ms, total: 15.7 s\nWall time: 575 ms\n\n\n\nout = n2ft(ps_can_lon, ps_can_lat, ps_can_intf, chunks=2000)\n\nCPU times: user 10min 29s, sys: 6.21 s, total: 10min 35s\nWall time: 13.4 s\n\n\n\nimport moraine as mr\nimport holoviews as hv\nimport numpy as np\nimport zarr\nfrom holoviews import opts\nfrom bokeh.models import WheelZoomTool\nhv.extension('bokeh')\n\n\n\n\n\n\n\n\n\n\n\nintf_plot = mr.pc_plot(np.angle(ps_can_intf),ps_can_y,ps_can_x)\nintf_filt_plot = mr.pc_plot(np.angle(out),ps_can_y,ps_can_x)\n\n\nintf_plot = intf_plot.redim(\n    x=hv.Dimension('lon', label='Longitude'), y=hv.Dimension('lat',label='Latitude'),\n    z=hv.Dimension('intf',label='Phase',range=(-np.pi,np.pi)),\n)\nintf_filt_plot = intf_filt_plot.redim(\n    x=hv.Dimension('lon', label='Longitude'), y=hv.Dimension('lat',label='Latitude'),\n    z=hv.Dimension('intf',label='Phase',range=(-np.pi,np.pi)),\n)\n\n\n(intf_plot+intf_filt_plot).opts(\n    opts.Image(\n        cmap='colorwheel',width=600, height=400, colorbar=True,\n        default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],\n        active_tools=['wheel_zoom']\n    ),\n    opts.Points(\n        color='intf', cmap='colorwheel',width=600, height=400, colorbar=True,\n        default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],\n        active_tools=['wheel_zoom']\n    )\n)",
    "crumbs": [
      "API",
      "dl"
    ]
  },
  {
    "objectID": "Tutorials/ds_processing.html",
    "href": "Tutorials/ds_processing.html",
    "title": "DS Processing",
    "section": "",
    "text": "In this tutorial, we demostrate how to do standard DS processing with the Moraine package.\nimport numpy as np\nimport zarr\nfrom matplotlib import pyplot as plt\nimport colorcet\n\nfrom moraine.utils_ import is_cuda_available\nif is_cuda_available():\n    import cupy as cp\n    from cupyx.scipy.ndimage import uniform_filter\n\nimport moraine as mr",
    "crumbs": [
      "Tutorials",
      "API",
      "DS Processing"
    ]
  },
  {
    "objectID": "Tutorials/ds_processing.html#load-rslc-stack",
    "href": "Tutorials/ds_processing.html#load-rslc-stack",
    "title": "DS Processing",
    "section": "Load rslc stack",
    "text": "Load rslc stack\n\nif is_cuda_available():\n    rslc = cp.asarray(zarr.open('../../data/rslc.zarr',mode='r')[:])\n    print(rslc.shape)\n\n(2500, 1834, 17)",
    "crumbs": [
      "Tutorials",
      "API",
      "DS Processing"
    ]
  },
  {
    "objectID": "Tutorials/ds_processing.html#apply-ks-test",
    "href": "Tutorials/ds_processing.html#apply-ks-test",
    "title": "DS Processing",
    "section": "Apply ks test",
    "text": "Apply ks test\n\nif is_cuda_available():\n    rmli = cp.abs(rslc)**2\n\n\naz_half_win = 5\nr_half_win = 5\naz_win = 2*az_half_win+1\nr_win = 2*r_half_win+1\n\n\nif is_cuda_available():\n    p = mr.ks_test(rmli,az_half_win=az_half_win,r_half_win=r_half_win)",
    "crumbs": [
      "Tutorials",
      "API",
      "DS Processing"
    ]
  },
  {
    "objectID": "Tutorials/ds_processing.html#select-shps",
    "href": "Tutorials/ds_processing.html#select-shps",
    "title": "DS Processing",
    "section": "Select SHPs",
    "text": "Select SHPs\n\nif is_cuda_available():\n    is_shp = (p &lt; 0.05) & (p &gt;= 0.0)\n    del p\n\n\nif is_cuda_available():\n    shp_num = cp.count_nonzero(is_shp,axis=(-2,-1))\n\n\nif is_cuda_available():\n    fig, ax = plt.subplots(1,1,figsize=(10,10))\n    pcm = ax.imshow(cp.asnumpy(shp_num),cmap=colorcet.cm.fire)\n    ax.set(title='Number of SHPs',xlabel='Range Index',ylabel='Azimuth Index')\n    fig.colorbar(pcm)\n    fig.show()",
    "crumbs": [
      "Tutorials",
      "API",
      "DS Processing"
    ]
  },
  {
    "objectID": "Tutorials/ds_processing.html#select-dss",
    "href": "Tutorials/ds_processing.html#select-dss",
    "title": "DS Processing",
    "section": "Select DSs",
    "text": "Select DSs\nHere we select DSs candidate as pixels have more than 50 brothers.\n\nif is_cuda_available():\n    is_ds_can = shp_num &gt;= 50\n    del shp_num\n\nThe number of DSs:\n\nif is_cuda_available():\n    cp.count_nonzero(is_ds_can)\n\nThe DSs distribution:\n\nif is_cuda_available():\n    fig, ax = plt.subplots(1,1,figsize=(10,10))\n    pcm = ax.imshow(cp.asnumpy(is_ds_can),cmap=colorcet.cm.fire)\n    ax.set(title='DS Candidate distribution',xlabel='Range Index',ylabel='Azimuth Index')\n    fig.colorbar(pcm)\n    fig.show()",
    "crumbs": [
      "Tutorials",
      "API",
      "DS Processing"
    ]
  },
  {
    "objectID": "Tutorials/ds_processing.html#estimate-coherence-matrix",
    "href": "Tutorials/ds_processing.html#estimate-coherence-matrix",
    "title": "DS Processing",
    "section": "Estimate coherence matrix",
    "text": "Estimate coherence matrix\nIn order to save memory, here we only estimate coherence matrix on selected DSs:\n\nif is_cuda_available():\n    ds_can_is_shp = is_shp[is_ds_can]\n    ds_can_idx = cp.stack(cp.where(is_ds_can),axis=-1)\n    ds_can_coh = mr.emperical_co_pc(rslc,ds_can_idx,ds_can_is_shp)\n    del is_shp\n\nPlot the average coherence matrix:\n\nif is_cuda_available():\n    ds_can_ave_coh = abs(ds_can_coh).mean(axis=0)\n    ds_can_ave_coh_uncompressed = mr.uncompress_coh(ds_can_ave_coh)\n    print(ds_can_ave_coh.shape,ds_can_ave_coh_uncompressed.shape)\n\n(136,) (17, 17)\n\n\n\nfig, ax = plt.subplots(1,1,figsize=(15,10))\npcm = ax.imshow(ds_can_ave_coh_uncompressed.get(),cmap=colorcet.cm.fire)\nax.set(title='Average Coherence Matrix',xlabel='Image Index',ylabel='Image Index')\nfig.colorbar(pcm)\nfig.show()\n\n\n\n\n\n\n\n\nThe coherence between the 5-th SLC and other SLC are bad. We may consider removing this image.",
    "crumbs": [
      "Tutorials",
      "API",
      "DS Processing"
    ]
  },
  {
    "objectID": "Tutorials/ds_processing.html#phase-linking",
    "href": "Tutorials/ds_processing.html#phase-linking",
    "title": "DS Processing",
    "section": "Phase linking",
    "text": "Phase linking\nHere we apply the EMI method:\n\nif is_cuda_available():\n    ds_can_ph, ds_can_emi_quality = mr.emi(ds_can_coh)\n    print(ds_can_ph.shape, ds_can_emi_quality.shape)\n\n(732727, 17) (732727,)\n\n\n\nif is_cuda_available():\n    ds_can_emi_quality_2d = cp.empty_like(is_ds_can,dtype=ds_can_emi_quality.dtype)\n    ds_can_emi_quality_2d[:] = cp.nan\n    ds_can_emi_quality_2d[is_ds_can] = ds_can_emi_quality\n\n\nif is_cuda_available():\n    fig, ax = plt.subplots(1,1,figsize=(10,10))\n    pcm = ax.imshow(cp.asnumpy(ds_can_emi_quality_2d),interpolation='nearest',vmin=1,vmax=1.3)\n    ax.set(title='DS EMI quality factor',xlabel='Range Index',ylabel='Azimuth Index')\n    fig.colorbar(pcm)\n    fig.show()\n\n\n\n\n\n\n\n\n\nif is_cuda_available():\n    ds_can_temp_coh = mr.ds_temp_coh(ds_can_coh,ds_can_ph)\n    print(ds_can_temp_coh.shape)\n\n(732727,)\n\n\n\nif is_cuda_available():\n    ds_can_temp_coh_2d = cp.empty_like(is_ds_can,dtype=ds_can_temp_coh.dtype)\n    ds_can_temp_coh_2d[:] = cp.nan\n    ds_can_temp_coh_2d[is_ds_can] = ds_can_temp_coh\n    fig, ax = plt.subplots(1,1,figsize=(10,10))\n    pcm = ax.imshow(cp.asnumpy(ds_can_temp_coh_2d),interpolation='nearest')\n    ax.set(title='DS Temporal Coherence',xlabel='Range Index',ylabel='Azimuth Index')\n    fig.colorbar(pcm)\n    fig.show()",
    "crumbs": [
      "Tutorials",
      "API",
      "DS Processing"
    ]
  },
  {
    "objectID": "Tutorials/ds_processing.html#refine-ds-candidate",
    "href": "Tutorials/ds_processing.html#refine-ds-candidate",
    "title": "DS Processing",
    "section": "Refine DS candidate",
    "text": "Refine DS candidate\nHere we select DS candidate based on EMI quality factor and temporal coherence:\n\nif is_cuda_available():\n    _is_ds_can_refined = (ds_can_emi_quality&gt;=1.0) & (ds_can_emi_quality &lt;1.2) & (ds_can_temp_coh &gt; 0.7) & (ds_can_temp_coh &lt;= 1.0)\n\n\nif is_cuda_available():\n    ds_can_refined_idx = ds_can_idx[_is_ds_can_refined]\n    is_ds_can_refined = cp.zeros_like(is_ds_can,dtype=bool)\n    is_ds_can_refined[ds_can_refined_idx[:,0],ds_can_refined_idx[:,1]] = True\n\n\nif is_cuda_available():\n    ds_can_refined_coh = ds_can_coh[_is_ds_can_refined]\n    ds_can_refined_ph = ds_can_ph[_is_ds_can_refined]\n    ds_can_refined_coh.shape\n\nPlot the average coherence matrix and refined DS candiate distribution:\n\nif is_cuda_available():\n    ds_can_refined_ave_coh = abs(ds_can_refined_coh).mean(axis=0)\n    ds_can_refined_ave_coh_uncompressed = mr.uncompress_coh(ds_can_refined_ave_coh)\n    fig, ax = plt.subplots(1,1,figsize=(15,10))\n    pcm = ax.imshow(cp.asnumpy(ds_can_refined_ave_coh_uncompressed),cmap=colorcet.cm.fire)\n    ax.set(title='Average Coherence Matrix',xlabel='Image Index',ylabel='Image Index')\n    fig.colorbar(pcm)\n    fig.show()\n\n\n\n\n\n\n\n\n\nif is_cuda_available():\n    fig, ax = plt.subplots(1,1,figsize=(10,10))\n    pcm = ax.imshow(cp.asnumpy(is_ds_can_refined),cmap=colorcet.cm.fire)\n    ax.set(title='DS Candidate Refined distribution',xlabel='Range Index',ylabel='Azimuth Index')\n    fig.colorbar(pcm)\n    fig.show()\n\n\n\n\n\n\n\n\nWe find the coherence matrix gets better and noisy pixels are moved.",
    "crumbs": [
      "Tutorials",
      "API",
      "DS Processing"
    ]
  },
  {
    "objectID": "Tutorials/CLI/ps_processing.html",
    "href": "Tutorials/CLI/ps_processing.html",
    "title": "PS Processing",
    "section": "",
    "text": "In this tutorial, we demostrate how to do PS processing with the decorrelation CLI interface. The input data for PS processing is prepared in Load Data.\n!ls ./load_data\n\ne.zarr    lat.zarr  meta.toml  phi.zarr    rslc_pyramid  scratch\nhgt.zarr  lon.zarr  n.zarr     range.zarr  rslc.zarr     theta.zarr",
    "crumbs": [
      "Tutorials",
      "CLI",
      "PS Processing"
    ]
  },
  {
    "objectID": "Tutorials/CLI/ps_processing.html#ps-candidates-selection",
    "href": "Tutorials/CLI/ps_processing.html#ps-candidates-selection",
    "title": "PS Processing",
    "section": "PS candidates selection",
    "text": "PS candidates selection\n\nAmplitude dispersion index calculation\nHere were calculate the amplitude dispersion index (ADI) which is used to identify persistent scatterer candidates.\n\nimport zarr\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport colorcet\nimport moraine.cli as mc\nimport moraine as mr\n\n\nrslc = './load_data/rslc.zarr'\nadi = './ps_processing/gix/ras_adi.zarr'\nrslc_zarr = zarr.open(rslc, mode='r')\n\n\nlogger = mc.get_logger()\n\n\nmc.amp_disp(rslc,adi)\n\n2025-09-20 23:54:56 - log_args - INFO - running function: amp_disp\n2025-09-20 23:54:56 - log_args - INFO - fetching args:\n2025-09-20 23:54:56 - log_args - INFO - rslc = './load_data/rslc.zarr'\n2025-09-20 23:54:56 - log_args - INFO - adi = './ps_processing/gix/ras_adi.zarr'\n2025-09-20 23:54:56 - log_args - INFO - chunks = None\n2025-09-20 23:54:56 - log_args - INFO - out_chunks = None\n2025-09-20 23:54:56 - log_args - INFO - cuda = False\n2025-09-20 23:54:56 - log_args - INFO - processes = None\n2025-09-20 23:54:56 - log_args - INFO - n_workers = None\n2025-09-20 23:54:56 - log_args - INFO - threads_per_worker = None\n2025-09-20 23:54:56 - log_args - INFO - rmm_pool_size = 0.9\n2025-09-20 23:54:56 - log_args - INFO - dask_cluster_arg = {}\n2025-09-20 23:54:56 - log_args - INFO - fetching args done.\n2025-09-20 23:54:56 - zarr_info - INFO - ./load_data/rslc.zarr zarray shape, chunks, dtype: (2500, 1834, 17), (1000, 1000, 1), complex64\n2025-09-20 23:54:56 - amp_disp - INFO - starting dask local cluster.\n2025-09-20 23:54:58 - amp_disp - INFO - dask local cluster started.\n2025-09-20 23:54:58 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.10:8787/status', workers=1, threads=1, memory=1.95 TiB)\n2025-09-20 23:54:58 - darr_info - INFO - rslc dask array shape, chunksize, dtype: (2500, 1834, 17), (1000, 1000, 17), complex64\n2025-09-20 23:54:58 - amp_disp - INFO - calculate amplitude dispersion index.\n2025-09-20 23:54:58 - amp_disp - INFO - got amplitude dispersion index.\n2025-09-20 23:54:58 - darr_info - INFO - adi dask array shape, chunksize, dtype: (2500, 1834), (1000, 1000), float32\n2025-09-20 23:54:58 - darr_info - INFO - adi dask array shape, chunksize, dtype: (2500, 1834), (1000, 1000), float32\n2025-09-20 23:54:58 - amp_disp - INFO - saving adi.\n2025-09-20 23:54:58 - zarr_info - INFO - ./ps_processing/gix/ras_adi.zarr zarray shape, chunks, dtype: (2500, 1834), (1000, 1000), float32\n2025-09-20 23:54:58 - amp_disp - INFO - computing graph setted. doing all the computing.\n2025-09-20 23:54:59 - amp_disp - INFO - computing finished. |  0.9s\n2025-09-20 23:54:59 - amp_disp - INFO - dask cluster closed.\n\n\nThen visualize the amplitude dispersion index. Since the data is small, we can visualize it with the API plot module moraine.plot. If you want to reduce the memory consumption, the CLI plot module moraine.cli.plot can be used. But the pyramid should be generated ahead.\n\nadi_data = zarr.open(adi,mode='r')[:]\nadi_plot = mr.ras_plot(adi_data)\n\n\nimport holoviews as hv\nfrom bokeh.models import WheelZoomTool\nfrom holoviews import opts\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n  \n  \n\n\n\n\n\n\n\n\nⓘ\n\n\n\n\n\nhv.extension('bokeh')\n\n\nadi_plot = adi_plot.redim(x=hv.Dimension('r', label='Range'), y=hv.Dimension('az',label='Azimuth'), z=hv.Dimension('adi',range=(0,1)))\n\n\nadi_plot.opts(opts.Image(cmap='viridis',width=600, height=600, colorbar=True,\n                          invert_yaxis=True,\n                          default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],active_tools=['wheel_zoom']))\n\n\n\n\n\n  \n\n\n\n\nThen we can select PS candidates by setting a threshold to the amplitude dispersion index:\n\nps_can_1_gix = './ps_processing/gix/ps_can_1_gix.zarr'\nmc.pc_logic_ras(adi, ps_can_1_gix, 'ras&lt;0.4', chunks=200000)\n\n2025-09-20 23:55:01 - log_args - INFO - running function: pc_logic_ras\n2025-09-20 23:55:01 - log_args - INFO - fetching args:\n2025-09-20 23:55:01 - log_args - INFO - ras = './ps_processing/gix/ras_adi.zarr'\n2025-09-20 23:55:01 - log_args - INFO - gix = './ps_processing/gix/ps_can_1_gix.zarr'\n2025-09-20 23:55:01 - log_args - INFO - operation = 'ras&lt;0.4'\n2025-09-20 23:55:01 - log_args - INFO - chunks = 200000\n2025-09-20 23:55:01 - log_args - INFO - fetching args done.\n2025-09-20 23:55:01 - zarr_info - INFO - ./ps_processing/gix/ras_adi.zarr zarray shape, chunks, dtype: (2500, 1834), (1000, 1000), float32\n2025-09-20 23:55:01 - pc_logic_ras - INFO - loading ras into memory.\n2025-09-20 23:55:01 - pc_logic_ras - INFO - select pc based on operation: ras&lt;0.4\n2025-09-20 23:55:01 - pc_logic_ras - INFO - number of selected pixels: 390525.\n2025-09-20 23:55:01 - zarr_info - INFO - ./ps_processing/gix/ps_can_1_gix.zarr zarray shape, chunks, dtype: (390525, 2), (200000, 1), int32\n2025-09-20 23:55:01 - pc_logic_ras - INFO - writing gix.\n2025-09-20 23:55:01 - pc_logic_ras - INFO - write done.\n\n\n\n\nNoise2Fringe\nHere we use Noise2Fringe to select another set of PS candidates.\n\ntnet = mr.TempNet.from_bandwidth(rslc_zarr.shape[-1],bandwidth=1)\n\n\ntnet.image_pairs\n\narray([[ 0,  1],\n       [ 1,  2],\n       [ 2,  3],\n       [ 3,  4],\n       [ 4,  5],\n       [ 5,  6],\n       [ 6,  7],\n       [ 7,  8],\n       [ 8,  9],\n       [ 9, 10],\n       [10, 11],\n       [11, 12],\n       [12, 13],\n       [13, 14],\n       [14, 15],\n       [15, 16]], dtype=int32)\n\n\n\nn2f_intf = './ps_processing/gix/ras_n2f_intf.zarr'\nmc.n2f(rslc, n2f_intf, tnet.image_pairs, cuda=True)\n\n2025-09-20 23:55:01 - log_args - INFO - running function: n2f\n2025-09-20 23:55:01 - log_args - INFO - fetching args:\n2025-09-20 23:55:01 - log_args - INFO - rslc = './load_data/rslc.zarr'\n2025-09-20 23:55:01 - log_args - INFO - intf = './ps_processing/gix/ras_n2f_intf.zarr'\n2025-09-20 23:55:01 - log_args - INFO - image_pairs = array([[ 0,  1],\n       [ 1,  2],\n       [ 2,  3],\n       [ 3,  4],\n       [ 4,  5],\n       [ 5,  6],\n       [ 6,  7],\n       [ 7,  8],\n       [ 8,  9],\n       [ 9, 10],\n       [10, 11],\n       [11, 12],\n       [12, 13],\n       [13, 14],\n       [14, 15],\n       [15, 16]], dtype=int32)\n2025-09-20 23:55:01 - log_args - INFO - chunks = None\n2025-09-20 23:55:01 - log_args - INFO - out_chunks = None\n2025-09-20 23:55:01 - log_args - INFO - depths = (0, 0)\n2025-09-20 23:55:01 - log_args - INFO - model = None\n2025-09-20 23:55:01 - log_args - INFO - cuda = True\n2025-09-20 23:55:01 - log_args - INFO - processes = None\n2025-09-20 23:55:01 - log_args - INFO - n_workers = None\n2025-09-20 23:55:01 - log_args - INFO - threads_per_worker = None\n2025-09-20 23:55:01 - log_args - INFO - rmm_pool_size = 0.5\n2025-09-20 23:55:01 - log_args - INFO - dask_cluster_arg = {}\n2025-09-20 23:55:01 - log_args - INFO - fetching args done.\n2025-09-20 23:55:01 - zarr_info - INFO - ./load_data/rslc.zarr zarray shape, chunks, dtype: (2500, 1834, 17), (1000, 1000, 1), complex64\n2025-09-20 23:55:01 - n2f - INFO - processing azimuth chunk size: 1000\n2025-09-20 23:55:01 - n2f - INFO - processing range chunk size: 1000\n2025-09-20 23:55:01 - n2f - INFO - starting dask cluster.\n2025-09-20 23:55:07 - n2f - INFO - dask cluster started.\n2025-09-20 23:55:07 - dask_cluster_info - INFO - dask cluster: LocalCUDACluster(dashboard_link='http://127.0.0.1:8787/status', workers=8, threads=8, memory=1.95 TiB)\n2025-09-20 23:55:07 - darr_info - INFO - rslc dask array shape, chunksize, dtype: (2500, 1834, 17), (2500, 1834, 1), complex64\n2025-09-20 23:55:07 - n2f - INFO - got filtered interferograms.\n2025-09-20 23:55:07 - darr_info - INFO - intf dask array shape, chunksize, dtype: (2500, 1834, 16), (2500, 1834, 1), complex64\n2025-09-20 23:55:07 - n2f - INFO - saving filtered interferograms.\n2025-09-20 23:55:07 - zarr_info - INFO - ./ps_processing/gix/ras_n2f_intf.zarr zarray shape, chunks, dtype: (2500, 1834, 16), (1000, 1000, 1), complex64\n2025-09-20 23:55:07 - n2f - INFO - computing graph setted. doing all the computing.\n2025-09-20 23:55:12 - n2f - INFO - computing finished.leted |  5.1s\n2025-09-20 23:55:14 - n2f - INFO - dask cluster closed.\n\n\nThen we estimate a temporal coherence:\n\ntemp_coh = './ps_processing/gix/ras_temp_coh.zarr'\ntnet = mr.TempNet.from_bandwidth(rslc_zarr.shape[-1],1)\n\n\nmc.temp_coh(n2f_intf, rslc, temp_coh, tnet.image_pairs)\n\n2025-09-20 23:55:14 - log_args - INFO - running function: temp_coh\n2025-09-20 23:55:14 - log_args - INFO - fetching args:\n2025-09-20 23:55:14 - log_args - INFO - intf = './ps_processing/gix/ras_n2f_intf.zarr'\n2025-09-20 23:55:14 - log_args - INFO - rslc = './load_data/rslc.zarr'\n2025-09-20 23:55:14 - log_args - INFO - t_coh = './ps_processing/gix/ras_temp_coh.zarr'\n2025-09-20 23:55:14 - log_args - INFO - image_pairs = array([[ 0,  1],\n       [ 1,  2],\n       [ 2,  3],\n       [ 3,  4],\n       [ 4,  5],\n       [ 5,  6],\n       [ 6,  7],\n       [ 7,  8],\n       [ 8,  9],\n       [ 9, 10],\n       [10, 11],\n       [11, 12],\n       [12, 13],\n       [13, 14],\n       [14, 15],\n       [15, 16]], dtype=int32)\n2025-09-20 23:55:14 - log_args - INFO - chunks = None\n2025-09-20 23:55:14 - log_args - INFO - cuda = False\n2025-09-20 23:55:14 - log_args - INFO - processes = None\n2025-09-20 23:55:14 - log_args - INFO - n_workers = None\n2025-09-20 23:55:14 - log_args - INFO - threads_per_worker = None\n2025-09-20 23:55:14 - log_args - INFO - rmm_pool_size = 0.9\n2025-09-20 23:55:14 - log_args - INFO - dask_cluster_arg = {}\n2025-09-20 23:55:14 - log_args - INFO - fetching args done.\n2025-09-20 23:55:14 - zarr_info - INFO - ./ps_processing/gix/ras_n2f_intf.zarr zarray shape, chunks, dtype: (2500, 1834, 16), (1000, 1000, 1), complex64\n2025-09-20 23:55:14 - zarr_info - INFO - ./load_data/rslc.zarr zarray shape, chunks, dtype: (2500, 1834, 17), (1000, 1000, 1), complex64\n2025-09-20 23:55:14 - temp_coh - INFO - starting dask local cluster.\n2025-09-20 23:55:14 - temp_coh - INFO - dask local cluster started.\n2025-09-20 23:55:14 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.10:8787/status', workers=1, threads=1, memory=1.95 TiB)\n2025-09-20 23:55:14 - darr_info - INFO - intf dask array shape, chunksize, dtype: (2500, 1834, 16), (1000, 1000, 16), complex64\n2025-09-20 23:55:14 - darr_info - INFO - rslc dask array shape, chunksize, dtype: (2500, 1834, 17), (1000, 1000, 17), complex64\n2025-09-20 23:55:14 - temp_coh - INFO - Estimate temporal coherence for DS.\n2025-09-20 23:55:14 - temp_coh - INFO - got temporal coherence t_coh.\n2025-09-20 23:55:14 - darr_info - INFO - t_coh dask array shape, chunksize, dtype: (2500, 1834), (1000, 1000), float32\n2025-09-20 23:55:14 - temp_coh - INFO - saving t_coh.\n2025-09-20 23:55:14 - temp_coh - INFO - computing graph setted. doing all the computing.\n2025-09-20 23:55:16 - temp_coh - INFO - computing finished. |  1.8s\n2025-09-20 23:55:16 - temp_coh - INFO - dask cluster closed.\n\n\nAnd select another set of PS candidates:\n\nps_can_2_gix = './ps_processing/gix/ps_can_2_gix.zarr'\nmc.pc_logic_ras(temp_coh, ps_can_2_gix, 'ras&gt;0.58', chunks=20000)\n\n2025-09-20 23:55:16 - log_args - INFO - running function: pc_logic_ras\n2025-09-20 23:55:16 - log_args - INFO - fetching args:\n2025-09-20 23:55:16 - log_args - INFO - ras = './ps_processing/gix/ras_temp_coh.zarr'\n2025-09-20 23:55:16 - log_args - INFO - gix = './ps_processing/gix/ps_can_2_gix.zarr'\n2025-09-20 23:55:16 - log_args - INFO - operation = 'ras&gt;0.58'\n2025-09-20 23:55:16 - log_args - INFO - chunks = 20000\n2025-09-20 23:55:16 - log_args - INFO - fetching args done.\n2025-09-20 23:55:16 - zarr_info - INFO - ./ps_processing/gix/ras_temp_coh.zarr zarray shape, chunks, dtype: (2500, 1834), (1000, 1000), float32\n2025-09-20 23:55:16 - pc_logic_ras - INFO - loading ras into memory.\n2025-09-20 23:55:16 - pc_logic_ras - INFO - select pc based on operation: ras&gt;0.58\n2025-09-20 23:55:16 - pc_logic_ras - INFO - number of selected pixels: 374510.\n2025-09-20 23:55:16 - zarr_info - INFO - ./ps_processing/gix/ps_can_2_gix.zarr zarray shape, chunks, dtype: (374510, 2), (20000, 1), int32\n2025-09-20 23:55:16 - pc_logic_ras - INFO - writing gix.\n2025-09-20 23:55:16 - pc_logic_ras - INFO - write done.\n\n\n\n\nMerge two candidates set\n\nps_can_gix = './ps_processing/gix/ps_can_gix.zarr'\nmc.pc_union(ps_can_1_gix, ps_can_2_gix, ps_can_gix)\n\n2025-09-20 23:55:16 - log_args - INFO - running function: pc_union\n2025-09-20 23:55:16 - log_args - INFO - fetching args:\n2025-09-20 23:55:16 - log_args - INFO - idx1 = './ps_processing/gix/ps_can_1_gix.zarr'\n2025-09-20 23:55:16 - log_args - INFO - idx2 = './ps_processing/gix/ps_can_2_gix.zarr'\n2025-09-20 23:55:16 - log_args - INFO - idx = './ps_processing/gix/ps_can_gix.zarr'\n2025-09-20 23:55:16 - log_args - INFO - pc1 = None\n2025-09-20 23:55:16 - log_args - INFO - pc2 = None\n2025-09-20 23:55:16 - log_args - INFO - pc = None\n2025-09-20 23:55:16 - log_args - INFO - shape = None\n2025-09-20 23:55:16 - log_args - INFO - chunks = None\n2025-09-20 23:55:16 - log_args - INFO - processes = False\n2025-09-20 23:55:16 - log_args - INFO - n_workers = 1\n2025-09-20 23:55:16 - log_args - INFO - threads_per_worker = 1\n2025-09-20 23:55:16 - log_args - INFO - dask_cluster_arg = {}\n2025-09-20 23:55:16 - log_args - INFO - fetching args done.\n2025-09-20 23:55:16 - zarr_info - INFO - ./ps_processing/gix/ps_can_1_gix.zarr zarray shape, chunks, dtype: (390525, 2), (200000, 1), int32\n2025-09-20 23:55:16 - zarr_info - INFO - ./ps_processing/gix/ps_can_2_gix.zarr zarray shape, chunks, dtype: (374510, 2), (20000, 1), int32\n2025-09-20 23:55:16 - pc_union - INFO - loading idx1 and idx2 into memory.\n2025-09-20 23:55:16 - pc_union - INFO - calculate the union\n2025-09-20 23:55:16 - pc_union - INFO - number of points in the union: 634220\n2025-09-20 23:55:16 - pc_union - INFO - write union idx\n2025-09-20 23:55:16 - pc_union - INFO - write done\n2025-09-20 23:55:16 - zarr_info - INFO - ./ps_processing/gix/ps_can_gix.zarr zarray shape, chunks, dtype: (634220, 2), (200000, 1), int32\n2025-09-20 23:55:16 - pc_union - INFO - no point cloud data provided, exit.\n\n\nThen we convert the ps candiates to hillbert coordinates:\n\nmc.pc_hix('./ps_processing/gix/ps_can_gix.zarr/', './ps_processing/gix/ps_can_hix.zarr', shape=(2500, 1834))\nps_can_hix = './ps_processing/hix/ps_can_hix.zarr'\nmc.pc_sort('./ps_processing/gix/ps_can_hix.zarr', ps_can_hix)\n\n2025-09-20 23:55:16 - log_args - INFO - running function: pc_hix\n2025-09-20 23:55:16 - log_args - INFO - fetching args:\n2025-09-20 23:55:16 - log_args - INFO - gix = './ps_processing/gix/ps_can_gix.zarr/'\n2025-09-20 23:55:16 - log_args - INFO - hix = './ps_processing/gix/ps_can_hix.zarr'\n2025-09-20 23:55:16 - log_args - INFO - shape = (2500, 1834)\n2025-09-20 23:55:16 - log_args - INFO - fetching args done.\n2025-09-20 23:55:16 - zarr_info - INFO - ./ps_processing/gix/ps_can_gix.zarr/ zarray shape, chunks, dtype: (634220, 2), (200000, 1), int32\n2025-09-20 23:55:16 - zarr_info - INFO - ./ps_processing/gix/ps_can_hix.zarr zarray shape, chunks, dtype: (634220,), (200000,), int64\n2025-09-20 23:55:16 - pc_hix - INFO - calculating the hillbert index based on grid index\n2025-09-20 23:55:17 - pc_hix - INFO - writing the hillbert index\n2025-09-20 23:55:17 - pc_hix - INFO - done.\n2025-09-20 23:55:17 - log_args - INFO - running function: pc_sort\n2025-09-20 23:55:17 - log_args - INFO - fetching args:\n2025-09-20 23:55:17 - log_args - INFO - idx_in = './ps_processing/gix/ps_can_hix.zarr'\n2025-09-20 23:55:17 - log_args - INFO - idx = './ps_processing/hix/ps_can_hix.zarr'\n2025-09-20 23:55:17 - log_args - INFO - pc_in = None\n2025-09-20 23:55:17 - log_args - INFO - pc = None\n2025-09-20 23:55:17 - log_args - INFO - shape = None\n2025-09-20 23:55:17 - log_args - INFO - chunks = None\n2025-09-20 23:55:17 - log_args - INFO - key = None\n2025-09-20 23:55:17 - log_args - INFO - processes = False\n2025-09-20 23:55:17 - log_args - INFO - n_workers = 1\n2025-09-20 23:55:17 - log_args - INFO - threads_per_worker = 1\n2025-09-20 23:55:17 - log_args - INFO - dask_cluster_arg = {}\n2025-09-20 23:55:17 - log_args - INFO - fetching args done.\n2025-09-20 23:55:17 - zarr_info - INFO - ./ps_processing/gix/ps_can_hix.zarr zarray shape, chunks, dtype: (634220,), (200000,), int64\n2025-09-20 23:55:17 - pc_sort - INFO - loading idx_in and calculate the sorting indices.\n2025-09-20 23:55:18 - pc_sort - INFO - output pc chunk size is 200000\n2025-09-20 23:55:18 - pc_sort - INFO - write idx\n2025-09-20 23:55:18 - zarr_info - INFO - idx zarray shape, chunks, dtype: (634220,), (200000,), int64\n2025-09-20 23:55:18 - pc_sort - INFO - no point cloud data provided, exit.\n\n\n\nps_can_rslc = './ps_processing/hix/ps_can_rslc.zarr'\nmc.ras2pc(ps_can_hix,\n          [rslc,'./load_data/e.zarr','./load_data/n.zarr',\n           './load_data/lon.zarr','./load_data/lat.zarr',\n           './ps_processing/gix/ras_adi.zarr'],\n          [ps_can_rslc, './ps_processing/hix/ps_can_e.zarr','./ps_processing/hix/ps_can_n.zarr',\n           './ps_processing/hix/ps_can_lon.zarr', './ps_processing/hix/ps_can_lat.zarr',\n           './ps_processing/hix/ps_can_adi.zarr',],\n)\n\n2025-09-20 23:55:18 - log_args - INFO - running function: ras2pc\n2025-09-20 23:55:18 - log_args - INFO - fetching args:\n2025-09-20 23:55:18 - log_args - INFO - idx = './ps_processing/hix/ps_can_hix.zarr'\n2025-09-20 23:55:18 - log_args - INFO - ras = ['./load_data/rslc.zarr', './load_data/e.zarr', './load_data/n.zarr', './load_data/lon.zarr', './load_data/lat.zarr', './ps_processing/gix/ras_adi.zarr']\n2025-09-20 23:55:18 - log_args - INFO - pc = ['./ps_processing/hix/ps_can_rslc.zarr', './ps_processing/hix/ps_can_e.zarr', './ps_processing/hix/ps_can_n.zarr', './ps_processing/hix/ps_can_lon.zarr', './ps_processing/hix/ps_can_lat.zarr', './ps_processing/hix/ps_can_adi.zarr']\n2025-09-20 23:55:18 - log_args - INFO - chunks = None\n2025-09-20 23:55:18 - log_args - INFO - processes = False\n2025-09-20 23:55:18 - log_args - INFO - n_workers = 1\n2025-09-20 23:55:18 - log_args - INFO - threads_per_worker = 1\n2025-09-20 23:55:18 - log_args - INFO - dask_cluster_arg = {}\n2025-09-20 23:55:18 - log_args - INFO - fetching args done.\n2025-09-20 23:55:18 - zarr_info - INFO - ./ps_processing/hix/ps_can_hix.zarr zarray shape, chunks, dtype: (634220,), (200000,), int64\n2025-09-20 23:55:18 - ras2pc - INFO - loading hix into memory and convert to gix\n2025-09-20 23:55:20 - ras2pc - INFO - starting dask local cluster.\n2025-09-20 23:55:20 - ras2pc - INFO - dask local cluster started.\n2025-09-20 23:55:20 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.10:8787/status', workers=1, threads=1, memory=1.95 TiB)\n2025-09-20 23:55:20 - ras2pc - INFO - start to slice on ./load_data/rslc.zarr\n2025-09-20 23:55:20 - zarr_info - INFO - ./load_data/rslc.zarr zarray shape, chunks, dtype: (2500, 1834, 17), (1000, 1000, 1), complex64\n2025-09-20 23:55:20 - darr_info - INFO - ras dask array shape, chunksize, dtype: (2500, 1834, 17), (2500, 1834, 1), complex64\n2025-09-20 23:55:20 - darr_info - INFO - pc dask array shape, chunksize, dtype: (634220, 17), (634220, 1), complex64\n2025-09-20 23:55:20 - ras2pc - INFO - saving to ./ps_processing/hix/ps_can_rslc.zarr.\n2025-09-20 23:55:20 - zarr_info - INFO - ./ps_processing/hix/ps_can_rslc.zarr zarray shape, chunks, dtype: (634220, 17), (200000, 1), complex64\n2025-09-20 23:55:20 - ras2pc - INFO - start to slice on ./load_data/e.zarr\n2025-09-20 23:55:20 - zarr_info - INFO - ./load_data/e.zarr zarray shape, chunks, dtype: (2500, 1834), (1000, 1000), float64\n2025-09-20 23:55:20 - darr_info - INFO - ras dask array shape, chunksize, dtype: (2500, 1834), (2500, 1834), float64\n2025-09-20 23:55:20 - darr_info - INFO - pc dask array shape, chunksize, dtype: (634220,), (634220,), float64\n2025-09-20 23:55:20 - ras2pc - INFO - saving to ./ps_processing/hix/ps_can_e.zarr.\n2025-09-20 23:55:20 - zarr_info - INFO - ./ps_processing/hix/ps_can_e.zarr zarray shape, chunks, dtype: (634220,), (200000,), float64\n2025-09-20 23:55:20 - ras2pc - INFO - start to slice on ./load_data/n.zarr\n2025-09-20 23:55:20 - zarr_info - INFO - ./load_data/n.zarr zarray shape, chunks, dtype: (2500, 1834), (1000, 1000), float64\n2025-09-20 23:55:20 - darr_info - INFO - ras dask array shape, chunksize, dtype: (2500, 1834), (2500, 1834), float64\n2025-09-20 23:55:20 - darr_info - INFO - pc dask array shape, chunksize, dtype: (634220,), (634220,), float64\n2025-09-20 23:55:20 - ras2pc - INFO - saving to ./ps_processing/hix/ps_can_n.zarr.\n2025-09-20 23:55:20 - zarr_info - INFO - ./ps_processing/hix/ps_can_n.zarr zarray shape, chunks, dtype: (634220,), (200000,), float64\n2025-09-20 23:55:20 - ras2pc - INFO - start to slice on ./load_data/lon.zarr\n2025-09-20 23:55:20 - zarr_info - INFO - ./load_data/lon.zarr zarray shape, chunks, dtype: (2500, 1834), (1000, 1000), float64\n2025-09-20 23:55:20 - darr_info - INFO - ras dask array shape, chunksize, dtype: (2500, 1834), (2500, 1834), float64\n2025-09-20 23:55:20 - darr_info - INFO - pc dask array shape, chunksize, dtype: (634220,), (634220,), float64\n2025-09-20 23:55:20 - ras2pc - INFO - saving to ./ps_processing/hix/ps_can_lon.zarr.\n2025-09-20 23:55:20 - zarr_info - INFO - ./ps_processing/hix/ps_can_lon.zarr zarray shape, chunks, dtype: (634220,), (200000,), float64\n2025-09-20 23:55:20 - ras2pc - INFO - start to slice on ./load_data/lat.zarr\n2025-09-20 23:55:20 - zarr_info - INFO - ./load_data/lat.zarr zarray shape, chunks, dtype: (2500, 1834), (1000, 1000), float64\n2025-09-20 23:55:20 - darr_info - INFO - ras dask array shape, chunksize, dtype: (2500, 1834), (2500, 1834), float64\n2025-09-20 23:55:20 - darr_info - INFO - pc dask array shape, chunksize, dtype: (634220,), (634220,), float64\n2025-09-20 23:55:20 - ras2pc - INFO - saving to ./ps_processing/hix/ps_can_lat.zarr.\n2025-09-20 23:55:20 - zarr_info - INFO - ./ps_processing/hix/ps_can_lat.zarr zarray shape, chunks, dtype: (634220,), (200000,), float64\n2025-09-20 23:55:20 - ras2pc - INFO - start to slice on ./ps_processing/gix/ras_adi.zarr\n2025-09-20 23:55:20 - zarr_info - INFO - ./ps_processing/gix/ras_adi.zarr zarray shape, chunks, dtype: (2500, 1834), (1000, 1000), float32\n2025-09-20 23:55:20 - darr_info - INFO - ras dask array shape, chunksize, dtype: (2500, 1834), (2500, 1834), float32\n2025-09-20 23:55:20 - darr_info - INFO - pc dask array shape, chunksize, dtype: (634220,), (634220,), float32\n2025-09-20 23:55:20 - ras2pc - INFO - saving to ./ps_processing/hix/ps_can_adi.zarr.\n2025-09-20 23:55:21 - zarr_info - INFO - ./ps_processing/hix/ps_can_adi.zarr zarray shape, chunks, dtype: (634220,), (200000,), float32\n2025-09-20 23:55:21 - ras2pc - INFO - computing graph setted. doing all the computing.\n2025-09-20 23:55:22 - ras2pc - INFO - computing finished.ed |  1.5s\n2025-09-20 23:55:22 - ras2pc - INFO - dask cluster closed.\n\n\nThe point cloud data is sorted according to the hillbert index so they close points in the list are closed to each other in map.",
    "crumbs": [
      "Tutorials",
      "CLI",
      "PS Processing"
    ]
  },
  {
    "objectID": "Tutorials/CLI/ps_processing.html#visualize-the-ps-candidates",
    "href": "Tutorials/CLI/ps_processing.html#visualize-the-ps-candidates",
    "title": "PS Processing",
    "section": "visualize the PS candidates",
    "text": "visualize the PS candidates\n\nmc.pc_pyramid(\n    './ps_processing/hix/ps_can_rslc.zarr',\n    './ps_processing/hix/ps_can_rslc_pyramid',\n    x = './ps_processing/hix/ps_can_e.zarr',\n    y = './ps_processing/hix/ps_can_n.zarr/',\n    ras_resolution = 20,\n)\n\n2025-09-20 23:55:33 - log_args - INFO - running function: pc_pyramid\n2025-09-20 23:55:33 - log_args - INFO - fetching args:\n2025-09-20 23:55:33 - log_args - INFO - pc = './ps_processing/hix/ps_can_rslc.zarr'\n2025-09-20 23:55:33 - log_args - INFO - out_dir = './ps_processing/hix/ps_can_rslc_pyramid'\n2025-09-20 23:55:33 - log_args - INFO - x = './ps_processing/hix/ps_can_e.zarr'\n2025-09-20 23:55:33 - log_args - INFO - y = './ps_processing/hix/ps_can_n.zarr/'\n2025-09-20 23:55:33 - log_args - INFO - yx = None\n2025-09-20 23:55:33 - log_args - INFO - ras_resolution = 20\n2025-09-20 23:55:33 - log_args - INFO - ras_chunks = (256, 256)\n2025-09-20 23:55:33 - log_args - INFO - pc_chunks = 65536\n2025-09-20 23:55:33 - log_args - INFO - processes = False\n2025-09-20 23:55:33 - log_args - INFO - n_workers = 1\n2025-09-20 23:55:33 - log_args - INFO - threads_per_worker = 2\n2025-09-20 23:55:33 - log_args - INFO - dask_cluster_arg = {}\n2025-09-20 23:55:33 - log_args - INFO - fetching args done.\n2025-09-20 23:55:33 - pc_pyramid - INFO - clean out dir\n2025-09-20 23:55:33 - zarr_info - INFO - ./ps_processing/hix/ps_can_rslc.zarr zarray shape, chunks, dtype: (634220, 17), (200000, 1), complex64\n2025-09-20 23:55:33 - pc_pyramid - INFO - rendering point cloud data coordinates:\n2025-09-20 23:55:33 - pc_pyramid - INFO - rasterizing point cloud data to grid with bounds: [np.float64(-16498472.34405057), np.float64(8649597.04965627), np.float64(-16470132.34405057), np.float64(8674957.04965627)].\n2025-09-20 23:55:33 - zarr_info - INFO - ps_processing/hix/ps_can_rslc_pyramid/x.zarr zarray shape, chunks, dtype: (634220,), (65536,), float64\n2025-09-20 23:55:33 - zarr_info - INFO - ps_processing/hix/ps_can_rslc_pyramid/y.zarr zarray shape, chunks, dtype: (634220,), (65536,), float64\n2025-09-20 23:55:33 - pc_pyramid - INFO - pc data coordinates rendering ends.\n2025-09-20 23:55:33 - zarr_info - INFO - ps_processing/hix/ps_can_rslc_pyramid/idx_0.zarr zarray shape, chunks, dtype: (1269, 1418), (256, 256), int64\n2025-09-20 23:55:35 - zarr_info - INFO - ps_processing/hix/ps_can_rslc_pyramid/idx_1.zarr zarray shape, chunks, dtype: (635, 709), (256, 256), int64\n2025-09-20 23:55:35 - zarr_info - INFO - ps_processing/hix/ps_can_rslc_pyramid/idx_2.zarr zarray shape, chunks, dtype: (318, 355), (256, 256), int64\n2025-09-20 23:55:35 - zarr_info - INFO - ps_processing/hix/ps_can_rslc_pyramid/idx_3.zarr zarray shape, chunks, dtype: (159, 178), (256, 256), int64\n2025-09-20 23:55:35 - zarr_info - INFO - ps_processing/hix/ps_can_rslc_pyramid/idx_4.zarr zarray shape, chunks, dtype: (80, 89), (256, 256), int64\n2025-09-20 23:55:35 - zarr_info - INFO - ps_processing/hix/ps_can_rslc_pyramid/idx_5.zarr zarray shape, chunks, dtype: (40, 45), (256, 256), int64\n2025-09-20 23:55:35 - zarr_info - INFO - ps_processing/hix/ps_can_rslc_pyramid/idx_6.zarr zarray shape, chunks, dtype: (20, 23), (256, 256), int64\n2025-09-20 23:55:35 - zarr_info - INFO - ps_processing/hix/ps_can_rslc_pyramid/idx_7.zarr zarray shape, chunks, dtype: (10, 12), (256, 256), int64\n2025-09-20 23:55:35 - zarr_info - INFO - ps_processing/hix/ps_can_rslc_pyramid/idx_8.zarr zarray shape, chunks, dtype: (5, 6), (256, 256), int64\n2025-09-20 23:55:35 - zarr_info - INFO - ps_processing/hix/ps_can_rslc_pyramid/idx_9.zarr zarray shape, chunks, dtype: (3, 3), (256, 256), int64\n2025-09-20 23:55:35 - zarr_info - INFO - ps_processing/hix/ps_can_rslc_pyramid/idx_10.zarr zarray shape, chunks, dtype: (2, 2), (256, 256), int64\n2025-09-20 23:55:35 - pc_pyramid - INFO - rasterized idx rendering ends\n2025-09-20 23:55:35 - pc_pyramid - INFO - dask local cluster started to render pc data.\n2025-09-20 23:55:35 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.10:8787/status', workers=1, threads=2, memory=1.95 TiB)\n2025-09-20 23:55:35 - zarr_info - INFO - ps_processing/hix/ps_can_rslc_pyramid/pc.zarr zarray shape, chunks, dtype: (634220, 17), (65536, 1), complex64\n2025-09-20 23:55:35 - zarr_info - INFO - ps_processing/hix/ps_can_rslc_pyramid/0.zarr zarray shape, chunks, dtype: (1269, 1418, 17), (256, 256, 1), complex64\n2025-09-20 23:55:35 - zarr_info - INFO - ps_processing/hix/ps_can_rslc_pyramid/1.zarr zarray shape, chunks, dtype: (635, 709, 17), (256, 256, 1), complex64\n2025-09-20 23:55:35 - zarr_info - INFO - ps_processing/hix/ps_can_rslc_pyramid/2.zarr zarray shape, chunks, dtype: (318, 355, 17), (256, 256, 1), complex64\n2025-09-20 23:55:35 - zarr_info - INFO - ps_processing/hix/ps_can_rslc_pyramid/3.zarr zarray shape, chunks, dtype: (159, 178, 17), (256, 256, 1), complex64\n2025-09-20 23:55:35 - zarr_info - INFO - ps_processing/hix/ps_can_rslc_pyramid/4.zarr zarray shape, chunks, dtype: (80, 89, 17), (256, 256, 1), complex64\n2025-09-20 23:55:35 - zarr_info - INFO - ps_processing/hix/ps_can_rslc_pyramid/5.zarr zarray shape, chunks, dtype: (40, 45, 17), (256, 256, 1), complex64\n2025-09-20 23:55:35 - zarr_info - INFO - ps_processing/hix/ps_can_rslc_pyramid/6.zarr zarray shape, chunks, dtype: (20, 23, 17), (256, 256, 1), complex64\n2025-09-20 23:55:35 - zarr_info - INFO - ps_processing/hix/ps_can_rslc_pyramid/7.zarr zarray shape, chunks, dtype: (10, 12, 17), (256, 256, 1), complex64\n2025-09-20 23:55:35 - zarr_info - INFO - ps_processing/hix/ps_can_rslc_pyramid/8.zarr zarray shape, chunks, dtype: (5, 6, 17), (256, 256, 1), complex64\n2025-09-20 23:55:35 - zarr_info - INFO - ps_processing/hix/ps_can_rslc_pyramid/9.zarr zarray shape, chunks, dtype: (3, 3, 17), (256, 256, 1), complex64\n2025-09-20 23:55:35 - zarr_info - INFO - ps_processing/hix/ps_can_rslc_pyramid/10.zarr zarray shape, chunks, dtype: (2, 2, 17), (256, 256, 1), complex64\n2025-09-20 23:55:35 - pc_pyramid - INFO - computing graph setted. doing all the computing.\n2025-09-20 23:55:39 - pc_pyramid - INFO - computing finished.  3.0s\n2025-09-20 23:55:39 - pc_pyramid - INFO - dask cluster closed.\n\n\n\nintf_plot = mc.pc_plot('./ps_processing/hix/ps_can_rslc_pyramid/',post_proc_ras='intf_all', post_proc_pc='intf_all',level_increase=1)\n\n\nimport holoviews as hv\nfrom bokeh.models import WheelZoomTool\nhv.extension('bokeh')\nimport toml\nwith open('load_data/meta.toml','r') as f:\n    dates = toml.load(f)['dates']\nintf_plot = intf_plot.redim(i=hv.Dimension('i', label='Reference Image', range=(0,16), value_format=(lambda i: dates[i])),\n                            j=hv.Dimension('j', label='Secondary Image', range=(0,16), value_format=(lambda i: dates[i])),\n                            x=hv.Dimension('lon', label='Longitude'), y=hv.Dimension('lat',label='Latitude'), z=hv.Dimension('Phase',range=(-np.pi,np.pi)))\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n  \n  \n\n\n\n\n\n\n\n\nⓘ\n\n\n\n\n\nhv.output(widget_location='bottom')\nhv.element.tiles.EsriImagery()*intf_plot.opts(\n    hv.opts.Image(\n        cmap='colorwheel',width=600, height=400, colorbar=True,\n        default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],\n        active_tools=['wheel_zoom']\n    ),\n    hv.opts.Points(\n        color='Phase', cmap='colorwheel',width=600, height=400, colorbar=True,\n        default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],\n        active_tools=['wheel_zoom']\n    ),\n)",
    "crumbs": [
      "Tutorials",
      "CLI",
      "PS Processing"
    ]
  },
  {
    "objectID": "Tutorials/CLI/pixel_refinement.html",
    "href": "Tutorials/CLI/pixel_refinement.html",
    "title": "Pixel refinement",
    "section": "",
    "text": "In this tutorial, we demostrate how to merge previous processed PS candidates in PS processing and DSs in DS processing together and refine these measurement points with Noise2Fringe Transformer.\nimport zarr\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport colorcet\nimport moraine.cli as mc\nimport moraine as mr",
    "crumbs": [
      "Tutorials",
      "CLI",
      "Pixel refinement"
    ]
  },
  {
    "objectID": "Tutorials/CLI/pixel_refinement.html#merge-pixels",
    "href": "Tutorials/CLI/pixel_refinement.html#merge-pixels",
    "title": "Pixel refinement",
    "section": "Merge pixels",
    "text": "Merge pixels\n\nlogger = mc.get_logger()\n\n\nds_ph = './ds_processing/hix/ds/ds_ph.zarr'\nds_e = './ds_processing/hix/ds/ds_e.zarr'\nds_n = './ds_processing/hix/ds/ds_n.zarr'\nds_hix = './ds_processing/hix/ds/ds_hix.zarr'\n\nps_can_rslc = './ps_processing/hix/ps_can_rslc.zarr'\nps_can_e = './ps_processing/hix/ps_can_e.zarr'\nps_can_n = './ps_processing/hix/ps_can_n.zarr'\nps_can_hix = './ps_processing/hix/ps_can_hix.zarr'\n\npc_can_hix = './pixel_refinement/hix/pc_can_hix.zarr'\npc_can_ph = './pixel_refinement/hix/pc_can_ph.zarr'\npc_can_e = './pixel_refinement/hix/pc_can_e.zarr'\npc_can_n = './pixel_refinement/hix/pc_can_n.zarr'\n\n\nmc.pc_union(\n    ps_can_hix, ds_hix, pc_can_hix,\n    pc1 = [ps_can_rslc, ps_can_e, ps_can_n,],\n    pc2 = [ds_ph, ds_e, ds_n],\n    pc = [pc_can_ph, pc_can_e, pc_can_n],\n)\n\n2025-09-20 23:55:52 - log_args - INFO - running function: pc_union\n2025-09-20 23:55:52 - log_args - INFO - fetching args:\n2025-09-20 23:55:52 - log_args - INFO - idx1 = './ps_processing/hix/ps_can_hix.zarr'\n2025-09-20 23:55:52 - log_args - INFO - idx2 = './ds_processing/hix/ds/ds_hix.zarr'\n2025-09-20 23:55:52 - log_args - INFO - idx = './pixel_refinement/hix/pc_can_hix.zarr'\n2025-09-20 23:55:52 - log_args - INFO - pc1 = ['./ps_processing/hix/ps_can_rslc.zarr', './ps_processing/hix/ps_can_e.zarr', './ps_processing/hix/ps_can_n.zarr']\n2025-09-20 23:55:52 - log_args - INFO - pc2 = ['./ds_processing/hix/ds/ds_ph.zarr', './ds_processing/hix/ds/ds_e.zarr', './ds_processing/hix/ds/ds_n.zarr']\n2025-09-20 23:55:52 - log_args - INFO - pc = ['./pixel_refinement/hix/pc_can_ph.zarr', './pixel_refinement/hix/pc_can_e.zarr', './pixel_refinement/hix/pc_can_n.zarr']\n2025-09-20 23:55:52 - log_args - INFO - shape = None\n2025-09-20 23:55:52 - log_args - INFO - chunks = None\n2025-09-20 23:55:52 - log_args - INFO - processes = False\n2025-09-20 23:55:52 - log_args - INFO - n_workers = 1\n2025-09-20 23:55:52 - log_args - INFO - threads_per_worker = 1\n2025-09-20 23:55:52 - log_args - INFO - dask_cluster_arg = {}\n2025-09-20 23:55:52 - log_args - INFO - fetching args done.\n2025-09-20 23:55:52 - zarr_info - INFO - ./ps_processing/hix/ps_can_hix.zarr zarray shape, chunks, dtype: (634220,), (200000,), int64\n2025-09-20 23:55:52 - zarr_info - INFO - ./ds_processing/hix/ds/ds_hix.zarr zarray shape, chunks, dtype: (293814,), (200000,), int64\n2025-09-20 23:55:52 - pc_union - INFO - loading idx1 and idx2 into memory.\n2025-09-20 23:55:52 - pc_union - INFO - calculate the union\n2025-09-20 23:55:52 - pc_union - INFO - number of points in the union: 758504\n2025-09-20 23:55:52 - pc_union - INFO - write union idx\n2025-09-20 23:55:52 - pc_union - INFO - write done\n2025-09-20 23:55:52 - zarr_info - INFO - ./pixel_refinement/hix/pc_can_hix.zarr zarray shape, chunks, dtype: (758504,), (200000,), int64\n2025-09-20 23:55:52 - pc_union - INFO - starting dask local cluster.\n2025-09-20 23:55:52 - pc_union - INFO - dask local cluster started.\n2025-09-20 23:55:52 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.10:8787/status', workers=1, threads=1, memory=1.95 TiB)\n2025-09-20 23:55:52 - zarr_info - INFO - ./ps_processing/hix/ps_can_rslc.zarr zarray shape, chunks, dtype: (634220, 17), (200000, 1), complex64\n2025-09-20 23:55:52 - zarr_info - INFO - ./ds_processing/hix/ds/ds_ph.zarr zarray shape, chunks, dtype: (293814, 17), (200000, 1), complex64\n2025-09-20 23:55:52 - darr_info - INFO - pc1 dask array shape, chunksize, dtype: (634220, 17), (634220, 1), complex64\n2025-09-20 23:55:52 - darr_info - INFO - pc2 dask array shape, chunksize, dtype: (293814, 17), (293814, 1), complex64\n2025-09-20 23:55:52 - pc_union - INFO - set up union pc data dask array.\n2025-09-20 23:55:52 - darr_info - INFO - pc dask array shape, chunksize, dtype: (758504, 17), (758504, 1), complex64\n2025-09-20 23:55:52 - pc_union - INFO - write pc to ./pixel_refinement/hix/pc_can_ph.zarr\n2025-09-20 23:55:52 - zarr_info - INFO - ./pixel_refinement/hix/pc_can_ph.zarr zarray shape, chunks, dtype: (758504, 17), (200000, 1), complex64\n2025-09-20 23:55:52 - zarr_info - INFO - ./ps_processing/hix/ps_can_e.zarr zarray shape, chunks, dtype: (634220,), (200000,), float64\n2025-09-20 23:55:52 - zarr_info - INFO - ./ds_processing/hix/ds/ds_e.zarr zarray shape, chunks, dtype: (293814,), (200000,), float64\n2025-09-20 23:55:52 - darr_info - INFO - pc1 dask array shape, chunksize, dtype: (634220,), (634220,), float64\n2025-09-20 23:55:52 - darr_info - INFO - pc2 dask array shape, chunksize, dtype: (293814,), (293814,), float64\n2025-09-20 23:55:52 - pc_union - INFO - set up union pc data dask array.\n2025-09-20 23:55:52 - darr_info - INFO - pc dask array shape, chunksize, dtype: (758504,), (758504,), float64\n2025-09-20 23:55:52 - pc_union - INFO - write pc to ./pixel_refinement/hix/pc_can_e.zarr\n2025-09-20 23:55:52 - zarr_info - INFO - ./pixel_refinement/hix/pc_can_e.zarr zarray shape, chunks, dtype: (758504,), (200000,), float64\n2025-09-20 23:55:52 - zarr_info - INFO - ./ps_processing/hix/ps_can_n.zarr zarray shape, chunks, dtype: (634220,), (200000,), float64\n2025-09-20 23:55:52 - zarr_info - INFO - ./ds_processing/hix/ds/ds_n.zarr zarray shape, chunks, dtype: (293814,), (200000,), float64\n2025-09-20 23:55:52 - darr_info - INFO - pc1 dask array shape, chunksize, dtype: (634220,), (634220,), float64\n2025-09-20 23:55:52 - darr_info - INFO - pc2 dask array shape, chunksize, dtype: (293814,), (293814,), float64\n2025-09-20 23:55:52 - pc_union - INFO - set up union pc data dask array.\n2025-09-20 23:55:52 - darr_info - INFO - pc dask array shape, chunksize, dtype: (758504,), (758504,), float64\n2025-09-20 23:55:52 - pc_union - INFO - write pc to ./pixel_refinement/hix/pc_can_n.zarr\n2025-09-20 23:55:52 - zarr_info - INFO - ./pixel_refinement/hix/pc_can_n.zarr zarray shape, chunks, dtype: (758504,), (200000,), float64\n2025-09-20 23:55:52 - pc_union - INFO - computing graph setted. doing all the computing.\n2025-09-20 23:55:53 - pc_union - INFO - computing finished. |  1.1s\n2025-09-20 23:55:53 - pc_union - INFO - dask cluster closed.\n\n\n\npc_can_lon = './pixel_refinement/hix/pc_can_lon.zarr'\npc_can_lat = './pixel_refinement/hix/pc_can_lat.zarr'\n\n\nmc.ras2pc(\n    pc_can_hix, \n    ras=['./load_data/lon.zarr/','./load_data/lat.zarr/'],\n    pc =[pc_can_lon, pc_can_lat]\n)\n\n2025-09-20 23:58:02 - log_args - INFO - running function: ras2pc\n2025-09-20 23:58:02 - log_args - INFO - fetching args:\n2025-09-20 23:58:02 - log_args - INFO - idx = './pixel_refinement/hix/pc_can_hix.zarr'\n2025-09-20 23:58:02 - log_args - INFO - ras = ['./load_data/lon.zarr/', './load_data/lat.zarr/']\n2025-09-20 23:58:02 - log_args - INFO - pc = ['./pixel_refinement/hix/pc_can_lon.zarr', './pixel_refinement/hix/pc_can_lat.zarr']\n2025-09-20 23:58:02 - log_args - INFO - chunks = None\n2025-09-20 23:58:02 - log_args - INFO - processes = False\n2025-09-20 23:58:02 - log_args - INFO - n_workers = 1\n2025-09-20 23:58:02 - log_args - INFO - threads_per_worker = 1\n2025-09-20 23:58:02 - log_args - INFO - dask_cluster_arg = {}\n2025-09-20 23:58:02 - log_args - INFO - fetching args done.\n2025-09-20 23:58:02 - zarr_info - INFO - ./pixel_refinement/hix/pc_can_hix.zarr zarray shape, chunks, dtype: (758504,), (200000,), int64\n2025-09-20 23:58:02 - ras2pc - INFO - loading hix into memory and convert to gix\n2025-09-20 23:58:04 - ras2pc - INFO - starting dask local cluster.\n2025-09-20 23:58:04 - ras2pc - INFO - dask local cluster started.\n2025-09-20 23:58:04 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.10:8787/status', workers=1, threads=1, memory=1.95 TiB)\n2025-09-20 23:58:04 - ras2pc - INFO - start to slice on ./load_data/lon.zarr/\n2025-09-20 23:58:04 - zarr_info - INFO - ./load_data/lon.zarr/ zarray shape, chunks, dtype: (2500, 1834), (1000, 1000), float64\n2025-09-20 23:58:04 - darr_info - INFO - ras dask array shape, chunksize, dtype: (2500, 1834), (2500, 1834), float64\n2025-09-20 23:58:04 - darr_info - INFO - pc dask array shape, chunksize, dtype: (758504,), (758504,), float64\n2025-09-20 23:58:04 - ras2pc - INFO - saving to ./pixel_refinement/hix/pc_can_lon.zarr.\n2025-09-20 23:58:04 - zarr_info - INFO - ./pixel_refinement/hix/pc_can_lon.zarr zarray shape, chunks, dtype: (758504,), (200000,), float64\n2025-09-20 23:58:04 - ras2pc - INFO - start to slice on ./load_data/lat.zarr/\n2025-09-20 23:58:04 - zarr_info - INFO - ./load_data/lat.zarr/ zarray shape, chunks, dtype: (2500, 1834), (1000, 1000), float64\n2025-09-20 23:58:04 - darr_info - INFO - ras dask array shape, chunksize, dtype: (2500, 1834), (2500, 1834), float64\n2025-09-20 23:58:04 - darr_info - INFO - pc dask array shape, chunksize, dtype: (758504,), (758504,), float64\n2025-09-20 23:58:04 - ras2pc - INFO - saving to ./pixel_refinement/hix/pc_can_lat.zarr.\n2025-09-20 23:58:04 - zarr_info - INFO - ./pixel_refinement/hix/pc_can_lat.zarr zarray shape, chunks, dtype: (758504,), (200000,), float64\n2025-09-20 23:58:04 - ras2pc - INFO - computing graph setted. doing all the computing.\n2025-09-20 23:58:05 - ras2pc - INFO - computing finished.ed |  0.2s\n2025-09-20 23:58:05 - ras2pc - INFO - dask cluster closed.",
    "crumbs": [
      "Tutorials",
      "CLI",
      "Pixel refinement"
    ]
  },
  {
    "objectID": "Tutorials/CLI/pixel_refinement.html#refine-pixels-with-noise2fringe-transformer",
    "href": "Tutorials/CLI/pixel_refinement.html#refine-pixels-with-noise2fringe-transformer",
    "title": "Pixel refinement",
    "section": "Refine pixels with Noise2fringe Transformer",
    "text": "Refine pixels with Noise2fringe Transformer\n\nn2ft_intf = './pixel_refinement/hix/pc_can_n2f_intf.zarr'\npc_can_ph_zarr = zarr.open(pc_can_ph,mode='r')\ntnet = tnet = mr.TempNet.from_bandwidth(pc_can_ph_zarr.shape[-1],1)\n\n\nmc.n2ft(pc_can_lon, pc_can_lat, pc_can_ph, n2ft_intf, tnet.image_pairs, chunks= 20000, cuda=True)\n\n2025-09-21 16:12:51 - log_args - INFO - running function: n2ft\n2025-09-21 16:12:51 - log_args - INFO - fetching args:\n2025-09-21 16:12:51 - log_args - INFO - x = './pixel_refinement/hix/pc_can_lon.zarr'\n2025-09-21 16:12:51 - log_args - INFO - y = './pixel_refinement/hix/pc_can_lat.zarr'\n2025-09-21 16:12:51 - log_args - INFO - rslc = './pixel_refinement/hix/pc_can_ph.zarr'\n2025-09-21 16:12:51 - log_args - INFO - intf = './pixel_refinement/pc_can_n2f_intf.zarr'\n2025-09-21 16:12:51 - log_args - INFO - image_pairs = array([[ 0,  1],\n       [ 1,  2],\n       [ 2,  3],\n       [ 3,  4],\n       [ 4,  5],\n       [ 5,  6],\n       [ 6,  7],\n       [ 7,  8],\n       [ 8,  9],\n       [ 9, 10],\n       [10, 11],\n       [11, 12],\n       [12, 13],\n       [13, 14],\n       [14, 15],\n       [15, 16]], dtype=int32)\n2025-09-21 16:12:51 - log_args - INFO - chunks = 20000\n2025-09-21 16:12:51 - log_args - INFO - out_chunks = None\n2025-09-21 16:12:51 - log_args - INFO - k = 128\n2025-09-21 16:12:51 - log_args - INFO - model = None\n2025-09-21 16:12:51 - log_args - INFO - cuda = True\n2025-09-21 16:12:51 - log_args - INFO - processes = None\n2025-09-21 16:12:51 - log_args - INFO - n_workers = None\n2025-09-21 16:12:51 - log_args - INFO - threads_per_worker = None\n2025-09-21 16:12:51 - log_args - INFO - rmm_pool_size = 0.5\n2025-09-21 16:12:51 - log_args - INFO - dask_cluster_arg = {}\n2025-09-21 16:12:51 - log_args - INFO - fetching args done.\n2025-09-21 16:12:51 - n2ft - INFO - load coordinates\n2025-09-21 16:12:51 - n2ft - INFO - Done\n2025-09-21 16:12:51 - zarr_info - INFO - ./pixel_refinement/hix/pc_can_ph.zarr zarray shape, chunks, dtype: (758504, 17), (200000, 1), complex64\n2025-09-21 16:12:51 - n2ft - INFO - processing point chunk size: 20000\n2025-09-21 16:12:51 - n2ft - INFO - distributing every processing chunk with halo data\n2025-09-21 16:12:55 - n2ft - INFO - processing chunk size with halo data: [23208, 24455, 22837, 23069, 34383, 27737, 29607, 28344, 26739, 25523, 24083, 24445, 25315, 25322, 24721, 26577, 24715, 25789, 26051, 26238, 25108, 27963, 28192, 25935, 27746, 25604, 26038, 25298, 25983, 25076, 25275, 22929, 24983, 25265, 24195, 24766, 26729, 21755]\n2025-09-21 16:12:55 - n2ft - INFO - starting dask cluster.\n2025-09-21 16:13:04 - n2ft - INFO - dask cluster started.\n2025-09-21 16:13:04 - dask_cluster_info - INFO - dask cluster: LocalCUDACluster(dashboard_link='http://127.0.0.1:8787/status', workers=8, threads=8, memory=1.95 TiB)\n2025-09-21 16:13:04 - darr_info - INFO - rslc dask array shape, chunksize, dtype: (758504, 17), (758504, 1), complex64\n2025-09-21 16:13:04 - n2ft - INFO - got filtered interferograms.\n2025-09-21 16:13:04 - darr_info - INFO - intf dask array shape, chunksize, dtype: (758504, 16), (758504, 1), complex64\n2025-09-21 16:13:04 - n2ft - INFO - saving filtered interferograms.\n2025-09-21 16:13:04 - zarr_info - INFO - ./pixel_refinement/pc_can_n2f_intf.zarr zarray shape, chunks, dtype: (758504, 16), (200000, 1), complex64\n2025-09-21 16:13:04 - n2ft - INFO - computing graph setted. doing all the computing.\n[                                        ] | 0% Completed |  0.2s\n\n\n/users/kangl/miniforge3/envs/work2/lib/python3.12/site-packages/distributed/client.py:3371: UserWarning: Sending large graph of size 24.85 MiB.\nThis may cause some slowdown.\nConsider loading the data with Dask directly\n or using futures or delayed objects to embed the data into the graph without repetition.\nSee also https://docs.dask.org/en/stable/best-practices.html#load-data-with-dask for more information.\n  warnings.warn(\n\n\n2025-09-21 16:13:26 - n2ft - INFO - computing finished.eted | 21.7s\n\n\n2025-09-21 16:13:30,258 - distributed.nanny - WARNING - Worker process still alive after 4.0 seconds, killing\n\n\n2025-09-21 16:13:30 - n2ft - INFO - dask cluster closed.\n\n\n\ntemp_coh = './pixel_refinement/hix/pc_can_temp_coh.zarr'\n\n\nmc.temp_coh(n2ft_intf, pc_can_ph, temp_coh, tnet.image_pairs, cuda=True)\n\n2025-09-21 16:15:51 - log_args - INFO - running function: temp_coh\n2025-09-21 16:15:51 - log_args - INFO - fetching args:\n2025-09-21 16:15:51 - log_args - INFO - intf = './pixel_refinement/hix/pc_can_n2f_intf.zarr'\n2025-09-21 16:15:51 - log_args - INFO - rslc = './pixel_refinement/hix/pc_can_ph.zarr'\n2025-09-21 16:15:51 - log_args - INFO - t_coh = './pixel_refinement/hix/pc_can_temp_coh.zarr'\n2025-09-21 16:15:51 - log_args - INFO - image_pairs = array([[ 0,  1],\n       [ 1,  2],\n       [ 2,  3],\n       [ 3,  4],\n       [ 4,  5],\n       [ 5,  6],\n       [ 6,  7],\n       [ 7,  8],\n       [ 8,  9],\n       [ 9, 10],\n       [10, 11],\n       [11, 12],\n       [12, 13],\n       [13, 14],\n       [14, 15],\n       [15, 16]], dtype=int32)\n2025-09-21 16:15:51 - log_args - INFO - chunks = None\n2025-09-21 16:15:51 - log_args - INFO - cuda = True\n2025-09-21 16:15:51 - log_args - INFO - processes = None\n2025-09-21 16:15:51 - log_args - INFO - n_workers = None\n2025-09-21 16:15:51 - log_args - INFO - threads_per_worker = None\n2025-09-21 16:15:51 - log_args - INFO - rmm_pool_size = 0.9\n2025-09-21 16:15:51 - log_args - INFO - dask_cluster_arg = {}\n2025-09-21 16:15:51 - log_args - INFO - fetching args done.\n2025-09-21 16:15:51 - zarr_info - INFO - ./pixel_refinement/hix/pc_can_n2f_intf.zarr zarray shape, chunks, dtype: (758504, 16), (200000, 1), complex64\n2025-09-21 16:15:51 - zarr_info - INFO - ./pixel_refinement/hix/pc_can_ph.zarr zarray shape, chunks, dtype: (758504, 17), (200000, 1), complex64\n2025-09-21 16:15:51 - temp_coh - INFO - starting dask local cluster.\n2025-09-21 16:16:00 - temp_coh - INFO - dask local cluster started.\n2025-09-21 16:16:00 - dask_cluster_info - INFO - dask cluster: LocalCUDACluster(dashboard_link='http://127.0.0.1:8787/status', workers=8, threads=8, memory=1.95 TiB)\n2025-09-21 16:16:00 - darr_info - INFO - intf dask array shape, chunksize, dtype: (758504, 16), (200000, 16), complex64\n2025-09-21 16:16:00 - darr_info - INFO - rslc dask array shape, chunksize, dtype: (758504, 17), (200000, 17), complex64\n2025-09-21 16:16:00 - temp_coh - INFO - Estimate temporal coherence for DS.\n2025-09-21 16:16:01 - temp_coh - INFO - got temporal coherence t_coh.\n2025-09-21 16:16:01 - darr_info - INFO - t_coh dask array shape, chunksize, dtype: (758504,), (200000,), float32\n2025-09-21 16:16:01 - temp_coh - INFO - saving t_coh.\n2025-09-21 16:16:01 - temp_coh - INFO - computing graph setted. doing all the computing.\n2025-09-21 16:16:02 - temp_coh - INFO - computing finished. |  0.9s\n2025-09-21 16:16:03 - temp_coh - INFO - dask cluster closed.\n\n\n\nimport holoviews as hv\nfrom bokeh.models import WheelZoomTool\nhv.extension('bokeh')\nimport toml\nwith open('load_data/meta.toml','r') as f:\n    dates = toml.load(f)['dates']\ntemp_coh_plot = mr.pc_plot(\n    zarr.open(temp_coh, mode='r')[:],\n    zarr.open(pc_can_n,mode='r')[:],\n    zarr.open(pc_can_e,mode='r')[:],\n)\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n  \n  \n\n\n\n\n\n\n\n\nⓘ\n\n\n\n\n\ntemp_coh_plot = temp_coh_plot.redim(\n    x=hv.Dimension('lon', label='Longitude'), \n    y=hv.Dimension('lat',label='Latitude'), \n    z=hv.Dimension('temp_coh')\n)\n\n\nhv.output(widget_location='bottom')\nhv.element.tiles.EsriImagery()*temp_coh_plot.opts(\n    hv.opts.Image(\n        cmap='fire',width=600, height=400, colorbar=True,\n        default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],\n        active_tools=['wheel_zoom']\n    ),\n    hv.opts.Points(\n        color='temp_coh', cmap='fire',width=600, height=400, colorbar=True,\n        default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],\n        active_tools=['wheel_zoom']\n    ),\n)\n\n\n\n\n\n  \n\n\n\n\n\npc_hix = './pixel_refinement/hix/pc/pc_hix.zarr'\n\n\nmc.pc_logic_pc(pc_can_hix, temp_coh, pc_hix, 'pc_in&gt;0.8')\n\n2025-09-21 16:30:45 - log_args - INFO - running function: pc_logic_pc\n2025-09-21 16:30:45 - log_args - INFO - fetching args:\n2025-09-21 16:30:45 - log_args - INFO - idx_in = './pixel_refinement/hix/pc_can_hix.zarr'\n2025-09-21 16:30:45 - log_args - INFO - pc_in = './pixel_refinement/hix/pc_can_temp_coh.zarr'\n2025-09-21 16:30:45 - log_args - INFO - idx = './pixel_refinement/hix/pc/pc_hix.zarr'\n2025-09-21 16:30:45 - log_args - INFO - operation = 'pc_in&gt;0.8'\n2025-09-21 16:30:45 - log_args - INFO - chunks = None\n2025-09-21 16:30:45 - log_args - INFO - fetching args done.\n2025-09-21 16:30:45 - zarr_info - INFO - ./pixel_refinement/hix/pc_can_hix.zarr zarray shape, chunks, dtype: (758504,), (200000,), int64\n2025-09-21 16:30:45 - zarr_info - INFO - ./pixel_refinement/hix/pc_can_temp_coh.zarr zarray shape, chunks, dtype: (758504,), (200000,), float32\n2025-09-21 16:30:45 - pc_logic_pc - INFO - loading idx_in into memory.\n2025-09-21 16:30:45 - pc_logic_pc - INFO - loading pc_in into memory.\n2025-09-21 16:30:45 - pc_logic_pc - INFO - select pc based on operation: pc_in&gt;0.8\n2025-09-21 16:30:45 - pc_logic_pc - INFO - number of selected pixels: 157318.\n2025-09-21 16:30:45 - zarr_info - INFO - idx zarray shape, chunks, dtype: (157318,), (200000,), int64\n2025-09-21 16:30:45 - pc_logic_pc - INFO - writing idx.\n2025-09-21 16:30:45 - pc_logic_pc - INFO - write done.\n\n\n\npc_ph = './pixel_refinement/hix/pc/pc_ph.zarr'\npc_e = './pixel_refinement/hix/pc/pc_e.zarr'\npc_n = './pixel_refinement/hix/pc/pc_n.zarr'\n\n\nmc.pc_select_data(\n    pc_can_hix, pc_hix, \n    pc_in = [pc_can_ph, pc_can_e, pc_can_n],\n    pc = [pc_ph, pc_e, pc_n],\n)\n\n2025-09-21 16:38:28 - log_args - INFO - running function: pc_select_data\n2025-09-21 16:38:28 - log_args - INFO - fetching args:\n2025-09-21 16:38:28 - log_args - INFO - idx_in = './pixel_refinement/hix/pc_can_hix.zarr'\n2025-09-21 16:38:28 - log_args - INFO - idx = './pixel_refinement/hix/pc/pc_hix.zarr'\n2025-09-21 16:38:28 - log_args - INFO - pc_in = ['./pixel_refinement/hix/pc_can_ph.zarr', './pixel_refinement/hix/pc_can_e.zarr', './pixel_refinement/hix/pc_can_n.zarr']\n2025-09-21 16:38:28 - log_args - INFO - pc = ['./pixel_refinement/hix/pc/pc_ph.zarr', './pixel_refinement/hix/pc/pc_e.zarr', './pixel_refinement/hix/pc/pc_n.zarr']\n2025-09-21 16:38:28 - log_args - INFO - shape = None\n2025-09-21 16:38:28 - log_args - INFO - chunks = None\n2025-09-21 16:38:28 - log_args - INFO - processes = False\n2025-09-21 16:38:28 - log_args - INFO - n_workers = 1\n2025-09-21 16:38:28 - log_args - INFO - threads_per_worker = 1\n2025-09-21 16:38:28 - log_args - INFO - dask_cluster_arg = {}\n2025-09-21 16:38:28 - log_args - INFO - fetching args done.\n2025-09-21 16:38:28 - zarr_info - INFO - ./pixel_refinement/hix/pc_can_hix.zarr zarray shape, chunks, dtype: (758504,), (200000,), int64\n2025-09-21 16:38:28 - zarr_info - INFO - ./pixel_refinement/hix/pc/pc_hix.zarr zarray shape, chunks, dtype: (157318,), (200000,), int64\n2025-09-21 16:38:28 - pc_select_data - INFO - loading idx_in and idx into memory.\n2025-09-21 16:38:28 - pc_select_data - INFO - starting dask local cluster.\n2025-09-21 16:38:28 - pc_select_data - INFO - dask local cluster started.\n2025-09-21 16:38:28 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.10:8787/status', workers=1, threads=1, memory=1.95 TiB)\n2025-09-21 16:38:28 - zarr_info - INFO - ./pixel_refinement/hix/pc_can_ph.zarr zarray shape, chunks, dtype: (758504, 17), (200000, 1), complex64\n2025-09-21 16:38:28 - darr_info - INFO - pc_in dask array shape, chunksize, dtype: (758504, 17), (758504, 1), complex64\n2025-09-21 16:38:28 - pc_select_data - INFO - set up selected pc data dask array.\n2025-09-21 16:38:28 - darr_info - INFO - pc dask array shape, chunksize, dtype: (157318, 17), (157318, 1), complex64\n2025-09-21 16:38:28 - pc_select_data - INFO - write pc to ./pixel_refinement/hix/pc/pc_ph.zarr\n2025-09-21 16:38:28 - zarr_info - INFO - ./pixel_refinement/hix/pc/pc_ph.zarr zarray shape, chunks, dtype: (157318, 17), (200000, 1), complex64\n2025-09-21 16:38:28 - zarr_info - INFO - ./pixel_refinement/hix/pc_can_e.zarr zarray shape, chunks, dtype: (758504,), (200000,), float64\n2025-09-21 16:38:28 - darr_info - INFO - pc_in dask array shape, chunksize, dtype: (758504,), (758504,), float64\n2025-09-21 16:38:28 - pc_select_data - INFO - set up selected pc data dask array.\n2025-09-21 16:38:28 - darr_info - INFO - pc dask array shape, chunksize, dtype: (157318,), (157318,), float64\n2025-09-21 16:38:28 - pc_select_data - INFO - write pc to ./pixel_refinement/hix/pc/pc_e.zarr\n2025-09-21 16:38:28 - zarr_info - INFO - ./pixel_refinement/hix/pc/pc_e.zarr zarray shape, chunks, dtype: (157318,), (200000,), float64\n2025-09-21 16:38:28 - zarr_info - INFO - ./pixel_refinement/hix/pc_can_n.zarr zarray shape, chunks, dtype: (758504,), (200000,), float64\n2025-09-21 16:38:28 - darr_info - INFO - pc_in dask array shape, chunksize, dtype: (758504,), (758504,), float64\n2025-09-21 16:38:28 - pc_select_data - INFO - set up selected pc data dask array.\n2025-09-21 16:38:28 - darr_info - INFO - pc dask array shape, chunksize, dtype: (157318,), (157318,), float64\n2025-09-21 16:38:28 - pc_select_data - INFO - write pc to ./pixel_refinement/hix/pc/pc_n.zarr\n2025-09-21 16:38:28 - zarr_info - INFO - ./pixel_refinement/hix/pc/pc_n.zarr zarray shape, chunks, dtype: (157318,), (200000,), float64\n2025-09-21 16:38:28 - pc_select_data - INFO - computing graph setted. doing all the computing.\n2025-09-21 16:38:29 - pc_select_data - INFO - computing finished.5s\n2025-09-21 16:38:29 - pc_select_data - INFO - dask cluster closed.",
    "crumbs": [
      "Tutorials",
      "CLI",
      "Pixel refinement"
    ]
  },
  {
    "objectID": "Tutorials/CLI/pixel_refinement.html#visualize-the-ps-candidates",
    "href": "Tutorials/CLI/pixel_refinement.html#visualize-the-ps-candidates",
    "title": "Pixel refinement",
    "section": "visualize the PS candidates",
    "text": "visualize the PS candidates\n\npc_ph_pyramid = './pixel_refinement/hix/pc/pc_ph_pyramid'\n\n\nmc.pc_pyramid(\n    pc_ph, pc_ph_pyramid,\n    x = pc_e,\n    y = pc_n,\n    ras_resolution = 20,\n)\n\n2025-09-21 16:41:13 - log_args - INFO - running function: pc_pyramid\n2025-09-21 16:41:13 - log_args - INFO - fetching args:\n2025-09-21 16:41:13 - log_args - INFO - pc = './pixel_refinement/hix/pc/pc_ph.zarr'\n2025-09-21 16:41:13 - log_args - INFO - out_dir = './pixel_refinement/hix/pc/pc_ph_pyramid'\n2025-09-21 16:41:13 - log_args - INFO - x = './pixel_refinement/hix/pc/pc_e.zarr'\n2025-09-21 16:41:13 - log_args - INFO - y = './pixel_refinement/hix/pc/pc_n.zarr'\n2025-09-21 16:41:14 - log_args - INFO - yx = None\n2025-09-21 16:41:14 - log_args - INFO - ras_resolution = 20\n2025-09-21 16:41:14 - log_args - INFO - ras_chunks = (256, 256)\n2025-09-21 16:41:14 - log_args - INFO - pc_chunks = 65536\n2025-09-21 16:41:14 - log_args - INFO - processes = False\n2025-09-21 16:41:14 - log_args - INFO - n_workers = 1\n2025-09-21 16:41:14 - log_args - INFO - threads_per_worker = 2\n2025-09-21 16:41:14 - log_args - INFO - dask_cluster_arg = {}\n2025-09-21 16:41:14 - log_args - INFO - fetching args done.\n2025-09-21 16:41:14 - pc_pyramid - INFO - clean out dir\n2025-09-21 16:41:14 - zarr_info - INFO - ./pixel_refinement/hix/pc/pc_ph.zarr zarray shape, chunks, dtype: (157318, 17), (200000, 1), complex64\n2025-09-21 16:41:14 - pc_pyramid - INFO - rendering point cloud data coordinates:\n2025-09-21 16:41:14 - pc_pyramid - INFO - rasterizing point cloud data to grid with bounds: [np.float64(-16498472.188209932), np.float64(8649654.067951033), np.float64(-16470212.188209932), np.float64(8674674.067951033)].\n2025-09-21 16:41:14 - zarr_info - INFO - pixel_refinement/hix/pc/pc_ph_pyramid/x.zarr zarray shape, chunks, dtype: (157318,), (65536,), float64\n2025-09-21 16:41:14 - zarr_info - INFO - pixel_refinement/hix/pc/pc_ph_pyramid/y.zarr zarray shape, chunks, dtype: (157318,), (65536,), float64\n2025-09-21 16:41:14 - pc_pyramid - INFO - pc data coordinates rendering ends.\n2025-09-21 16:41:14 - zarr_info - INFO - pixel_refinement/hix/pc/pc_ph_pyramid/idx_0.zarr zarray shape, chunks, dtype: (1252, 1414), (256, 256), int64\n2025-09-21 16:41:15 - zarr_info - INFO - pixel_refinement/hix/pc/pc_ph_pyramid/idx_1.zarr zarray shape, chunks, dtype: (626, 707), (256, 256), int64\n2025-09-21 16:41:15 - zarr_info - INFO - pixel_refinement/hix/pc/pc_ph_pyramid/idx_2.zarr zarray shape, chunks, dtype: (313, 354), (256, 256), int64\n2025-09-21 16:41:15 - zarr_info - INFO - pixel_refinement/hix/pc/pc_ph_pyramid/idx_3.zarr zarray shape, chunks, dtype: (157, 177), (256, 256), int64\n2025-09-21 16:41:15 - zarr_info - INFO - pixel_refinement/hix/pc/pc_ph_pyramid/idx_4.zarr zarray shape, chunks, dtype: (79, 89), (256, 256), int64\n2025-09-21 16:41:15 - zarr_info - INFO - pixel_refinement/hix/pc/pc_ph_pyramid/idx_5.zarr zarray shape, chunks, dtype: (40, 45), (256, 256), int64\n2025-09-21 16:41:15 - zarr_info - INFO - pixel_refinement/hix/pc/pc_ph_pyramid/idx_6.zarr zarray shape, chunks, dtype: (20, 23), (256, 256), int64\n2025-09-21 16:41:15 - zarr_info - INFO - pixel_refinement/hix/pc/pc_ph_pyramid/idx_7.zarr zarray shape, chunks, dtype: (10, 12), (256, 256), int64\n2025-09-21 16:41:15 - zarr_info - INFO - pixel_refinement/hix/pc/pc_ph_pyramid/idx_8.zarr zarray shape, chunks, dtype: (5, 6), (256, 256), int64\n2025-09-21 16:41:15 - zarr_info - INFO - pixel_refinement/hix/pc/pc_ph_pyramid/idx_9.zarr zarray shape, chunks, dtype: (3, 3), (256, 256), int64\n2025-09-21 16:41:15 - zarr_info - INFO - pixel_refinement/hix/pc/pc_ph_pyramid/idx_10.zarr zarray shape, chunks, dtype: (2, 2), (256, 256), int64\n2025-09-21 16:41:15 - pc_pyramid - INFO - rasterized idx rendering ends\n2025-09-21 16:41:15 - pc_pyramid - INFO - dask local cluster started to render pc data.\n2025-09-21 16:41:15 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.10:8787/status', workers=1, threads=2, memory=1.95 TiB)\n2025-09-21 16:41:15 - zarr_info - INFO - pixel_refinement/hix/pc/pc_ph_pyramid/pc.zarr zarray shape, chunks, dtype: (157318, 17), (65536, 1), complex64\n2025-09-21 16:41:15 - zarr_info - INFO - pixel_refinement/hix/pc/pc_ph_pyramid/0.zarr zarray shape, chunks, dtype: (1252, 1414, 17), (256, 256, 1), complex64\n2025-09-21 16:41:15 - zarr_info - INFO - pixel_refinement/hix/pc/pc_ph_pyramid/1.zarr zarray shape, chunks, dtype: (626, 707, 17), (256, 256, 1), complex64\n2025-09-21 16:41:15 - zarr_info - INFO - pixel_refinement/hix/pc/pc_ph_pyramid/2.zarr zarray shape, chunks, dtype: (313, 354, 17), (256, 256, 1), complex64\n2025-09-21 16:41:15 - zarr_info - INFO - pixel_refinement/hix/pc/pc_ph_pyramid/3.zarr zarray shape, chunks, dtype: (157, 177, 17), (256, 256, 1), complex64\n2025-09-21 16:41:15 - zarr_info - INFO - pixel_refinement/hix/pc/pc_ph_pyramid/4.zarr zarray shape, chunks, dtype: (79, 89, 17), (256, 256, 1), complex64\n2025-09-21 16:41:15 - zarr_info - INFO - pixel_refinement/hix/pc/pc_ph_pyramid/5.zarr zarray shape, chunks, dtype: (40, 45, 17), (256, 256, 1), complex64\n2025-09-21 16:41:15 - zarr_info - INFO - pixel_refinement/hix/pc/pc_ph_pyramid/6.zarr zarray shape, chunks, dtype: (20, 23, 17), (256, 256, 1), complex64\n2025-09-21 16:41:15 - zarr_info - INFO - pixel_refinement/hix/pc/pc_ph_pyramid/7.zarr zarray shape, chunks, dtype: (10, 12, 17), (256, 256, 1), complex64\n2025-09-21 16:41:15 - zarr_info - INFO - pixel_refinement/hix/pc/pc_ph_pyramid/8.zarr zarray shape, chunks, dtype: (5, 6, 17), (256, 256, 1), complex64\n2025-09-21 16:41:15 - zarr_info - INFO - pixel_refinement/hix/pc/pc_ph_pyramid/9.zarr zarray shape, chunks, dtype: (3, 3, 17), (256, 256, 1), complex64\n2025-09-21 16:41:15 - zarr_info - INFO - pixel_refinement/hix/pc/pc_ph_pyramid/10.zarr zarray shape, chunks, dtype: (2, 2, 17), (256, 256, 1), complex64\n2025-09-21 16:41:16 - pc_pyramid - INFO - computing graph setted. doing all the computing.\n2025-09-21 16:41:18 - pc_pyramid - INFO - computing finished.  1.9s\n2025-09-21 16:41:18 - pc_pyramid - INFO - dask cluster closed.\n\n\n\nintf_plot = mc.pc_plot(pc_ph_pyramid,post_proc_ras='intf_all', post_proc_pc='intf_all',level_increase=0)\n\n\nimport holoviews as hv\nfrom bokeh.models import WheelZoomTool\nhv.extension('bokeh')\nimport toml\nwith open('load_data/meta.toml','r') as f:\n    dates = toml.load(f)['dates']\nintf_plot = intf_plot.redim(i=hv.Dimension('i', label='Reference Image', range=(0,16), value_format=(lambda i: dates[i])),\n                            j=hv.Dimension('j', label='Secondary Image', range=(0,16), value_format=(lambda i: dates[i])),\n                            x=hv.Dimension('lon', label='Longitude'), y=hv.Dimension('lat',label='Latitude'), z=hv.Dimension('Phase',range=(-np.pi,np.pi)))\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n  \n  \n\n\n\n\n\n\n\n\nⓘ\n\n\n\n\n\nhv.output(widget_location='bottom')\nhv.element.tiles.EsriImagery()*intf_plot.opts(\n    hv.opts.Image(\n        cmap='colorwheel',width=600, height=400, colorbar=True,\n        default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],\n        active_tools=['wheel_zoom']\n    ),\n    hv.opts.Points(\n        color='Phase', cmap='colorwheel',width=600, height=400, colorbar=True,\n        default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],\n        active_tools=['wheel_zoom']\n    ),\n)",
    "crumbs": [
      "Tutorials",
      "CLI",
      "Pixel refinement"
    ]
  },
  {
    "objectID": "Tutorials/CLI/ds_processing.html",
    "href": "Tutorials/CLI/ds_processing.html",
    "title": "DS Processing",
    "section": "",
    "text": "In this tutorial, we demostrate how to do DS processing with the decorrelation CLI interface. The input data for DS processing is prepared in Load Data.\n!ls ./load_data\n\ne.zarr    lat.zarr  meta.toml  phi.zarr    rslc_pyramid  scratch\nhgt.zarr  lon.zarr  n.zarr     range.zarr  rslc.zarr     theta.zarr",
    "crumbs": [
      "Tutorials",
      "CLI",
      "DS Processing"
    ]
  },
  {
    "objectID": "Tutorials/CLI/ds_processing.html#shp-selection",
    "href": "Tutorials/CLI/ds_processing.html#shp-selection",
    "title": "DS Processing",
    "section": "SHP selection",
    "text": "SHP selection\nHere we use two sample Kolmogorov-Smirnov (KS) test for Spatially Homogenious Pixel (SHP) identification.\nThe output pvalue is the P-value for this test. The smaller the p-value, the more likely the two sample are from same distribution, i.e., the more likely the two pixels are SHP to each other.\n\nimport numpy as np\nimport moraine.cli as mc\nimport moraine as mr\n\n\nrslc = './load_data/rslc.zarr'\npvalue = './ds_processing/gix/ras_pvalue.zarr'\naz_half_win = 5\nr_half_win = 5\nmethod = 'ks'\n\n\nlogger = mc.get_logger()\n\n\nmc.shp_test(rslc,pvalue,\n            az_half_win=az_half_win,r_half_win=r_half_win)\n\n2025-09-20 23:29:58 - log_args - INFO - running function: shp_test\n2025-09-20 23:29:58 - log_args - INFO - fetching args:\n2025-09-20 23:29:58 - log_args - INFO - rslc = './load_data/rslc.zarr'\n2025-09-20 23:29:58 - log_args - INFO - pvalue = './ds_processing/gix/ras_pvalue.zarr'\n2025-09-20 23:29:58 - log_args - INFO - az_half_win = 5\n2025-09-20 23:29:58 - log_args - INFO - r_half_win = 5\n2025-09-20 23:29:58 - log_args - INFO - method = None\n2025-09-20 23:29:58 - log_args - INFO - chunks = None\n2025-09-20 23:29:58 - log_args - INFO - cuda = False\n2025-09-20 23:29:58 - log_args - INFO - processes = None\n2025-09-20 23:29:58 - log_args - INFO - n_workers = None\n2025-09-20 23:29:58 - log_args - INFO - threads_per_worker = None\n2025-09-20 23:29:58 - log_args - INFO - rmm_pool_size = 0.9\n2025-09-20 23:29:58 - log_args - INFO - dask_cluster_arg = {}\n2025-09-20 23:29:58 - log_args - INFO - fetching args done.\n2025-09-20 23:29:58 - shp_test - INFO - hypothetic test method: ks\n2025-09-20 23:29:58 - zarr_info - INFO - ./load_data/rslc.zarr zarray shape, chunks, dtype: (2500, 1834, 17), (1000, 1000, 1), complex64\n2025-09-20 23:29:58 - shp_test - INFO - starting dask local cluster.\n2025-09-20 23:30:02 - shp_test - INFO - dask local cluster started.\n2025-09-20 23:30:02 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.10:8787/status', workers=1, threads=1, memory=1.95 TiB)\n2025-09-20 23:30:02 - shp_test - INFO - azimuth half window size: 5; azimuth window size: 11\n2025-09-20 23:30:02 - shp_test - INFO - range half window size: 5; range window size: 11\n2025-09-20 23:30:02 - darr_info - INFO - rslc with overlap dask array shape, chunksize, dtype: (2520, 1844, 17), (1010, 1005, 17), complex64\n2025-09-20 23:30:03 - shp_test - INFO - applying test on rmli stack.\n2025-09-20 23:30:03 - shp_test - INFO - trim shared boundaries between p value chunks\n2025-09-20 23:30:03 - darr_info - INFO - p value dask array shape, chunksize, dtype: (2500, 1834, 11, 11), (1000, 1000, 11, 11), float32\n2025-09-20 23:30:03 - shp_test - INFO - saving p value.\n2025-09-20 23:30:03 - zarr_info - INFO - ./ds_processing/gix/ras_pvalue.zarr zarray shape, chunks, dtype: (2500, 1834, 11, 11), (1000, 1000, 1, 1), float32\n2025-09-20 23:30:03 - shp_test - INFO - computing graph setted. doing all the computing.\n2025-09-20 23:30:20 - shp_test - INFO - computing finished. | 16.8s\n2025-09-20 23:30:20 - shp_test - INFO - dask cluster closed.\n\n\nThen we select SHP by setting a threshold on this Pvalue:\n\nimport zarr\nfrom matplotlib import pyplot as plt\nimport colorcet\n\n\nis_shp = './ds_processing/gix/ras_is_shp.zarr'\nshp_num = './ds_processing/gix/ras_shp_num.zarr'\np_max = 0.05\n\n\nmc.select_shp(pvalue,is_shp,shp_num,p_max=p_max)\n\n2025-09-20 23:30:21 - log_args - INFO - running function: select_shp\n2025-09-20 23:30:21 - log_args - INFO - fetching args:\n2025-09-20 23:30:21 - log_args - INFO - pvalue = './ds_processing/gix/ras_pvalue.zarr'\n2025-09-20 23:30:21 - log_args - INFO - is_shp = './ds_processing/gix/ras_is_shp.zarr'\n2025-09-20 23:30:21 - log_args - INFO - shp_num = './ds_processing/gix/ras_shp_num.zarr'\n2025-09-20 23:30:21 - log_args - INFO - p_max = 0.05\n2025-09-20 23:30:21 - log_args - INFO - chunks = None\n2025-09-20 23:30:21 - log_args - INFO - processes = False\n2025-09-20 23:30:21 - log_args - INFO - n_workers = 1\n2025-09-20 23:30:21 - log_args - INFO - threads_per_worker = 1\n2025-09-20 23:30:21 - log_args - INFO - dask_cluster_arg = {}\n2025-09-20 23:30:21 - log_args - INFO - fetching args done.\n2025-09-20 23:30:21 - zarr_info - INFO - ./ds_processing/gix/ras_pvalue.zarr zarray shape, chunks, dtype: (2500, 1834, 11, 11), (1000, 1000, 1, 1), float32\n2025-09-20 23:30:21 - select_shp - INFO - starting dask cluster.\n2025-09-20 23:30:21 - select_shp - INFO - dask cluster started.\n2025-09-20 23:30:21 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.10:8787/status', workers=1, threads=1, memory=1.95 TiB)\n2025-09-20 23:30:21 - darr_info - INFO - pvalue dask array shape, chunksize, dtype: (2500, 1834, 11, 11), (1000, 1000, 11, 11), float32\n2025-09-20 23:30:21 - select_shp - INFO - selecting SHPs based on pvalue threshold: 0.05\n2025-09-20 23:30:21 - darr_info - INFO - is_shp dask array shape, chunksize, dtype: (2500, 1834, 11, 11), (1000, 1000, 11, 11), bool\n2025-09-20 23:30:21 - select_shp - INFO - calculate shp_num.\n2025-09-20 23:30:21 - darr_info - INFO - shp_num dask array shape, chunksize, dtype: (2500, 1834), (1000, 1000), int32\n2025-09-20 23:30:21 - select_shp - INFO - saving is_shp.\n2025-09-20 23:30:21 - zarr_info - INFO - ./ds_processing/gix/ras_is_shp.zarr zarray shape, chunks, dtype: (2500, 1834, 11, 11), (1000, 1000, 1, 1), bool\n2025-09-20 23:30:21 - select_shp - INFO - saving shp_num.\n2025-09-20 23:30:21 - zarr_info - INFO - ./ds_processing/gix/ras_shp_num.zarr zarray shape, chunks, dtype: (2500, 1834), (1000, 1000), int32\n2025-09-20 23:30:21 - select_shp - INFO - computing graph setted. doing all the computing.\n2025-09-20 23:30:32 - select_shp - INFO - computing finished. 11.0s\n2025-09-20 23:30:32 - select_shp - INFO - dask cluster closed.\n\n\nThe output is_shp indicate wheather a pixel in the window is a SHP to its center pixel.\n\nshp_num_zarr = zarr.open(shp_num,mode='r')\nshp_num_data = shp_num_zarr[:]\nshp_num_plot = mr.plot.ras_plot(shp_num_data)\n\n\nimport holoviews as hv\nhv.extension('bokeh')\nfrom bokeh.models import WheelZoomTool\nfrom holoviews import opts\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n  \n  \n\n\n\n\n\n\n\n\nⓘ\n\n\n\n\n\nshp_num_plot = shp_num_plot.redim(x=hv.Dimension('r', label='Range'), y=hv.Dimension('az',label='Azimuth'), z=hv.Dimension('n_shp',))\n\n\nshp_num_plot.opts(opts.Image(cmap='viridis',width=600, height=600, colorbar=True,\n                          invert_yaxis=True,\n                          default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],active_tools=['wheel_zoom']))",
    "crumbs": [
      "Tutorials",
      "CLI",
      "DS Processing"
    ]
  },
  {
    "objectID": "Tutorials/CLI/ds_processing.html#ds-candidates-selection",
    "href": "Tutorials/CLI/ds_processing.html#ds-candidates-selection",
    "title": "DS Processing",
    "section": "DS candidates selection",
    "text": "DS candidates selection\n\nds_can_gix = './ds_processing/gix/ds_can_gix.zarr'\nis_ds_can = './ds_processing/gix/ras_is_ds_can.zarr'\n\n\nmc.pc_logic_ras(shp_num,ds_can_gix,'ras&gt;=50',chunks=200000)\nmc.gix2bool(ds_can_gix, is_ds_can, shape= shp_num_zarr.shape)\n\n2025-09-20 23:33:59 - log_args - INFO - running function: pc_logic_ras\n2025-09-20 23:33:59 - log_args - INFO - fetching args:\n2025-09-20 23:33:59 - log_args - INFO - ras = './ds_processing/gix/ras_shp_num.zarr'\n2025-09-20 23:33:59 - log_args - INFO - gix = './ds_processing/gix/ds_can_gix.zarr'\n2025-09-20 23:33:59 - log_args - INFO - operation = 'ras&gt;=50'\n2025-09-20 23:33:59 - log_args - INFO - chunks = 200000\n2025-09-20 23:33:59 - log_args - INFO - fetching args done.\n2025-09-20 23:33:59 - zarr_info - INFO - ./ds_processing/gix/ras_shp_num.zarr zarray shape, chunks, dtype: (2500, 1834), (1000, 1000), int32\n2025-09-20 23:33:59 - pc_logic_ras - INFO - loading ras into memory.\n2025-09-20 23:33:59 - pc_logic_ras - INFO - select pc based on operation: ras&gt;=50\n2025-09-20 23:33:59 - pc_logic_ras - INFO - number of selected pixels: 732727.\n2025-09-20 23:33:59 - zarr_info - INFO - ./ds_processing/gix/ds_can_gix.zarr zarray shape, chunks, dtype: (732727, 2), (200000, 1), int32\n2025-09-20 23:33:59 - pc_logic_ras - INFO - writing gix.\n2025-09-20 23:33:59 - pc_logic_ras - INFO - write done.\n2025-09-20 23:33:59 - log_args - INFO - running function: gix2bool\n2025-09-20 23:33:59 - log_args - INFO - fetching args:\n2025-09-20 23:33:59 - log_args - INFO - gix = './ds_processing/gix/ds_can_gix.zarr'\n2025-09-20 23:33:59 - log_args - INFO - is_pc = './ds_processing/gix/ras_is_ds_can.zarr'\n2025-09-20 23:33:59 - log_args - INFO - shape = (2500, 1834)\n2025-09-20 23:33:59 - log_args - INFO - chunks = (1000, 1000)\n2025-09-20 23:33:59 - log_args - INFO - fetching args done.\n2025-09-20 23:33:59 - zarr_info - INFO - gix zarray shape, chunks, dtype: (732727, 2), (200000, 1), int32\n2025-09-20 23:33:59 - gix2bool - INFO - loading gix into memory.\n2025-09-20 23:33:59 - gix2bool - INFO - calculate the bool array\n2025-09-20 23:33:59 - zarr_info - INFO - is_pc zarray shape, chunks, dtype: (2500, 1834), (1000, 1000), bool\n2025-09-20 23:33:59 - gix2bool - INFO - write the bool array.\n2025-09-20 23:33:59 - gix2bool - INFO - write done.\n\n\nds_can_idx is a int array with shape of (num_of_DS_can, 2). It indicate the position of DS candidate in radar coordinate.\n\nis_ds_can_zarr = zarr.open(is_ds_can,mode='r')\nis_ds_can_data = is_ds_can_zarr[:]\nis_ds_can_plot = mr.ras_plot(is_ds_can_data)\n\n\nis_ds_can_plot = is_ds_can_plot.redim(x=hv.Dimension('r', label='Range'), y=hv.Dimension('az',label='Azimuth'), z=hv.Dimension('is_ds_can',))\nis_ds_can_plot.opts(opts.Image(cmap='viridis',width=600, height=600, colorbar=True,\n                          invert_yaxis=True,\n                          default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],active_tools=['wheel_zoom']))",
    "crumbs": [
      "Tutorials",
      "CLI",
      "DS Processing"
    ]
  },
  {
    "objectID": "Tutorials/CLI/ds_processing.html#coherence-matrix-estimation",
    "href": "Tutorials/CLI/ds_processing.html#coherence-matrix-estimation",
    "title": "DS Processing",
    "section": "Coherence matrix estimation",
    "text": "Coherence matrix estimation\nThe coherence matrix estimation is kind of complicated as it involves both raster and point cloud data. We also want to save the output point cloud data in the hilbert order.\nFirst, we generate DS candidate point cloud is_shp by ras chunks (which is a directory):\n\nds_can_is_shp_dir = './ds_processing/gix/ds_can_is_shp'\nds_can_key = './ds_processing/gix/ds_can_key.zarr'\n\n\nmc.ras2pc_ras_chunk(ds_can_gix,is_shp,ds_can_is_shp_dir,ds_can_key,chunks=(1000,1000))\n\n2025-09-20 23:34:09 - log_args - INFO - running function: ras2pc_ras_chunk\n2025-09-20 23:34:09 - log_args - INFO - fetching args:\n2025-09-20 23:34:09 - log_args - INFO - gix = './ds_processing/gix/ds_can_gix.zarr'\n2025-09-20 23:34:09 - log_args - INFO - ras = './ds_processing/gix/ras_is_shp.zarr'\n2025-09-20 23:34:09 - log_args - INFO - pc = './ds_processing/gix/ds_can_is_shp'\n2025-09-20 23:34:09 - log_args - INFO - key = './ds_processing/gix/ds_can_key.zarr'\n2025-09-20 23:34:09 - log_args - INFO - chunks = (1000, 1000)\n2025-09-20 23:34:09 - log_args - INFO - processes = False\n2025-09-20 23:34:09 - log_args - INFO - n_workers = 1\n2025-09-20 23:34:09 - log_args - INFO - threads_per_worker = 1\n2025-09-20 23:34:09 - log_args - INFO - dask_cluster_arg = {}\n2025-09-20 23:34:09 - log_args - INFO - fetching args done.\n2025-09-20 23:34:09 - zarr_info - INFO - ./ds_processing/gix/ds_can_gix.zarr zarray shape, chunks, dtype: (732727, 2), (200000, 1), int32\n2025-09-20 23:34:09 - ras2pc_ras_chunk - INFO - loading gix into memory.\n2025-09-20 23:34:09 - ras2pc_ras_chunk - INFO - convert gix to the order of ras chunk\n2025-09-20 23:34:15 - ras2pc_ras_chunk - INFO - save key\n2025-09-20 23:34:15 - ras2pc_ras_chunk - INFO - starting dask local cluster.\n2025-09-20 23:34:15 - ras2pc_ras_chunk - INFO - dask local cluster started.\n2025-09-20 23:34:15 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.10:8787/status', workers=1, threads=1, memory=1.95 TiB)\n2025-09-20 23:34:15 - ras2pc_ras_chunk - INFO - start to slice on ./ds_processing/gix/ras_is_shp.zarr\n2025-09-20 23:34:15 - zarr_info - INFO - ./ds_processing/gix/ras_is_shp.zarr zarray shape, chunks, dtype: (2500, 1834, 11, 11), (1000, 1000, 1, 1), bool\n2025-09-20 23:34:15 - darr_info - INFO - ras dask array shape, chunksize, dtype: (2500, 1834, 11, 11), (1000, 1000, 11, 11), bool\n2025-09-20 23:34:15 - darr_info - INFO - pc dask array shape, chunksize, dtype: (732727, 11, 11), (201403, 11, 11), bool\n2025-09-20 23:34:15 - ras2pc_ras_chunk - INFO - saving to ds_processing/gix/ds_can_is_shp.\n2025-09-20 23:34:15 - ras2pc_ras_chunk - INFO - computing graph setted. doing all the computing.\n2025-09-20 23:34:19 - ras2pc_ras_chunk - INFO - computing finished.\n2025-09-20 23:34:19 - ras2pc_ras_chunk - INFO - dask cluster closed.\n\n\nThen we estimate the coherence matrix:\n\nds_can_coh_dir = './ds_processing/gix/ds_can_coh'\n\n\nmc.emperical_co_pc(rslc,ds_can_is_shp_dir,ds_can_gix,ds_can_coh_dir,cuda=True)\n\n2025-09-20 23:34:28 - log_args - INFO - running function: emperical_co_pc\n2025-09-20 23:34:28 - log_args - INFO - fetching args:\n2025-09-20 23:34:28 - log_args - INFO - rslc = './load_data/rslc.zarr'\n2025-09-20 23:34:28 - log_args - INFO - is_shp_dir = './ds_processing/gix/ds_can_is_shp'\n2025-09-20 23:34:28 - log_args - INFO - gix = './ds_processing/gix/ds_can_gix.zarr'\n2025-09-20 23:34:28 - log_args - INFO - coh_dir = './ds_processing/gix/ds_can_coh'\n2025-09-20 23:34:28 - log_args - INFO - image_pairs = None\n2025-09-20 23:34:28 - log_args - INFO - chunks = None\n2025-09-20 23:34:28 - log_args - INFO - cuda = True\n2025-09-20 23:34:28 - log_args - INFO - processes = None\n2025-09-20 23:34:28 - log_args - INFO - n_workers = None\n2025-09-20 23:34:28 - log_args - INFO - threads_per_worker = None\n2025-09-20 23:34:28 - log_args - INFO - rmm_pool_size = 0.9\n2025-09-20 23:34:28 - log_args - INFO - dask_cluster_arg = {}\n2025-09-20 23:34:28 - log_args - INFO - fetching args done.\n2025-09-20 23:34:29 - zarr_info - INFO - ./load_data/rslc.zarr zarray shape, chunks, dtype: (2500, 1834, 17), (1000, 1000, 1), complex64\n2025-09-20 23:34:29 - emperical_co_pc - INFO - azimuth window size and half azimuth window size: 11, 5\n2025-09-20 23:34:29 - emperical_co_pc - INFO - range window size and half range window size: 11, 5\n2025-09-20 23:34:29 - emperical_co_pc - INFO - parallel processing azimuth chunk size: 1000\n2025-09-20 23:34:29 - emperical_co_pc - INFO - parallel processing range chunk size: 1000\n2025-09-20 23:34:29 - zarr_info - INFO - ./ds_processing/gix/ds_can_gix.zarr zarray shape, chunks, dtype: (732727, 2), (200000, 1), int32\n2025-09-20 23:34:29 - emperical_co_pc - INFO - loading gix into memory.\n2025-09-20 23:34:29 - emperical_co_pc - INFO - convert gix to the order of ras chunk\n2025-09-20 23:34:29 - emperical_co_pc - INFO - starting dask cluster.\n2025-09-20 23:34:35 - emperical_co_pc - INFO - dask cluster started.\n2025-09-20 23:34:35 - dask_cluster_info - INFO - dask cluster: LocalCUDACluster(dashboard_link='http://127.0.0.1:8787/status', workers=8, threads=8, memory=1.95 TiB)\n2025-09-20 23:34:35 - darr_info - INFO - rslc_overlap dask array shape, chunksize, dtype: (2520, 1844, 17), (1010, 1005, 17), complex64\n2025-09-20 23:34:35 - darr_info - INFO - gix in ras chunk order dask array shape, chunksize, dtype: (732727, 2), (201403, 2), int32\n2025-09-20 23:34:36 - emperical_co_pc - INFO - estimating coherence matrix chunk by chunk.\n2025-09-20 23:34:36 - darr_info - INFO - is_shp for chunk 0 dask array shape, chunksize, dtype: (201097, 11, 11), (201097, 11, 11), bool\n2025-09-20 23:34:36 - darr_info - INFO - coh for chunk 0 dask array shape, chunksize, dtype: (201097, 136), (201097, 136), complex64\n2025-09-20 23:34:36 - emperical_co_pc - INFO - saving coh for chunk 0\n2025-09-20 23:34:36 - zarr_info - INFO - ds_processing/gix/ds_can_coh/0.zarr zarray shape, chunks, dtype: (201097, 136), (201097, 1), complex64\n2025-09-20 23:34:36 - darr_info - INFO - is_shp for chunk 1 dask array shape, chunksize, dtype: (137562, 11, 11), (137562, 11, 11), bool\n2025-09-20 23:34:36 - darr_info - INFO - coh for chunk 1 dask array shape, chunksize, dtype: (137562, 136), (137562, 136), complex64\n2025-09-20 23:34:36 - emperical_co_pc - INFO - saving coh for chunk 1\n2025-09-20 23:34:36 - zarr_info - INFO - ds_processing/gix/ds_can_coh/1.zarr zarray shape, chunks, dtype: (137562, 136), (137562, 1), complex64\n2025-09-20 23:34:36 - darr_info - INFO - is_shp for chunk 2 dask array shape, chunksize, dtype: (201403, 11, 11), (201403, 11, 11), bool\n2025-09-20 23:34:36 - darr_info - INFO - coh for chunk 2 dask array shape, chunksize, dtype: (201403, 136), (201403, 136), complex64\n2025-09-20 23:34:36 - emperical_co_pc - INFO - saving coh for chunk 2\n2025-09-20 23:34:36 - zarr_info - INFO - ds_processing/gix/ds_can_coh/2.zarr zarray shape, chunks, dtype: (201403, 136), (201403, 1), complex64\n2025-09-20 23:34:36 - darr_info - INFO - is_shp for chunk 3 dask array shape, chunksize, dtype: (73518, 11, 11), (73518, 11, 11), bool\n2025-09-20 23:34:36 - darr_info - INFO - coh for chunk 3 dask array shape, chunksize, dtype: (73518, 136), (73518, 136), complex64\n2025-09-20 23:34:36 - emperical_co_pc - INFO - saving coh for chunk 3\n2025-09-20 23:34:36 - zarr_info - INFO - ds_processing/gix/ds_can_coh/3.zarr zarray shape, chunks, dtype: (73518, 136), (73518, 1), complex64\n2025-09-20 23:34:36 - darr_info - INFO - is_shp for chunk 4 dask array shape, chunksize, dtype: (78445, 11, 11), (78445, 11, 11), bool\n2025-09-20 23:34:36 - darr_info - INFO - coh for chunk 4 dask array shape, chunksize, dtype: (78445, 136), (78445, 136), complex64\n2025-09-20 23:34:36 - emperical_co_pc - INFO - saving coh for chunk 4\n2025-09-20 23:34:36 - zarr_info - INFO - ds_processing/gix/ds_can_coh/4.zarr zarray shape, chunks, dtype: (78445, 136), (78445, 1), complex64\n2025-09-20 23:34:36 - darr_info - INFO - is_shp for chunk 5 dask array shape, chunksize, dtype: (40702, 11, 11), (40702, 11, 11), bool\n2025-09-20 23:34:36 - darr_info - INFO - coh for chunk 5 dask array shape, chunksize, dtype: (40702, 136), (40702, 136), complex64\n2025-09-20 23:34:36 - emperical_co_pc - INFO - saving coh for chunk 5\n2025-09-20 23:34:36 - zarr_info - INFO - ds_processing/gix/ds_can_coh/5.zarr zarray shape, chunks, dtype: (40702, 136), (40702, 1), complex64\n2025-09-20 23:34:36 - emperical_co_pc - INFO - computing graph setted. doing all the computing.\n2025-09-20 23:34:39 - emperical_co_pc - INFO - computing finished.s\n2025-09-20 23:34:41 - emperical_co_pc - INFO - dask cluster closed.\n\n\nThe output of emperical_co_pc is point cloud data in the raster chunk order. So we prepare the key to sort the point cloud data to hilbert order (the hillbert index of DS candidate can be generated by the way):\n\nds_can_hix_unsorted = './ds_processing/gix/ds_can_hix.zarr'\nds_can_hix = './ds_processing/hix/ds_can/ds_can_hix.zarr'\ngix2hix_key = './ds_processing/gix/gix2hix.zarr'\n\n\nmc.pc_hix(ds_can_gix, ds_can_hix_unsorted, shape=zarr.open(rslc,mode='r').shape[:2])\nmc.pc_sort(\n    ds_can_hix_unsorted, ds_can_hix,\n    shape=zarr.open(rslc,mode='r').shape[:2],\n    pc_in = './ds_processing/gix/ds_can_gix.zarr',\n    pc = './ds_processing/hix/ds_can/ds_can_gix.zarr',\n    key=gix2hix_key,\n)\n\n2025-09-20 23:34:58 - log_args - INFO - running function: pc_hix\n2025-09-20 23:34:58 - log_args - INFO - fetching args:\n2025-09-20 23:34:58 - log_args - INFO - gix = './ds_processing/gix/ds_can_gix.zarr'\n2025-09-20 23:34:58 - log_args - INFO - hix = './ds_processing/gix/ds_can_hix.zarr'\n2025-09-20 23:34:58 - log_args - INFO - shape = (2500, 1834)\n2025-09-20 23:34:58 - log_args - INFO - fetching args done.\n2025-09-20 23:34:58 - zarr_info - INFO - ./ds_processing/gix/ds_can_gix.zarr zarray shape, chunks, dtype: (732727, 2), (200000, 1), int32\n2025-09-20 23:34:58 - zarr_info - INFO - ./ds_processing/gix/ds_can_hix.zarr zarray shape, chunks, dtype: (732727,), (200000,), int64\n2025-09-20 23:34:58 - pc_hix - INFO - calculating the hillbert index based on grid index\n2025-09-20 23:34:58 - pc_hix - INFO - writing the hillbert index\n2025-09-20 23:34:58 - pc_hix - INFO - done.\n2025-09-20 23:34:58 - log_args - INFO - running function: pc_sort\n2025-09-20 23:34:58 - log_args - INFO - fetching args:\n2025-09-20 23:34:58 - log_args - INFO - idx_in = './ds_processing/gix/ds_can_hix.zarr'\n2025-09-20 23:34:58 - log_args - INFO - idx = './ds_processing/hix/ds_can/ds_can_hix.zarr'\n2025-09-20 23:34:58 - log_args - INFO - pc_in = './ds_processing/gix/ds_can_gix.zarr'\n2025-09-20 23:34:58 - log_args - INFO - pc = './ds_processing/hix/ds_can/ds_can_gix.zarr'\n2025-09-20 23:34:58 - log_args - INFO - shape = (2500, 1834)\n2025-09-20 23:34:58 - log_args - INFO - chunks = None\n2025-09-20 23:34:58 - log_args - INFO - key = './ds_processing/gix/gix2hix.zarr'\n2025-09-20 23:34:58 - log_args - INFO - processes = False\n2025-09-20 23:34:58 - log_args - INFO - n_workers = 1\n2025-09-20 23:34:58 - log_args - INFO - threads_per_worker = 1\n2025-09-20 23:34:58 - log_args - INFO - dask_cluster_arg = {}\n2025-09-20 23:34:58 - log_args - INFO - fetching args done.\n2025-09-20 23:34:58 - zarr_info - INFO - ./ds_processing/gix/ds_can_hix.zarr zarray shape, chunks, dtype: (732727,), (200000,), int64\n2025-09-20 23:34:58 - pc_sort - INFO - loading idx_in and calculate the sorting indices.\n2025-09-20 23:34:58 - pc_sort - INFO - output pc chunk size is 200000\n2025-09-20 23:34:58 - pc_sort - INFO - write idx\n2025-09-20 23:34:58 - zarr_info - INFO - idx zarray shape, chunks, dtype: (732727,), (200000,), int64\n2025-09-20 23:34:58 - pc_sort - INFO - saving key for this sorting\n2025-09-20 23:34:58 - pc_sort - INFO - starting dask local cluster.\n2025-09-20 23:34:58 - pc_sort - INFO - dask local cluster started.\n2025-09-20 23:34:58 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.10:8787/status', workers=1, threads=1, memory=1.95 TiB)\n2025-09-20 23:34:58 - zarr_info - INFO - ./ds_processing/gix/ds_can_gix.zarr zarray shape, chunks, dtype: (732727, 2), (200000, 1), int32\n2025-09-20 23:34:58 - darr_info - INFO - pc_in dask array shape, chunksize, dtype: (732727, 2), (732727, 1), int32\n2025-09-20 23:34:58 - pc_sort - INFO - set up sorted pc data dask array.\n2025-09-20 23:34:58 - darr_info - INFO - pc dask array shape, chunksize, dtype: (732727, 2), (732727, 1), int32\n2025-09-20 23:34:58 - pc_sort - INFO - write pc to ./ds_processing/hix/ds_can/ds_can_gix.zarr\n2025-09-20 23:34:58 - zarr_info - INFO - ./ds_processing/hix/ds_can/ds_can_gix.zarr zarray shape, chunks, dtype: (732727, 2), (200000, 1), int32\n2025-09-20 23:34:58 - pc_sort - INFO - computing graph setted. doing all the computing.\n2025-09-20 23:34:59 - pc_sort - INFO - computing finished.d |  0.1s\n2025-09-20 23:34:59 - pc_sort - INFO - dask cluster closed.\n\n\nThen concat and sort ds_can_coh to hilbert order:\n\nds_can_coh = './ds_processing/hix/ds_can/ds_can_coh.zarr'\nds_can_coh_ave = './ds_processing/hix/ds_can/ds_can_coh_ave.zarr'\n\n\nchunks = zarr.open(ds_can_gix,mode='r').chunks[0]\nmc.pc_concat(ds_can_coh_dir,ds_can_coh,key=[ds_can_key,gix2hix_key],chunks=chunks)\n\n2025-09-20 23:35:07 - log_args - INFO - running function: pc_concat\n2025-09-20 23:35:07 - log_args - INFO - fetching args:\n2025-09-20 23:35:07 - log_args - INFO - pcs = './ds_processing/gix/ds_can_coh'\n2025-09-20 23:35:07 - log_args - INFO - pc = './ds_processing/hix/ds_can/ds_can_coh.zarr'\n2025-09-20 23:35:07 - log_args - INFO - key = ['./ds_processing/gix/ds_can_key.zarr', './ds_processing/gix/gix2hix.zarr']\n2025-09-20 23:35:07 - log_args - INFO - chunks = 200000\n2025-09-20 23:35:07 - log_args - INFO - processes = False\n2025-09-20 23:35:07 - log_args - INFO - n_workers = 1\n2025-09-20 23:35:07 - log_args - INFO - threads_per_worker = 1\n2025-09-20 23:35:07 - log_args - INFO - dask_cluster_arg = {}\n2025-09-20 23:35:07 - log_args - INFO - fetching args done.\n2025-09-20 23:35:07 - pc_concat - INFO - input pcs: [[PosixPath('ds_processing/gix/ds_can_coh/0.zarr'), PosixPath('ds_processing/gix/ds_can_coh/1.zarr'), PosixPath('ds_processing/gix/ds_can_coh/2.zarr'), PosixPath('ds_processing/gix/ds_can_coh/3.zarr'), PosixPath('ds_processing/gix/ds_can_coh/4.zarr'), PosixPath('ds_processing/gix/ds_can_coh/5.zarr')]]\n2025-09-20 23:35:07 - pc_concat - INFO - output pc: ['./ds_processing/hix/ds_can/ds_can_coh.zarr']\n2025-09-20 23:35:07 - pc_concat - INFO - load key\n2025-09-20 23:35:07 - zarr_info - INFO - ./ds_processing/gix/ds_can_key.zarr zarray shape, chunks, dtype: (732727,), (200000,), int64\n2025-09-20 23:35:07 - zarr_info - INFO - ./ds_processing/gix/gix2hix.zarr zarray shape, chunks, dtype: (732727,), (200000,), int64\n2025-09-20 23:35:07 - pc_concat - INFO - starting dask local cluster.\n2025-09-20 23:35:07 - pc_concat - INFO - dask local cluster started.\n2025-09-20 23:35:07 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.10:8787/status', workers=1, threads=1, memory=1.95 TiB)\n2025-09-20 23:35:07 - pc_concat - INFO - read pc from [PosixPath('ds_processing/gix/ds_can_coh/0.zarr'), PosixPath('ds_processing/gix/ds_can_coh/1.zarr'), PosixPath('ds_processing/gix/ds_can_coh/2.zarr'), PosixPath('ds_processing/gix/ds_can_coh/3.zarr'), PosixPath('ds_processing/gix/ds_can_coh/4.zarr'), PosixPath('ds_processing/gix/ds_can_coh/5.zarr')]\n2025-09-20 23:35:07 - darr_info - INFO - concatenated pc dask array shape, chunksize, dtype: (732727, 136), (732727, 1), complex64\n2025-09-20 23:35:07 - pc_concat - INFO - sort pc according to key\n2025-09-20 23:35:07 - darr_info - INFO - sorted pc dask array shape, chunksize, dtype: (732727, 136), (732727, 1), complex64\n2025-09-20 23:35:07 - pc_concat - INFO - save pc to ./ds_processing/hix/ds_can/ds_can_coh.zarr\n2025-09-20 23:35:08 - zarr_info - INFO - ./ds_processing/hix/ds_can/ds_can_coh.zarr zarray shape, chunks, dtype: (732727, 136), (200000, 1), complex64\n2025-09-20 23:35:08 - pc_concat - INFO - computing graph setted. doing all the computing.\n2025-09-20 23:35:15 - pc_concat - INFO - computing finished.|  7.3s\n2025-09-20 23:35:15 - pc_concat - INFO - dask cluster closed.\n\n\n\nn_points = zarr.open(ds_can_coh,mode='r').shape[0]\nmc.data_reduce(ds_can_coh,ds_can_coh_ave,map_func=np.abs,reduce_func=np.sum,post_map_func=lambda x: x/n_points)\n\n2025-09-20 23:35:23 - log_args - INFO - running function: data_reduce\n2025-09-20 23:35:23 - log_args - INFO - fetching args:\n2025-09-20 23:35:23 - log_args - INFO - data_in = './ds_processing/hix/ds_can/ds_can_coh.zarr'\n2025-09-20 23:35:23 - log_args - INFO - out = './ds_processing/hix/ds_can/ds_can_coh_ave.zarr'\n2025-09-20 23:35:23 - log_args - INFO - map_func = &lt;ufunc 'absolute'&gt;\n2025-09-20 23:35:23 - log_args - INFO - reduce_func = &lt;function sum&gt;\n2025-09-20 23:35:23 - log_args - INFO - axis = 0\n2025-09-20 23:35:23 - log_args - INFO - post_map_func = &lt;function &lt;lambda&gt;&gt;\n2025-09-20 23:35:23 - log_args - INFO - processes = False\n2025-09-20 23:35:23 - log_args - INFO - n_workers = 1\n2025-09-20 23:35:23 - log_args - INFO - threads_per_worker = 1\n2025-09-20 23:35:23 - log_args - INFO - dask_cluster_arg = {}\n2025-09-20 23:35:23 - log_args - INFO - fetching args done.\n2025-09-20 23:35:23 - zarr_info - INFO - ./ds_processing/hix/ds_can/ds_can_coh.zarr zarray shape, chunks, dtype: (732727, 136), (200000, 1), complex64\n2025-09-20 23:35:23 - data_reduce - INFO - starting dask local cluster.\n2025-09-20 23:35:23 - data_reduce - INFO - dask local cluster started.\n2025-09-20 23:35:23 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.10:8787/status', workers=1, threads=1, memory=1.95 TiB)\n2025-09-20 23:35:23 - darr_info - INFO - data_in dask array shape, chunksize, dtype: (732727, 136), (200000, 1), complex64\n2025-09-20 23:35:23 - darr_info - INFO - maped_data_in dask array shape, chunksize, dtype: (732727, 136), (200000, 1), float32\n2025-09-20 23:35:23 - darr_info - INFO - reduced data in every chunk dask array shape, chunksize, dtype: (4, 136), (1, 1), float32\n2025-09-20 23:35:23 - data_reduce - INFO - computing graph setted. doing all the computing.\n2025-09-20 23:35:26 - data_reduce - INFO - computing finished. 2.8s\n2025-09-20 23:35:26 - data_reduce - INFO - dask cluster closed.\n2025-09-20 23:35:26 - data_reduce - INFO - continue the reduction on reduced data over every chunk\n2025-09-20 23:35:26 - data_reduce - INFO - post mapping\n2025-09-20 23:35:26 - data_reduce - INFO - writing output.\n2025-09-20 23:35:26 - data_reduce - INFO - done.\n\n\n\nds_can_coh_ave_zarr = zarr.open(ds_can_coh_ave,mode='r')\nds_can_coh_ave_plot = mr.plot.ras_plot(mr.uncompress_coh(ds_can_coh_ave_zarr[:]))\nds_can_coh_ave_plot = ds_can_coh_ave_plot.redim(x=hv.Dimension('sec_image', label='Secondary image'), y=hv.Dimension('ref_image',label='Reference image'), z=hv.Dimension('ds_can_coh_ave',))\nds_can_coh_ave_plot.opts(opts.Image(cmap='viridis',frame_width=600, frame_height=600, colorbar=True,\n                          invert_yaxis=True,\n                          default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],active_tools=['wheel_zoom']))",
    "crumbs": [
      "Tutorials",
      "CLI",
      "DS Processing"
    ]
  },
  {
    "objectID": "Tutorials/CLI/ds_processing.html#visualize-adpative-multi-looked-interferograms",
    "href": "Tutorials/CLI/ds_processing.html#visualize-adpative-multi-looked-interferograms",
    "title": "DS Processing",
    "section": "Visualize adpative multi-looked interferograms",
    "text": "Visualize adpative multi-looked interferograms\nVisualize interferograms after adaptive multi-looking and compare with the raw 1 by 1 look interferograms:\n\nmc.pc_pyramid(\n    './ds_processing/hix/ds_can/ds_can_coh.zarr',\n    './ds_processing/hix/ds_can/ds_can_coh_pyramid',\n    yx = './ds_processing/hix/ds_can/ds_can_gix.zarr',\n    ras_resolution=2,\n)\n\n2025-09-20 23:35:36 - log_args - INFO - running function: pc_pyramid\n2025-09-20 23:35:36 - log_args - INFO - fetching args:\n2025-09-20 23:35:36 - log_args - INFO - pc = './ds_processing/hix/ds_can/ds_can_coh.zarr'\n2025-09-20 23:35:36 - log_args - INFO - out_dir = './ds_processing/hix/ds_can/ds_can_coh_pyramid'\n2025-09-20 23:35:36 - log_args - INFO - x = None\n2025-09-20 23:35:36 - log_args - INFO - y = None\n2025-09-20 23:35:36 - log_args - INFO - yx = './ds_processing/hix/ds_can/ds_can_gix.zarr'\n2025-09-20 23:35:36 - log_args - INFO - ras_resolution = 2\n2025-09-20 23:35:36 - log_args - INFO - ras_chunks = (256, 256)\n2025-09-20 23:35:36 - log_args - INFO - pc_chunks = 65536\n2025-09-20 23:35:36 - log_args - INFO - processes = False\n2025-09-20 23:35:36 - log_args - INFO - n_workers = 1\n2025-09-20 23:35:36 - log_args - INFO - threads_per_worker = 2\n2025-09-20 23:35:36 - log_args - INFO - dask_cluster_arg = {}\n2025-09-20 23:35:36 - log_args - INFO - fetching args done.\n2025-09-20 23:35:36 - pc_pyramid - INFO - clean out dir\n2025-09-20 23:35:39 - zarr_info - INFO - ./ds_processing/hix/ds_can/ds_can_coh.zarr zarray shape, chunks, dtype: (732727, 136), (200000, 1), complex64\n2025-09-20 23:35:39 - pc_pyramid - INFO - rendering point cloud data coordinates:\n2025-09-20 23:35:39 - pc_pyramid - INFO - rasterizing point cloud data to grid with bounds: [np.int32(0), np.int32(0), np.int32(1832), np.int32(2498)].\n2025-09-20 23:35:39 - zarr_info - INFO - ds_processing/hix/ds_can/ds_can_coh_pyramid/x.zarr zarray shape, chunks, dtype: (732727,), (65536,), int32\n2025-09-20 23:35:39 - zarr_info - INFO - ds_processing/hix/ds_can/ds_can_coh_pyramid/y.zarr zarray shape, chunks, dtype: (732727,), (65536,), int32\n2025-09-20 23:35:39 - pc_pyramid - INFO - pc data coordinates rendering ends.\n2025-09-20 23:35:39 - zarr_info - INFO - ds_processing/hix/ds_can/ds_can_coh_pyramid/idx_0.zarr zarray shape, chunks, dtype: (1250, 917), (256, 256), int64\n2025-09-20 23:35:41 - zarr_info - INFO - ds_processing/hix/ds_can/ds_can_coh_pyramid/idx_1.zarr zarray shape, chunks, dtype: (625, 459), (256, 256), int64\n2025-09-20 23:35:41 - zarr_info - INFO - ds_processing/hix/ds_can/ds_can_coh_pyramid/idx_2.zarr zarray shape, chunks, dtype: (313, 230), (256, 256), int64\n2025-09-20 23:35:41 - zarr_info - INFO - ds_processing/hix/ds_can/ds_can_coh_pyramid/idx_3.zarr zarray shape, chunks, dtype: (157, 115), (256, 256), int64\n2025-09-20 23:35:41 - zarr_info - INFO - ds_processing/hix/ds_can/ds_can_coh_pyramid/idx_4.zarr zarray shape, chunks, dtype: (79, 58), (256, 256), int64\n2025-09-20 23:35:41 - zarr_info - INFO - ds_processing/hix/ds_can/ds_can_coh_pyramid/idx_5.zarr zarray shape, chunks, dtype: (40, 29), (256, 256), int64\n2025-09-20 23:35:41 - zarr_info - INFO - ds_processing/hix/ds_can/ds_can_coh_pyramid/idx_6.zarr zarray shape, chunks, dtype: (20, 15), (256, 256), int64\n2025-09-20 23:35:41 - zarr_info - INFO - ds_processing/hix/ds_can/ds_can_coh_pyramid/idx_7.zarr zarray shape, chunks, dtype: (10, 8), (256, 256), int64\n2025-09-20 23:35:41 - zarr_info - INFO - ds_processing/hix/ds_can/ds_can_coh_pyramid/idx_8.zarr zarray shape, chunks, dtype: (5, 4), (256, 256), int64\n2025-09-20 23:35:41 - zarr_info - INFO - ds_processing/hix/ds_can/ds_can_coh_pyramid/idx_9.zarr zarray shape, chunks, dtype: (3, 2), (256, 256), int64\n2025-09-20 23:35:41 - pc_pyramid - INFO - rasterized idx rendering ends\n2025-09-20 23:35:41 - pc_pyramid - INFO - dask local cluster started to render pc data.\n2025-09-20 23:35:41 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.10:8787/status', workers=1, threads=2, memory=1.95 TiB)\n2025-09-20 23:35:41 - zarr_info - INFO - ds_processing/hix/ds_can/ds_can_coh_pyramid/pc.zarr zarray shape, chunks, dtype: (732727, 136), (65536, 1), complex64\n2025-09-20 23:35:41 - zarr_info - INFO - ds_processing/hix/ds_can/ds_can_coh_pyramid/0.zarr zarray shape, chunks, dtype: (1250, 917, 136), (256, 256, 1), complex64\n2025-09-20 23:35:41 - zarr_info - INFO - ds_processing/hix/ds_can/ds_can_coh_pyramid/1.zarr zarray shape, chunks, dtype: (625, 459, 136), (256, 256, 1), complex64\n2025-09-20 23:35:41 - zarr_info - INFO - ds_processing/hix/ds_can/ds_can_coh_pyramid/2.zarr zarray shape, chunks, dtype: (313, 230, 136), (256, 256, 1), complex64\n2025-09-20 23:35:41 - zarr_info - INFO - ds_processing/hix/ds_can/ds_can_coh_pyramid/3.zarr zarray shape, chunks, dtype: (157, 115, 136), (256, 256, 1), complex64\n2025-09-20 23:35:41 - zarr_info - INFO - ds_processing/hix/ds_can/ds_can_coh_pyramid/4.zarr zarray shape, chunks, dtype: (79, 58, 136), (256, 256, 1), complex64\n2025-09-20 23:35:41 - zarr_info - INFO - ds_processing/hix/ds_can/ds_can_coh_pyramid/5.zarr zarray shape, chunks, dtype: (40, 29, 136), (256, 256, 1), complex64\n2025-09-20 23:35:41 - zarr_info - INFO - ds_processing/hix/ds_can/ds_can_coh_pyramid/6.zarr zarray shape, chunks, dtype: (20, 15, 136), (256, 256, 1), complex64\n2025-09-20 23:35:41 - zarr_info - INFO - ds_processing/hix/ds_can/ds_can_coh_pyramid/7.zarr zarray shape, chunks, dtype: (10, 8, 136), (256, 256, 1), complex64\n2025-09-20 23:35:41 - zarr_info - INFO - ds_processing/hix/ds_can/ds_can_coh_pyramid/8.zarr zarray shape, chunks, dtype: (5, 4, 136), (256, 256, 1), complex64\n2025-09-20 23:35:41 - zarr_info - INFO - ds_processing/hix/ds_can/ds_can_coh_pyramid/9.zarr zarray shape, chunks, dtype: (3, 2, 136), (256, 256, 1), complex64\n2025-09-20 23:35:43 - pc_pyramid - INFO - computing graph setted. doing all the computing.\n2025-09-20 23:35:58 - pc_pyramid - INFO - computing finished. 15.0s\n2025-09-20 23:35:58 - pc_pyramid - INFO - dask cluster closed.\n\n\n\nrslc_zarr = zarr.open(rslc,mode='r')\ntnet = mr.TempNet.from_bandwidth(rslc_zarr.shape[2])\n\n\ndef co_phase_post_proc_ras(data_zarr,xslice,yslice,i,j):\n    if i == j:\n        nx = xslice.stop-xslice.start\n        ny = yslice.stop-yslice.start\n        mask = np.isnan(data_zarr[yslice,xslice,0])\n        data = np.zeros((ny,nx),dtype=np.float32)\n        data[mask] = np.nan\n        return data\n    elif i &gt; j:\n        ref, sec = j, i\n        conj = True\n    else:\n        ref, sec = i, j\n        conj = False\n    image_pair_idx = tnet.image_pairs_idx(ref=ref,sec=sec)\n    if image_pair_idx == -1:\n        nx = xslice.stop-xslice.start\n        ny = yslice.stop-yslice.start\n        return np.full((ny,nx),fill_value=np.nan,dtype=np.float32)\n    data = data_zarr[yslice,xslice,image_pair_idx]\n    if conj:\n        return -np.angle(data)\n    else:\n        return np.angle(data)\n\n\ndef co_phase_post_proc_pc(data_zarr,idx_array,i,j):\n    if i == j:\n        data = np.zeros_like(idx_array,dtype=np.float32)\n        return data\n    elif i &gt; j:\n        ref, sec = j, i\n        conj = True\n    else:\n        ref, sec = i, j\n        conj = False\n    image_pair_idx = tnet.image_pairs_idx(ref=ref,sec=sec)\n    if image_pair_idx == -1:\n        return np.full_like(idx_array,fill_value=np.nan,dtype=np.float32)\n    data = data_zarr[idx_array,image_pair_idx]\n    if conj:\n        return -np.angle(data)\n    else:\n        return np.angle(data)\n\n\nds_can_intf_plot = mc.pc_plot(\n    './ds_processing/hix/ds_can/ds_can_coh_pyramid',\n    post_proc_ras=co_phase_post_proc_ras,\n    post_proc_pc=co_phase_post_proc_pc,\n    n_kdim=2,level_increase=1)\nraw_intf_plot = mc.ras_plot('./load_data/rslc_pyramid',post_proc='intf_all',n_kdim=2,level_increase=1)\nintf_plots = raw_intf_plot.relabel('Raw Interferograms') + ds_can_intf_plot.relabel('Adaptively multilooked Interferograms')\n\n\nimport holoviews as hv\nfrom bokeh.models import WheelZoomTool\nhv.extension('bokeh')\nimport toml\nwith open('load_data/meta.toml','r') as f:\n    dates = toml.load(f)['dates']\nintf_plots = intf_plots.redim(\n    i=hv.Dimension('i', label='Reference Image', range=(0,16), value_format=(lambda i: dates[i])),\n    j=hv.Dimension('j', label='Secondary Image', range=(0,16), value_format=(lambda i: dates[i])),\n    x=hv.Dimension('r', label='Range'),\n    y=hv.Dimension('az',label='Azimuth'),\n    z=hv.Dimension('Phase',range=(-np.pi,np.pi))\n)\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n  \n  \n\n\n\n\n\n\n\n\nⓘ\n\n\n\n\n\nhv.output(widget_location='bottom')\nintf_plots.opts(\n    hv.opts.Image(\n        cmap='colorwheel',frame_width=500, frame_height=600, colorbar=True,\n        default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],\n        active_tools=['wheel_zoom'],\n        invert_yaxis=True,\n    ),\n    hv.opts.Points(\n        color='Phase', cmap='colorwheel',frame_width=500, frame_height=600, colorbar=True,\n        default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],\n        active_tools=['wheel_zoom'],\n        invert_yaxis=True,\n    ),\n)",
    "crumbs": [
      "Tutorials",
      "CLI",
      "DS Processing"
    ]
  },
  {
    "objectID": "Tutorials/CLI/ds_processing.html#phase-linking",
    "href": "Tutorials/CLI/ds_processing.html#phase-linking",
    "title": "DS Processing",
    "section": "Phase linking",
    "text": "Phase linking\nTo get rid of the closure phase, phase linking is applied here:\n\nds_can_coh = './ds_processing/hix/ds_can/ds_can_coh.zarr'\nds_can_ph = './ds_processing/hix/ds_can/ds_can_ph.zarr'\nds_can_emi_quality = './ds_processing/hix/ds_can/ds_can_emi_quality.zarr'\nemi_quality = './ds_processing/hix/ds_can/ras_ds_can_emi_quality.zarr'\n\n\nmc.emi(ds_can_coh,ds_can_ph,ds_can_emi_quality)\n\n2025-09-20 23:36:28 - log_args - INFO - running function: emi\n2025-09-20 23:36:28 - log_args - INFO - fetching args:\n2025-09-20 23:36:28 - log_args - INFO - coh = './ds_processing/hix/ds_can/ds_can_coh.zarr'\n2025-09-20 23:36:28 - log_args - INFO - ph = './ds_processing/hix/ds_can/ds_can_ph.zarr'\n2025-09-20 23:36:28 - log_args - INFO - emi_quality = './ds_processing/hix/ds_can/ds_can_emi_quality.zarr'\n2025-09-20 23:36:28 - log_args - INFO - ref = 0\n2025-09-20 23:36:28 - log_args - INFO - chunks = None\n2025-09-20 23:36:28 - log_args - INFO - cuda = False\n2025-09-20 23:36:28 - log_args - INFO - processes = None\n2025-09-20 23:36:28 - log_args - INFO - n_workers = None\n2025-09-20 23:36:28 - log_args - INFO - threads_per_worker = None\n2025-09-20 23:36:28 - log_args - INFO - rmm_pool_size = 0.9\n2025-09-20 23:36:28 - log_args - INFO - dask_cluster_arg = {}\n2025-09-20 23:36:28 - log_args - INFO - fetching args done.\n2025-09-20 23:36:28 - zarr_info - INFO - ./ds_processing/hix/ds_can/ds_can_coh.zarr zarray shape, chunks, dtype: (732727, 136), (200000, 1), complex64\n2025-09-20 23:36:28 - emi - INFO - starting dask cluster.\n2025-09-20 23:36:28 - emi - INFO - dask cluster started.\n2025-09-20 23:36:28 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.10:8787/status', workers=1, threads=2, memory=1.95 TiB)\n2025-09-20 23:36:28 - darr_info - INFO - coh dask array shape, chunksize, dtype: (732727, 136), (200000, 136), complex64\n2025-09-20 23:36:28 - emi - INFO - phase linking with EMI.\n2025-09-20 23:36:28 - emi - INFO - got ph and emi_quality.\n2025-09-20 23:36:28 - darr_info - INFO - ph dask array shape, chunksize, dtype: (732727, 17), (200000, 17), complex64\n2025-09-20 23:36:28 - darr_info - INFO - emi_quality dask array shape, chunksize, dtype: (732727,), (200000,), float32\n2025-09-20 23:36:28 - emi - INFO - saving ph and emi_quality.\n2025-09-20 23:36:28 - zarr_info - INFO - ./ds_processing/hix/ds_can/ds_can_ph.zarr zarray shape, chunks, dtype: (732727, 17), (200000, 1), complex64\n2025-09-20 23:36:28 - zarr_info - INFO - ./ds_processing/hix/ds_can/ds_can_emi_quality.zarr zarray shape, chunks, dtype: (732727,), (200000,), float32\n2025-09-20 23:36:28 - emi - INFO - computing graph setted. doing all the computing.\n2025-09-20 23:36:34 - emi - INFO - computing finished.leted |  6.3s\n2025-09-20 23:36:34 - emi - INFO - dask cluster closed.\n\n\n\nrslc_zarr = zarr.open(rslc,mode='r')\nmc.pc2ras(ds_can_hix, ds_can_emi_quality,emi_quality,rslc_zarr.shape[:2])\n\n2025-09-20 23:36:41 - log_args - INFO - running function: pc2ras\n2025-09-20 23:36:41 - log_args - INFO - fetching args:\n2025-09-20 23:36:41 - log_args - INFO - idx = './ds_processing/hix/ds_can/ds_can_hix.zarr'\n2025-09-20 23:36:41 - log_args - INFO - pc = './ds_processing/hix/ds_can/ds_can_emi_quality.zarr'\n2025-09-20 23:36:41 - log_args - INFO - ras = './ds_processing/hix/ds_can/ras_ds_can_emi_quality.zarr'\n2025-09-20 23:36:41 - log_args - INFO - shape = (2500, 1834)\n2025-09-20 23:36:41 - log_args - INFO - chunks = (1000, 1000)\n2025-09-20 23:36:41 - log_args - INFO - processes = False\n2025-09-20 23:36:41 - log_args - INFO - n_workers = 1\n2025-09-20 23:36:41 - log_args - INFO - threads_per_worker = 1\n2025-09-20 23:36:41 - log_args - INFO - dask_cluster_arg = {}\n2025-09-20 23:36:41 - log_args - INFO - fetching args done.\n2025-09-20 23:36:41 - zarr_info - INFO - ./ds_processing/hix/ds_can/ds_can_hix.zarr zarray shape, chunks, dtype: (732727,), (200000,), int64\n2025-09-20 23:36:41 - pc2ras - INFO - loading hix into memory and convert to gix\n2025-09-20 23:36:43 - pc2ras - INFO - starting dask local cluster.\n2025-09-20 23:36:43 - pc2ras - INFO - dask local cluster started.\n2025-09-20 23:36:43 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.10:8787/status', workers=1, threads=1, memory=1.95 TiB)\n2025-09-20 23:36:43 - pc2ras - INFO - start to work on ./ds_processing/hix/ds_can/ds_can_emi_quality.zarr\n2025-09-20 23:36:43 - zarr_info - INFO - ./ds_processing/hix/ds_can/ds_can_emi_quality.zarr zarray shape, chunks, dtype: (732727,), (200000,), float32\n2025-09-20 23:36:43 - darr_info - INFO - pc dask array shape, chunksize, dtype: (732727,), (732727,), float32\n2025-09-20 23:36:43 - pc2ras - INFO - create ras dask array\n2025-09-20 23:36:43 - darr_info - INFO - ras dask array shape, chunksize, dtype: (2500, 1834), (2500, 1834), float32\n2025-09-20 23:36:43 - pc2ras - INFO - save ras to ./ds_processing/hix/ds_can/ras_ds_can_emi_quality.zarr\n2025-09-20 23:36:43 - zarr_info - INFO - ./ds_processing/hix/ds_can/ras_ds_can_emi_quality.zarr zarray shape, chunks, dtype: (2500, 1834), (1000, 1000), float32\n2025-09-20 23:36:43 - pc2ras - INFO - computing graph setted. doing all the computing.\n2025-09-20 23:36:43 - pc2ras - INFO - computing finished.ed |  0.1s\n2025-09-20 23:36:43 - pc2ras - INFO - dask cluster closed.\n\n\n\nemi_quality_zarr = zarr.open(emi_quality,mode='r')\nemi_quality_plot = mr.plot.ras_plot(emi_quality_zarr[:])\nemi_quality_plot = emi_quality_plot.redim(x=hv.Dimension('r', label='Range'), y=hv.Dimension('az',label='Azimuth'), z=hv.Dimension('emi_quality',range=(0.5,1.3)))\nemi_quality_plot.opts(opts.Image(cmap='viridis',frame_width=500, frame_height=600, colorbar=True,\n                          invert_yaxis=True,\n                          default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],active_tools=['wheel_zoom']))\n\n\n\n\n\n  \n\n\n\n\nWe can also estimate a temporal coherence for DS:\n\nds_can_t_coh = './ds_processing/hix/ds_can/ds_can_t_coh.zarr'\n\n\nmc.ds_temp_coh(ds_can_coh,ds_can_ph, ds_can_t_coh)\n\n2025-09-20 23:37:06 - log_args - INFO - running function: ds_temp_coh\n2025-09-20 23:37:06 - log_args - INFO - fetching args:\n2025-09-20 23:37:06 - log_args - INFO - coh = './ds_processing/hix/ds_can/ds_can_coh.zarr'\n2025-09-20 23:37:06 - log_args - INFO - ph = './ds_processing/hix/ds_can/ds_can_ph.zarr'\n2025-09-20 23:37:06 - log_args - INFO - t_coh = './ds_processing/hix/ds_can/ds_can_t_coh.zarr'\n2025-09-20 23:37:06 - log_args - INFO - tnet = None\n2025-09-20 23:37:06 - log_args - INFO - chunks = None\n2025-09-20 23:37:06 - log_args - INFO - cuda = False\n2025-09-20 23:37:06 - log_args - INFO - processes = None\n2025-09-20 23:37:06 - log_args - INFO - n_workers = None\n2025-09-20 23:37:06 - log_args - INFO - threads_per_worker = None\n2025-09-20 23:37:06 - log_args - INFO - rmm_pool_size = 0.9\n2025-09-20 23:37:06 - log_args - INFO - dask_cluster_arg = {}\n2025-09-20 23:37:06 - log_args - INFO - fetching args done.\n2025-09-20 23:37:06 - zarr_info - INFO - ./ds_processing/hix/ds_can/ds_can_coh.zarr zarray shape, chunks, dtype: (732727, 136), (200000, 1), complex64\n2025-09-20 23:37:06 - zarr_info - INFO - ./ds_processing/hix/ds_can/ds_can_ph.zarr zarray shape, chunks, dtype: (732727, 17), (200000, 1), complex64\n2025-09-20 23:37:06 - ds_temp_coh - INFO - starting dask local cluster.\n2025-09-20 23:37:06 - ds_temp_coh - INFO - dask local cluster started.\n2025-09-20 23:37:06 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.10:8787/status', workers=1, threads=2, memory=1.95 TiB)\n2025-09-20 23:37:06 - darr_info - INFO - coh dask array shape, chunksize, dtype: (732727, 136), (200000, 136), complex64\n2025-09-20 23:37:06 - darr_info - INFO - ph dask array shape, chunksize, dtype: (732727, 17), (200000, 17), complex64\n2025-09-20 23:37:06 - ds_temp_coh - INFO - Estimate temporal coherence for DS.\n2025-09-20 23:37:06 - ds_temp_coh - INFO - got temporal coherence t_coh.\n2025-09-20 23:37:06 - darr_info - INFO - t_coh dask array shape, chunksize, dtype: (732727,), (200000,), float32\n2025-09-20 23:37:06 - ds_temp_coh - INFO - saving t_coh.\n2025-09-20 23:37:06 - ds_temp_coh - INFO - computing graph setted. doing all the computing.\n2025-09-20 23:37:08 - ds_temp_coh - INFO - computing finished. 1.2s\n2025-09-20 23:37:08 - ds_temp_coh - INFO - dask cluster closed.\n\n\nPlot it:\n\nt_coh = './ds_processing/hix/ds_can/ras_ds_can_t_coh.zarr'\nrslc_zarr = zarr.open(rslc,mode='r')\nmc.pc2ras(ds_can_hix, ds_can_t_coh,t_coh,rslc_zarr.shape[:2])\n\n2025-09-20 23:37:14 - log_args - INFO - running function: pc2ras\n2025-09-20 23:37:14 - log_args - INFO - fetching args:\n2025-09-20 23:37:14 - log_args - INFO - idx = './ds_processing/hix/ds_can/ds_can_hix.zarr'\n2025-09-20 23:37:14 - log_args - INFO - pc = './ds_processing/hix/ds_can/ds_can_t_coh.zarr'\n2025-09-20 23:37:14 - log_args - INFO - ras = './ds_processing/hix/ds_can/ras_ds_can_t_coh.zarr'\n2025-09-20 23:37:14 - log_args - INFO - shape = (2500, 1834)\n2025-09-20 23:37:14 - log_args - INFO - chunks = (1000, 1000)\n2025-09-20 23:37:14 - log_args - INFO - processes = False\n2025-09-20 23:37:14 - log_args - INFO - n_workers = 1\n2025-09-20 23:37:14 - log_args - INFO - threads_per_worker = 1\n2025-09-20 23:37:14 - log_args - INFO - dask_cluster_arg = {}\n2025-09-20 23:37:14 - log_args - INFO - fetching args done.\n2025-09-20 23:37:14 - zarr_info - INFO - ./ds_processing/hix/ds_can/ds_can_hix.zarr zarray shape, chunks, dtype: (732727,), (200000,), int64\n2025-09-20 23:37:14 - pc2ras - INFO - loading hix into memory and convert to gix\n2025-09-20 23:37:14 - pc2ras - INFO - starting dask local cluster.\n2025-09-20 23:37:14 - pc2ras - INFO - dask local cluster started.\n2025-09-20 23:37:14 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.10:8787/status', workers=1, threads=1, memory=1.95 TiB)\n2025-09-20 23:37:14 - pc2ras - INFO - start to work on ./ds_processing/hix/ds_can/ds_can_t_coh.zarr\n2025-09-20 23:37:14 - zarr_info - INFO - ./ds_processing/hix/ds_can/ds_can_t_coh.zarr zarray shape, chunks, dtype: (732727,), (200000,), float32\n2025-09-20 23:37:14 - darr_info - INFO - pc dask array shape, chunksize, dtype: (732727,), (732727,), float32\n2025-09-20 23:37:14 - pc2ras - INFO - create ras dask array\n2025-09-20 23:37:14 - darr_info - INFO - ras dask array shape, chunksize, dtype: (2500, 1834), (2500, 1834), float32\n2025-09-20 23:37:14 - pc2ras - INFO - save ras to ./ds_processing/hix/ds_can/ras_ds_can_t_coh.zarr\n2025-09-20 23:37:14 - zarr_info - INFO - ./ds_processing/hix/ds_can/ras_ds_can_t_coh.zarr zarray shape, chunks, dtype: (2500, 1834), (1000, 1000), float32\n2025-09-20 23:37:14 - pc2ras - INFO - computing graph setted. doing all the computing.\n2025-09-20 23:37:14 - pc2ras - INFO - computing finished.ed |  0.1s\n2025-09-20 23:37:14 - pc2ras - INFO - dask cluster closed.\n\n\n\nt_coh_zarr = zarr.open(t_coh,mode='r')\nt_coh_plot = mr.plot.ras_plot(t_coh_zarr[:])\nt_coh_plot = t_coh_plot.redim(x=hv.Dimension('r', label='Range'), y=hv.Dimension('az',label='Azimuth'), z=hv.Dimension('t_coh',range=(0,1)))\nt_coh_plot.opts(opts.Image(cmap='viridis',frame_width=500, frame_height=600, colorbar=True,\n                          invert_yaxis=True,\n                          default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],active_tools=['wheel_zoom']))\n\n\n\n\n\n  \n\n\n\n\nThe full coherence matrix may be too big to be saved. It is also possible to do the coherence matrix estimation, phase linking together:\n\nds_can_ph_dir = './ds_processing/gix/ds_can_ph'\nds_can_emi_quality_dir = './ds_processing/gix/ds_can_emi_quality'\nds_can_t_coh_dir = './ds_processing/gix/ds_can_t_coh'\n\n\nmc.emperical_co_emi_temp_coh_pc(rslc,ds_can_is_shp_dir,ds_can_gix,ds_can_ph_dir,ds_can_emi_quality_dir,ds_can_t_coh_dir,chunks=(1000,1000),cuda=True)\nmc.pc_concat(\n    [ds_can_ph_dir,ds_can_emi_quality_dir,ds_can_t_coh_dir],\n    [ds_can_ph,ds_can_emi_quality,ds_can_t_coh],\n    key=[ds_can_key,gix2hix_key],\n    chunks=200000)\n\n2025-09-20 23:37:32 - log_args - INFO - running function: emperical_co_emi_temp_coh_pc\n2025-09-20 23:37:32 - log_args - INFO - fetching args:\n2025-09-20 23:37:32 - log_args - INFO - rslc = './load_data/rslc.zarr'\n2025-09-20 23:37:32 - log_args - INFO - is_shp_dir = './ds_processing/gix/ds_can_is_shp'\n2025-09-20 23:37:32 - log_args - INFO - gix = './ds_processing/gix/ds_can_gix.zarr'\n2025-09-20 23:37:32 - log_args - INFO - ph_dir = './ds_processing/gix/ds_can_ph'\n2025-09-20 23:37:32 - log_args - INFO - emi_quality_dir = './ds_processing/gix/ds_can_emi_quality'\n2025-09-20 23:37:32 - log_args - INFO - t_coh_dir = './ds_processing/gix/ds_can_t_coh'\n2025-09-20 23:37:32 - log_args - INFO - batch_size = 1000\n2025-09-20 23:37:32 - log_args - INFO - chunks = (1000, 1000)\n2025-09-20 23:37:32 - log_args - INFO - cuda = True\n2025-09-20 23:37:32 - log_args - INFO - processes = None\n2025-09-20 23:37:32 - log_args - INFO - n_workers = None\n2025-09-20 23:37:32 - log_args - INFO - threads_per_worker = None\n2025-09-20 23:37:32 - log_args - INFO - rmm_pool_size = 0.9\n2025-09-20 23:37:32 - log_args - INFO - dask_cluster_arg = {}\n2025-09-20 23:37:32 - log_args - INFO - fetching args done.\n2025-09-20 23:37:32 - zarr_info - INFO - ./load_data/rslc.zarr zarray shape, chunks, dtype: (2500, 1834, 17), (1000, 1000, 1), complex64\n2025-09-20 23:37:32 - emperical_co_emi_temp_coh_pc - INFO - azimuth window size and half azimuth window size: 11, 5\n2025-09-20 23:37:32 - emperical_co_emi_temp_coh_pc - INFO - range window size and half range window size: 11, 5\n2025-09-20 23:37:32 - emperical_co_emi_temp_coh_pc - INFO - parallel processing azimuth chunk size: 1000\n2025-09-20 23:37:32 - emperical_co_emi_temp_coh_pc - INFO - parallel processing range chunk size: 1000\n2025-09-20 23:37:32 - zarr_info - INFO - ./ds_processing/gix/ds_can_gix.zarr zarray shape, chunks, dtype: (732727, 2), (200000, 1), int32\n2025-09-20 23:37:32 - emperical_co_emi_temp_coh_pc - INFO - loading gix into memory.\n2025-09-20 23:37:32 - emperical_co_emi_temp_coh_pc - INFO - convert gix to the order of ras chunk\n2025-09-20 23:37:32 - emperical_co_emi_temp_coh_pc - INFO - starting dask cluster.\n2025-09-20 23:37:38 - emperical_co_emi_temp_coh_pc - INFO - dask cluster started.\n2025-09-20 23:37:38 - dask_cluster_info - INFO - dask cluster: LocalCUDACluster(dashboard_link='http://127.0.0.1:8787/status', workers=8, threads=8, memory=1.95 TiB)\n2025-09-20 23:37:38 - darr_info - INFO - rslc_overlap dask array shape, chunksize, dtype: (2520, 1844, 17), (1010, 1005, 17), complex64\n2025-09-20 23:37:38 - darr_info - INFO - gix in ras chunk order dask array shape, chunksize, dtype: (732727, 2), (201403, 2), int32\n2025-09-20 23:37:38 - emperical_co_emi_temp_coh_pc - INFO - estimating coherence matrix chunk by chunk.\n2025-09-20 23:37:38 - darr_info - INFO - is_shp for chunk 0 dask array shape, chunksize, dtype: (201097, 11, 11), (201097, 11, 11), bool\n2025-09-20 23:37:38 - darr_info - INFO - ph for chunk 0 dask array shape, chunksize, dtype: (201097, 17), (201097, 17), complex64\n2025-09-20 23:37:38 - darr_info - INFO - emi_quality for chunk 0 dask array shape, chunksize, dtype: (201097,), (201097,), float32\n2025-09-20 23:37:38 - darr_info - INFO - t_coh for chunk 0 dask array shape, chunksize, dtype: (201097,), (201097,), float32\n2025-09-20 23:37:38 - emperical_co_emi_temp_coh_pc - INFO - saving ph, emi_quality, t_coh for chunk 0\n2025-09-20 23:37:38 - zarr_info - INFO - ds_processing/gix/ds_can_ph/0.zarr zarray shape, chunks, dtype: (201097, 17), (201097, 1), complex64\n2025-09-20 23:37:38 - zarr_info - INFO - ds_processing/gix/ds_can_emi_quality/0.zarr zarray shape, chunks, dtype: (201097,), (201097,), float32\n2025-09-20 23:37:38 - zarr_info - INFO - ds_processing/gix/ds_can_t_coh/0.zarr zarray shape, chunks, dtype: (201097,), (201097,), float32\n2025-09-20 23:37:38 - darr_info - INFO - is_shp for chunk 1 dask array shape, chunksize, dtype: (137562, 11, 11), (137562, 11, 11), bool\n2025-09-20 23:37:38 - darr_info - INFO - ph for chunk 1 dask array shape, chunksize, dtype: (137562, 17), (137562, 17), complex64\n2025-09-20 23:37:38 - darr_info - INFO - emi_quality for chunk 1 dask array shape, chunksize, dtype: (137562,), (137562,), float32\n2025-09-20 23:37:38 - darr_info - INFO - t_coh for chunk 1 dask array shape, chunksize, dtype: (137562,), (137562,), float32\n2025-09-20 23:37:38 - emperical_co_emi_temp_coh_pc - INFO - saving ph, emi_quality, t_coh for chunk 1\n2025-09-20 23:37:38 - zarr_info - INFO - ds_processing/gix/ds_can_ph/1.zarr zarray shape, chunks, dtype: (137562, 17), (137562, 1), complex64\n2025-09-20 23:37:38 - zarr_info - INFO - ds_processing/gix/ds_can_emi_quality/1.zarr zarray shape, chunks, dtype: (137562,), (137562,), float32\n2025-09-20 23:37:38 - zarr_info - INFO - ds_processing/gix/ds_can_t_coh/1.zarr zarray shape, chunks, dtype: (137562,), (137562,), float32\n2025-09-20 23:37:38 - darr_info - INFO - is_shp for chunk 2 dask array shape, chunksize, dtype: (201403, 11, 11), (201403, 11, 11), bool\n2025-09-20 23:37:38 - darr_info - INFO - ph for chunk 2 dask array shape, chunksize, dtype: (201403, 17), (201403, 17), complex64\n2025-09-20 23:37:38 - darr_info - INFO - emi_quality for chunk 2 dask array shape, chunksize, dtype: (201403,), (201403,), float32\n2025-09-20 23:37:38 - darr_info - INFO - t_coh for chunk 2 dask array shape, chunksize, dtype: (201403,), (201403,), float32\n2025-09-20 23:37:38 - emperical_co_emi_temp_coh_pc - INFO - saving ph, emi_quality, t_coh for chunk 2\n2025-09-20 23:37:38 - zarr_info - INFO - ds_processing/gix/ds_can_ph/2.zarr zarray shape, chunks, dtype: (201403, 17), (201403, 1), complex64\n2025-09-20 23:37:38 - zarr_info - INFO - ds_processing/gix/ds_can_emi_quality/2.zarr zarray shape, chunks, dtype: (201403,), (201403,), float32\n2025-09-20 23:37:38 - zarr_info - INFO - ds_processing/gix/ds_can_t_coh/2.zarr zarray shape, chunks, dtype: (201403,), (201403,), float32\n2025-09-20 23:37:38 - darr_info - INFO - is_shp for chunk 3 dask array shape, chunksize, dtype: (73518, 11, 11), (73518, 11, 11), bool\n2025-09-20 23:37:38 - darr_info - INFO - ph for chunk 3 dask array shape, chunksize, dtype: (73518, 17), (73518, 17), complex64\n2025-09-20 23:37:38 - darr_info - INFO - emi_quality for chunk 3 dask array shape, chunksize, dtype: (73518,), (73518,), float32\n2025-09-20 23:37:38 - darr_info - INFO - t_coh for chunk 3 dask array shape, chunksize, dtype: (73518,), (73518,), float32\n2025-09-20 23:37:38 - emperical_co_emi_temp_coh_pc - INFO - saving ph, emi_quality, t_coh for chunk 3\n2025-09-20 23:37:38 - zarr_info - INFO - ds_processing/gix/ds_can_ph/3.zarr zarray shape, chunks, dtype: (73518, 17), (73518, 1), complex64\n2025-09-20 23:37:38 - zarr_info - INFO - ds_processing/gix/ds_can_emi_quality/3.zarr zarray shape, chunks, dtype: (73518,), (73518,), float32\n2025-09-20 23:37:38 - zarr_info - INFO - ds_processing/gix/ds_can_t_coh/3.zarr zarray shape, chunks, dtype: (73518,), (73518,), float32\n2025-09-20 23:37:38 - darr_info - INFO - is_shp for chunk 4 dask array shape, chunksize, dtype: (78445, 11, 11), (78445, 11, 11), bool\n2025-09-20 23:37:38 - darr_info - INFO - ph for chunk 4 dask array shape, chunksize, dtype: (78445, 17), (78445, 17), complex64\n2025-09-20 23:37:38 - darr_info - INFO - emi_quality for chunk 4 dask array shape, chunksize, dtype: (78445,), (78445,), float32\n2025-09-20 23:37:38 - darr_info - INFO - t_coh for chunk 4 dask array shape, chunksize, dtype: (78445,), (78445,), float32\n2025-09-20 23:37:38 - emperical_co_emi_temp_coh_pc - INFO - saving ph, emi_quality, t_coh for chunk 4\n2025-09-20 23:37:38 - zarr_info - INFO - ds_processing/gix/ds_can_ph/4.zarr zarray shape, chunks, dtype: (78445, 17), (78445, 1), complex64\n2025-09-20 23:37:38 - zarr_info - INFO - ds_processing/gix/ds_can_emi_quality/4.zarr zarray shape, chunks, dtype: (78445,), (78445,), float32\n2025-09-20 23:37:38 - zarr_info - INFO - ds_processing/gix/ds_can_t_coh/4.zarr zarray shape, chunks, dtype: (78445,), (78445,), float32\n2025-09-20 23:37:38 - darr_info - INFO - is_shp for chunk 5 dask array shape, chunksize, dtype: (40702, 11, 11), (40702, 11, 11), bool\n2025-09-20 23:37:38 - darr_info - INFO - ph for chunk 5 dask array shape, chunksize, dtype: (40702, 17), (40702, 17), complex64\n2025-09-20 23:37:38 - darr_info - INFO - emi_quality for chunk 5 dask array shape, chunksize, dtype: (40702,), (40702,), float32\n2025-09-20 23:37:38 - darr_info - INFO - t_coh for chunk 5 dask array shape, chunksize, dtype: (40702,), (40702,), float32\n2025-09-20 23:37:38 - emperical_co_emi_temp_coh_pc - INFO - saving ph, emi_quality, t_coh for chunk 5\n2025-09-20 23:37:38 - zarr_info - INFO - ds_processing/gix/ds_can_ph/5.zarr zarray shape, chunks, dtype: (40702, 17), (40702, 1), complex64\n2025-09-20 23:37:38 - zarr_info - INFO - ds_processing/gix/ds_can_emi_quality/5.zarr zarray shape, chunks, dtype: (40702,), (40702,), float32\n2025-09-20 23:37:38 - zarr_info - INFO - ds_processing/gix/ds_can_t_coh/5.zarr zarray shape, chunks, dtype: (40702,), (40702,), float32\n2025-09-20 23:37:38 - emperical_co_emi_temp_coh_pc - INFO - computing graph setted. doing all the computing.\n2025-09-20 23:37:45 - emperical_co_emi_temp_coh_pc - INFO - computing finished.\n2025-09-20 23:37:47 - emperical_co_emi_temp_coh_pc - INFO - dask cluster closed.\n2025-09-20 23:37:47 - log_args - INFO - running function: pc_concat\n2025-09-20 23:37:47 - log_args - INFO - fetching args:\n2025-09-20 23:37:47 - log_args - INFO - pcs = ['./ds_processing/gix/ds_can_ph', './ds_processing/gix/ds_can_emi_quality', './ds_processing/gix/ds_can_t_coh']\n2025-09-20 23:37:47 - log_args - INFO - pc = ['./ds_processing/hix/ds_can/ds_can_ph.zarr', './ds_processing/hix/ds_can/ds_can_emi_quality.zarr', './ds_processing/hix/ds_can/ds_can_t_coh.zarr']\n2025-09-20 23:37:47 - log_args - INFO - key = ['./ds_processing/gix/ds_can_key.zarr', './ds_processing/gix/gix2hix.zarr']\n2025-09-20 23:37:47 - log_args - INFO - chunks = 200000\n2025-09-20 23:37:47 - log_args - INFO - processes = False\n2025-09-20 23:37:47 - log_args - INFO - n_workers = 1\n2025-09-20 23:37:47 - log_args - INFO - threads_per_worker = 1\n2025-09-20 23:37:47 - log_args - INFO - dask_cluster_arg = {}\n2025-09-20 23:37:47 - log_args - INFO - fetching args done.\n2025-09-20 23:37:47 - pc_concat - INFO - input pcs: [[PosixPath('ds_processing/gix/ds_can_ph/0.zarr'), PosixPath('ds_processing/gix/ds_can_ph/1.zarr'), PosixPath('ds_processing/gix/ds_can_ph/2.zarr'), PosixPath('ds_processing/gix/ds_can_ph/3.zarr'), PosixPath('ds_processing/gix/ds_can_ph/4.zarr'), PosixPath('ds_processing/gix/ds_can_ph/5.zarr')], [PosixPath('ds_processing/gix/ds_can_emi_quality/0.zarr'), PosixPath('ds_processing/gix/ds_can_emi_quality/1.zarr'), PosixPath('ds_processing/gix/ds_can_emi_quality/2.zarr'), PosixPath('ds_processing/gix/ds_can_emi_quality/3.zarr'), PosixPath('ds_processing/gix/ds_can_emi_quality/4.zarr'), PosixPath('ds_processing/gix/ds_can_emi_quality/5.zarr')], [PosixPath('ds_processing/gix/ds_can_t_coh/0.zarr'), PosixPath('ds_processing/gix/ds_can_t_coh/1.zarr'), PosixPath('ds_processing/gix/ds_can_t_coh/2.zarr'), PosixPath('ds_processing/gix/ds_can_t_coh/3.zarr'), PosixPath('ds_processing/gix/ds_can_t_coh/4.zarr'), PosixPath('ds_processing/gix/ds_can_t_coh/5.zarr')]]\n2025-09-20 23:37:47 - pc_concat - INFO - output pc: ['./ds_processing/hix/ds_can/ds_can_ph.zarr', './ds_processing/hix/ds_can/ds_can_emi_quality.zarr', './ds_processing/hix/ds_can/ds_can_t_coh.zarr']\n2025-09-20 23:37:47 - pc_concat - INFO - load key\n2025-09-20 23:37:47 - zarr_info - INFO - ./ds_processing/gix/ds_can_key.zarr zarray shape, chunks, dtype: (732727,), (200000,), int64\n2025-09-20 23:37:47 - zarr_info - INFO - ./ds_processing/gix/gix2hix.zarr zarray shape, chunks, dtype: (732727,), (200000,), int64\n2025-09-20 23:37:47 - pc_concat - INFO - starting dask local cluster.\n2025-09-20 23:37:47 - pc_concat - INFO - dask local cluster started.\n2025-09-20 23:37:47 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.10:8787/status', workers=1, threads=1, memory=1.95 TiB)\n2025-09-20 23:37:47 - pc_concat - INFO - read pc from [PosixPath('ds_processing/gix/ds_can_ph/0.zarr'), PosixPath('ds_processing/gix/ds_can_ph/1.zarr'), PosixPath('ds_processing/gix/ds_can_ph/2.zarr'), PosixPath('ds_processing/gix/ds_can_ph/3.zarr'), PosixPath('ds_processing/gix/ds_can_ph/4.zarr'), PosixPath('ds_processing/gix/ds_can_ph/5.zarr')]\n2025-09-20 23:37:47 - darr_info - INFO - concatenated pc dask array shape, chunksize, dtype: (732727, 17), (732727, 1), complex64\n2025-09-20 23:37:47 - pc_concat - INFO - sort pc according to key\n2025-09-20 23:37:47 - darr_info - INFO - sorted pc dask array shape, chunksize, dtype: (732727, 17), (732727, 1), complex64\n2025-09-20 23:37:47 - pc_concat - INFO - save pc to ./ds_processing/hix/ds_can/ds_can_ph.zarr\n2025-09-20 23:37:47 - zarr_info - INFO - ./ds_processing/hix/ds_can/ds_can_ph.zarr zarray shape, chunks, dtype: (732727, 17), (200000, 1), complex64\n2025-09-20 23:37:47 - pc_concat - INFO - read pc from [PosixPath('ds_processing/gix/ds_can_emi_quality/0.zarr'), PosixPath('ds_processing/gix/ds_can_emi_quality/1.zarr'), PosixPath('ds_processing/gix/ds_can_emi_quality/2.zarr'), PosixPath('ds_processing/gix/ds_can_emi_quality/3.zarr'), PosixPath('ds_processing/gix/ds_can_emi_quality/4.zarr'), PosixPath('ds_processing/gix/ds_can_emi_quality/5.zarr')]\n2025-09-20 23:37:47 - darr_info - INFO - concatenated pc dask array shape, chunksize, dtype: (732727,), (732727,), float32\n2025-09-20 23:37:47 - pc_concat - INFO - sort pc according to key\n2025-09-20 23:37:47 - darr_info - INFO - sorted pc dask array shape, chunksize, dtype: (732727,), (732727,), float32\n2025-09-20 23:37:47 - pc_concat - INFO - save pc to ./ds_processing/hix/ds_can/ds_can_emi_quality.zarr\n2025-09-20 23:37:47 - zarr_info - INFO - ./ds_processing/hix/ds_can/ds_can_emi_quality.zarr zarray shape, chunks, dtype: (732727,), (200000,), float32\n2025-09-20 23:37:47 - pc_concat - INFO - read pc from [PosixPath('ds_processing/gix/ds_can_t_coh/0.zarr'), PosixPath('ds_processing/gix/ds_can_t_coh/1.zarr'), PosixPath('ds_processing/gix/ds_can_t_coh/2.zarr'), PosixPath('ds_processing/gix/ds_can_t_coh/3.zarr'), PosixPath('ds_processing/gix/ds_can_t_coh/4.zarr'), PosixPath('ds_processing/gix/ds_can_t_coh/5.zarr')]\n2025-09-20 23:37:47 - darr_info - INFO - concatenated pc dask array shape, chunksize, dtype: (732727,), (732727,), float32\n2025-09-20 23:37:47 - pc_concat - INFO - sort pc according to key\n2025-09-20 23:37:47 - darr_info - INFO - sorted pc dask array shape, chunksize, dtype: (732727,), (732727,), float32\n2025-09-20 23:37:47 - pc_concat - INFO - save pc to ./ds_processing/hix/ds_can/ds_can_t_coh.zarr\n2025-09-20 23:37:47 - zarr_info - INFO - ./ds_processing/hix/ds_can/ds_can_t_coh.zarr zarray shape, chunks, dtype: (732727,), (200000,), float32\n2025-09-20 23:37:47 - pc_concat - INFO - computing graph setted. doing all the computing.\n2025-09-20 23:37:48 - pc_concat - INFO - computing finished.|  0.9s\n2025-09-20 23:37:48 - pc_concat - INFO - dask cluster closed.",
    "crumbs": [
      "Tutorials",
      "CLI",
      "DS Processing"
    ]
  },
  {
    "objectID": "Tutorials/CLI/ds_processing.html#ds-candidiates-refinement",
    "href": "Tutorials/CLI/ds_processing.html#ds-candidiates-refinement",
    "title": "DS Processing",
    "section": "DS candidiates refinement",
    "text": "DS candidiates refinement\nThen, we refine the ds candidate using EMI quality factor and the temporal coherence:\n\nds_can_r1_hix = './ds_processing/hix/ds_can/ds_can_r1_hix.zarr'\nmc.pc_logic_pc(ds_can_hix, ds_can_emi_quality,ds_can_r1_hix,'(pc_in&gt;=1.0)&(pc_in&lt;=1.05)')\n\n2025-09-20 23:40:34 - log_args - INFO - running function: pc_logic_pc\n2025-09-20 23:40:34 - log_args - INFO - fetching args:\n2025-09-20 23:40:34 - log_args - INFO - idx_in = './ds_processing/hix/ds_can/ds_can_hix.zarr'\n2025-09-20 23:40:34 - log_args - INFO - pc_in = './ds_processing/hix/ds_can/ds_can_emi_quality.zarr'\n2025-09-20 23:40:34 - log_args - INFO - idx = './ds_processing/hix/ds_can/ds_can_r1_hix.zarr'\n2025-09-20 23:40:34 - log_args - INFO - operation = '(pc_in&gt;=1.0)&(pc_in&lt;=1.05)'\n2025-09-20 23:40:34 - log_args - INFO - chunks = None\n2025-09-20 23:40:34 - log_args - INFO - fetching args done.\n2025-09-20 23:40:34 - zarr_info - INFO - ./ds_processing/hix/ds_can/ds_can_hix.zarr zarray shape, chunks, dtype: (732727,), (200000,), int64\n2025-09-20 23:40:34 - zarr_info - INFO - ./ds_processing/hix/ds_can/ds_can_emi_quality.zarr zarray shape, chunks, dtype: (732727,), (200000,), float32\n2025-09-20 23:40:34 - pc_logic_pc - INFO - loading idx_in into memory.\n2025-09-20 23:40:34 - pc_logic_pc - INFO - loading pc_in into memory.\n2025-09-20 23:40:34 - pc_logic_pc - INFO - select pc based on operation: (pc_in&gt;=1.0)&(pc_in&lt;=1.05)\n2025-09-20 23:40:34 - pc_logic_pc - INFO - number of selected pixels: 404013.\n2025-09-20 23:40:34 - zarr_info - INFO - idx zarray shape, chunks, dtype: (404013,), (200000,), int64\n2025-09-20 23:40:34 - pc_logic_pc - INFO - writing idx.\n2025-09-20 23:40:34 - pc_logic_pc - INFO - write done.\n\n\n\nds_can_r2_hix = './ds_processing/hix/ds_can/ds_can_r2_hix.zarr'\nmc.pc_logic_pc(ds_can_hix, ds_can_t_coh,ds_can_r2_hix,'(pc_in&gt;=0.8)&(pc_in&lt;=1.0)')\n\n2025-09-20 23:40:35 - log_args - INFO - running function: pc_logic_pc\n2025-09-20 23:40:35 - log_args - INFO - fetching args:\n2025-09-20 23:40:35 - log_args - INFO - idx_in = './ds_processing/hix/ds_can/ds_can_hix.zarr'\n2025-09-20 23:40:35 - log_args - INFO - pc_in = './ds_processing/hix/ds_can/ds_can_t_coh.zarr'\n2025-09-20 23:40:35 - log_args - INFO - idx = './ds_processing/hix/ds_can/ds_can_r2_hix.zarr'\n2025-09-20 23:40:35 - log_args - INFO - operation = '(pc_in&gt;=0.8)&(pc_in&lt;=1.0)'\n2025-09-20 23:40:35 - log_args - INFO - chunks = None\n2025-09-20 23:40:35 - log_args - INFO - fetching args done.\n2025-09-20 23:40:35 - zarr_info - INFO - ./ds_processing/hix/ds_can/ds_can_hix.zarr zarray shape, chunks, dtype: (732727,), (200000,), int64\n2025-09-20 23:40:35 - zarr_info - INFO - ./ds_processing/hix/ds_can/ds_can_t_coh.zarr zarray shape, chunks, dtype: (732727,), (200000,), float32\n2025-09-20 23:40:35 - pc_logic_pc - INFO - loading idx_in into memory.\n2025-09-20 23:40:35 - pc_logic_pc - INFO - loading pc_in into memory.\n2025-09-20 23:40:35 - pc_logic_pc - INFO - select pc based on operation: (pc_in&gt;=0.8)&(pc_in&lt;=1.0)\n2025-09-20 23:40:35 - pc_logic_pc - INFO - number of selected pixels: 381992.\n2025-09-20 23:40:35 - zarr_info - INFO - idx zarray shape, chunks, dtype: (381992,), (200000,), int64\n2025-09-20 23:40:35 - pc_logic_pc - INFO - writing idx.\n2025-09-20 23:40:35 - pc_logic_pc - INFO - write done.\n\n\nGet their intersection:\n\n\n\n\n\n\nNote\n\n\n\nNote that pc_union can be applied if the coherence is not good and no much pixels selected.\n\n\n\nds_hix = './ds_processing/hix/ds/ds_hix.zarr'\n\n\nmc.pc_intersect(ds_can_r1_hix,ds_can_r2_hix,ds_hix)\n\n2025-09-20 23:40:38 - log_args - INFO - running function: pc_intersect\n2025-09-20 23:40:38 - log_args - INFO - fetching args:\n2025-09-20 23:40:38 - log_args - INFO - idx1 = './ds_processing/hix/ds_can/ds_can_r1_hix.zarr'\n2025-09-20 23:40:38 - log_args - INFO - idx2 = './ds_processing/hix/ds_can/ds_can_r2_hix.zarr'\n2025-09-20 23:40:38 - log_args - INFO - idx = './ds_processing/hix/ds/ds_hix.zarr'\n2025-09-20 23:40:38 - log_args - INFO - pc1 = None\n2025-09-20 23:40:38 - log_args - INFO - pc2 = None\n2025-09-20 23:40:38 - log_args - INFO - pc = None\n2025-09-20 23:40:38 - log_args - INFO - shape = None\n2025-09-20 23:40:38 - log_args - INFO - chunks = None\n2025-09-20 23:40:38 - log_args - INFO - prefer_1 = True\n2025-09-20 23:40:38 - log_args - INFO - processes = False\n2025-09-20 23:40:38 - log_args - INFO - n_workers = 1\n2025-09-20 23:40:38 - log_args - INFO - threads_per_worker = 1\n2025-09-20 23:40:38 - log_args - INFO - dask_cluster_arg = {}\n2025-09-20 23:40:38 - log_args - INFO - fetching args done.\n2025-09-20 23:40:38 - zarr_info - INFO - ./ds_processing/hix/ds_can/ds_can_r1_hix.zarr zarray shape, chunks, dtype: (404013,), (200000,), int64\n2025-09-20 23:40:38 - zarr_info - INFO - ./ds_processing/hix/ds_can/ds_can_r2_hix.zarr zarray shape, chunks, dtype: (381992,), (200000,), int64\n2025-09-20 23:40:38 - pc_intersect - INFO - loading idx1 and idx2 into memory.\n2025-09-20 23:40:38 - pc_intersect - INFO - calculate the intersection\n2025-09-20 23:40:38 - pc_intersect - INFO - number of points in the intersection: 293814\n2025-09-20 23:40:38 - pc_intersect - INFO - write intersect idx\n2025-09-20 23:40:38 - pc_intersect - INFO - write done\n2025-09-20 23:40:38 - zarr_info - INFO - ./ds_processing/hix/ds/ds_hix.zarr zarray shape, chunks, dtype: (293814,), (200000,), int64\n2025-09-20 23:40:38 - pc_intersect - INFO - no point cloud data provided, exit.",
    "crumbs": [
      "Tutorials",
      "CLI",
      "DS Processing"
    ]
  },
  {
    "objectID": "Tutorials/CLI/ds_processing.html#visualize-phase-linked-interferograms-at-refined-ds-points",
    "href": "Tutorials/CLI/ds_processing.html#visualize-phase-linked-interferograms-at-refined-ds-points",
    "title": "DS Processing",
    "section": "Visualize phase linked interferograms at refined ds points",
    "text": "Visualize phase linked interferograms at refined ds points\n\nds_coh = './ds_processing/hix/ds/ds_coh.zarr'\nds_ph = './ds_processing/hix/ds/ds_ph.zarr'\nds_gix = './ds_processing/hix/ds/ds_gix.zarr'\n\n\nmc.pc_select_data(\n    ds_can_hix,ds_hix,\n    pc_in=[ds_can_coh, ds_can_ph, './ds_processing/hix/ds_can/ds_can_gix.zarr/' ],\n    pc=[ds_coh,ds_ph, ds_gix],threads_per_worker=32)\n\n2025-09-20 23:40:42 - log_args - INFO - running function: pc_select_data\n2025-09-20 23:40:42 - log_args - INFO - fetching args:\n2025-09-20 23:40:42 - log_args - INFO - idx_in = './ds_processing/hix/ds_can/ds_can_hix.zarr'\n2025-09-20 23:40:42 - log_args - INFO - idx = './ds_processing/hix/ds/ds_hix.zarr'\n2025-09-20 23:40:42 - log_args - INFO - pc_in = ['./ds_processing/hix/ds_can/ds_can_coh.zarr', './ds_processing/hix/ds_can/ds_can_ph.zarr', './ds_processing/hix/ds_can/ds_can_gix.zarr/']\n2025-09-20 23:40:42 - log_args - INFO - pc = ['./ds_processing/hix/ds/ds_coh.zarr', './ds_processing/hix/ds/ds_ph.zarr', './ds_processing/hix/ds/ds_gix.zarr']\n2025-09-20 23:40:42 - log_args - INFO - shape = None\n2025-09-20 23:40:42 - log_args - INFO - chunks = None\n2025-09-20 23:40:42 - log_args - INFO - processes = False\n2025-09-20 23:40:42 - log_args - INFO - n_workers = 1\n2025-09-20 23:40:42 - log_args - INFO - threads_per_worker = 32\n2025-09-20 23:40:42 - log_args - INFO - dask_cluster_arg = {}\n2025-09-20 23:40:42 - log_args - INFO - fetching args done.\n2025-09-20 23:40:42 - zarr_info - INFO - ./ds_processing/hix/ds_can/ds_can_hix.zarr zarray shape, chunks, dtype: (732727,), (200000,), int64\n2025-09-20 23:40:42 - zarr_info - INFO - ./ds_processing/hix/ds/ds_hix.zarr zarray shape, chunks, dtype: (293814,), (200000,), int64\n2025-09-20 23:40:42 - pc_select_data - INFO - loading idx_in and idx into memory.\n2025-09-20 23:40:42 - pc_select_data - INFO - starting dask local cluster.\n2025-09-20 23:40:42 - pc_select_data - INFO - dask local cluster started.\n2025-09-20 23:40:42 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.10:8787/status', workers=1, threads=32, memory=1.95 TiB)\n2025-09-20 23:40:42 - zarr_info - INFO - ./ds_processing/hix/ds_can/ds_can_coh.zarr zarray shape, chunks, dtype: (732727, 136), (200000, 1), complex64\n2025-09-20 23:40:43 - darr_info - INFO - pc_in dask array shape, chunksize, dtype: (732727, 136), (732727, 1), complex64\n2025-09-20 23:40:43 - pc_select_data - INFO - set up selected pc data dask array.\n2025-09-20 23:40:43 - darr_info - INFO - pc dask array shape, chunksize, dtype: (293814, 136), (293814, 1), complex64\n2025-09-20 23:40:43 - pc_select_data - INFO - write pc to ./ds_processing/hix/ds/ds_coh.zarr\n2025-09-20 23:40:43 - zarr_info - INFO - ./ds_processing/hix/ds/ds_coh.zarr zarray shape, chunks, dtype: (293814, 136), (200000, 1), complex64\n2025-09-20 23:40:43 - zarr_info - INFO - ./ds_processing/hix/ds_can/ds_can_ph.zarr zarray shape, chunks, dtype: (732727, 17), (200000, 1), complex64\n2025-09-20 23:40:43 - darr_info - INFO - pc_in dask array shape, chunksize, dtype: (732727, 17), (732727, 1), complex64\n2025-09-20 23:40:43 - pc_select_data - INFO - set up selected pc data dask array.\n2025-09-20 23:40:43 - darr_info - INFO - pc dask array shape, chunksize, dtype: (293814, 17), (293814, 1), complex64\n2025-09-20 23:40:43 - pc_select_data - INFO - write pc to ./ds_processing/hix/ds/ds_ph.zarr\n2025-09-20 23:40:43 - zarr_info - INFO - ./ds_processing/hix/ds/ds_ph.zarr zarray shape, chunks, dtype: (293814, 17), (200000, 1), complex64\n2025-09-20 23:40:43 - zarr_info - INFO - ./ds_processing/hix/ds_can/ds_can_gix.zarr/ zarray shape, chunks, dtype: (732727, 2), (200000, 1), int32\n2025-09-20 23:40:43 - darr_info - INFO - pc_in dask array shape, chunksize, dtype: (732727, 2), (732727, 1), int32\n2025-09-20 23:40:43 - pc_select_data - INFO - set up selected pc data dask array.\n2025-09-20 23:40:43 - darr_info - INFO - pc dask array shape, chunksize, dtype: (293814, 2), (293814, 1), int32\n2025-09-20 23:40:43 - pc_select_data - INFO - write pc to ./ds_processing/hix/ds/ds_gix.zarr\n2025-09-20 23:40:43 - zarr_info - INFO - ./ds_processing/hix/ds/ds_gix.zarr zarray shape, chunks, dtype: (293814, 2), (200000, 1), int32\n2025-09-20 23:40:43 - pc_select_data - INFO - computing graph setted. doing all the computing.\n2025-09-20 23:40:46 - pc_select_data - INFO - computing finished.9s\n2025-09-20 23:40:46 - pc_select_data - INFO - dask cluster closed.\n\n\nThen plot them:\n\nmc.pc_pyramid(\n    './ds_processing/hix/ds/ds_coh.zarr',\n    './ds_processing/hix/ds/ds_coh_pyramid',\n    yx = './ds_processing/hix/ds/ds_gix.zarr',\n    ras_resolution=2,\n)\n\n2025-09-20 23:40:46 - log_args - INFO - running function: pc_pyramid\n2025-09-20 23:40:46 - log_args - INFO - fetching args:\n2025-09-20 23:40:46 - log_args - INFO - pc = './ds_processing/hix/ds/ds_coh.zarr'\n2025-09-20 23:40:46 - log_args - INFO - out_dir = './ds_processing/hix/ds/ds_coh_pyramid'\n2025-09-20 23:40:46 - log_args - INFO - x = None\n2025-09-20 23:40:46 - log_args - INFO - y = None\n2025-09-20 23:40:46 - log_args - INFO - yx = './ds_processing/hix/ds/ds_gix.zarr'\n2025-09-20 23:40:46 - log_args - INFO - ras_resolution = 2\n2025-09-20 23:40:46 - log_args - INFO - ras_chunks = (256, 256)\n2025-09-20 23:40:46 - log_args - INFO - pc_chunks = 65536\n2025-09-20 23:40:46 - log_args - INFO - processes = False\n2025-09-20 23:40:46 - log_args - INFO - n_workers = 1\n2025-09-20 23:40:46 - log_args - INFO - threads_per_worker = 2\n2025-09-20 23:40:46 - log_args - INFO - dask_cluster_arg = {}\n2025-09-20 23:40:46 - log_args - INFO - fetching args done.\n2025-09-20 23:40:46 - pc_pyramid - INFO - clean out dir\n2025-09-20 23:40:49 - zarr_info - INFO - ./ds_processing/hix/ds/ds_coh.zarr zarray shape, chunks, dtype: (293814, 136), (200000, 1), complex64\n2025-09-20 23:40:49 - pc_pyramid - INFO - rendering point cloud data coordinates:\n2025-09-20 23:40:49 - pc_pyramid - INFO - rasterizing point cloud data to grid with bounds: [np.int32(0), np.int32(0), np.int32(1832), np.int32(2498)].\n2025-09-20 23:40:49 - zarr_info - INFO - ds_processing/hix/ds/ds_coh_pyramid/x.zarr zarray shape, chunks, dtype: (293814,), (65536,), int32\n2025-09-20 23:40:49 - zarr_info - INFO - ds_processing/hix/ds/ds_coh_pyramid/y.zarr zarray shape, chunks, dtype: (293814,), (65536,), int32\n2025-09-20 23:40:49 - pc_pyramid - INFO - pc data coordinates rendering ends.\n2025-09-20 23:40:49 - zarr_info - INFO - ds_processing/hix/ds/ds_coh_pyramid/idx_0.zarr zarray shape, chunks, dtype: (1250, 917), (256, 256), int64\n2025-09-20 23:40:49 - zarr_info - INFO - ds_processing/hix/ds/ds_coh_pyramid/idx_1.zarr zarray shape, chunks, dtype: (625, 459), (256, 256), int64\n2025-09-20 23:40:49 - zarr_info - INFO - ds_processing/hix/ds/ds_coh_pyramid/idx_2.zarr zarray shape, chunks, dtype: (313, 230), (256, 256), int64\n2025-09-20 23:40:49 - zarr_info - INFO - ds_processing/hix/ds/ds_coh_pyramid/idx_3.zarr zarray shape, chunks, dtype: (157, 115), (256, 256), int64\n2025-09-20 23:40:49 - zarr_info - INFO - ds_processing/hix/ds/ds_coh_pyramid/idx_4.zarr zarray shape, chunks, dtype: (79, 58), (256, 256), int64\n2025-09-20 23:40:49 - zarr_info - INFO - ds_processing/hix/ds/ds_coh_pyramid/idx_5.zarr zarray shape, chunks, dtype: (40, 29), (256, 256), int64\n2025-09-20 23:40:49 - zarr_info - INFO - ds_processing/hix/ds/ds_coh_pyramid/idx_6.zarr zarray shape, chunks, dtype: (20, 15), (256, 256), int64\n2025-09-20 23:40:49 - zarr_info - INFO - ds_processing/hix/ds/ds_coh_pyramid/idx_7.zarr zarray shape, chunks, dtype: (10, 8), (256, 256), int64\n2025-09-20 23:40:49 - zarr_info - INFO - ds_processing/hix/ds/ds_coh_pyramid/idx_8.zarr zarray shape, chunks, dtype: (5, 4), (256, 256), int64\n2025-09-20 23:40:49 - zarr_info - INFO - ds_processing/hix/ds/ds_coh_pyramid/idx_9.zarr zarray shape, chunks, dtype: (3, 2), (256, 256), int64\n2025-09-20 23:40:49 - pc_pyramid - INFO - rasterized idx rendering ends\n2025-09-20 23:40:49 - pc_pyramid - INFO - dask local cluster started to render pc data.\n2025-09-20 23:40:49 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.10:8787/status', workers=1, threads=2, memory=1.95 TiB)\n2025-09-20 23:40:50 - zarr_info - INFO - ds_processing/hix/ds/ds_coh_pyramid/pc.zarr zarray shape, chunks, dtype: (293814, 136), (65536, 1), complex64\n2025-09-20 23:40:50 - zarr_info - INFO - ds_processing/hix/ds/ds_coh_pyramid/0.zarr zarray shape, chunks, dtype: (1250, 917, 136), (256, 256, 1), complex64\n2025-09-20 23:40:50 - zarr_info - INFO - ds_processing/hix/ds/ds_coh_pyramid/1.zarr zarray shape, chunks, dtype: (625, 459, 136), (256, 256, 1), complex64\n2025-09-20 23:40:50 - zarr_info - INFO - ds_processing/hix/ds/ds_coh_pyramid/2.zarr zarray shape, chunks, dtype: (313, 230, 136), (256, 256, 1), complex64\n2025-09-20 23:40:50 - zarr_info - INFO - ds_processing/hix/ds/ds_coh_pyramid/3.zarr zarray shape, chunks, dtype: (157, 115, 136), (256, 256, 1), complex64\n2025-09-20 23:40:50 - zarr_info - INFO - ds_processing/hix/ds/ds_coh_pyramid/4.zarr zarray shape, chunks, dtype: (79, 58, 136), (256, 256, 1), complex64\n2025-09-20 23:40:50 - zarr_info - INFO - ds_processing/hix/ds/ds_coh_pyramid/5.zarr zarray shape, chunks, dtype: (40, 29, 136), (256, 256, 1), complex64\n2025-09-20 23:40:50 - zarr_info - INFO - ds_processing/hix/ds/ds_coh_pyramid/6.zarr zarray shape, chunks, dtype: (20, 15, 136), (256, 256, 1), complex64\n2025-09-20 23:40:50 - zarr_info - INFO - ds_processing/hix/ds/ds_coh_pyramid/7.zarr zarray shape, chunks, dtype: (10, 8, 136), (256, 256, 1), complex64\n2025-09-20 23:40:50 - zarr_info - INFO - ds_processing/hix/ds/ds_coh_pyramid/8.zarr zarray shape, chunks, dtype: (5, 4, 136), (256, 256, 1), complex64\n2025-09-20 23:40:50 - zarr_info - INFO - ds_processing/hix/ds/ds_coh_pyramid/9.zarr zarray shape, chunks, dtype: (3, 2, 136), (256, 256, 1), complex64\n2025-09-20 23:40:51 - pc_pyramid - INFO - computing graph setted. doing all the computing.\n2025-09-20 23:41:04 - pc_pyramid - INFO - computing finished. 12.9s\n2025-09-20 23:41:04 - pc_pyramid - INFO - dask cluster closed.\n\n\n\nmc.pc_pyramid(\n    './ds_processing/hix/ds/ds_ph.zarr',\n    './ds_processing/hix/ds/ds_ph_pyramid',\n    yx = './ds_processing/hix/ds/ds_gix.zarr',\n    ras_resolution=2,\n)\n\n2025-09-20 23:41:04 - log_args - INFO - running function: pc_pyramid\n2025-09-20 23:41:04 - log_args - INFO - fetching args:\n2025-09-20 23:41:04 - log_args - INFO - pc = './ds_processing/hix/ds/ds_ph.zarr'\n2025-09-20 23:41:04 - log_args - INFO - out_dir = './ds_processing/hix/ds/ds_ph_pyramid'\n2025-09-20 23:41:04 - log_args - INFO - x = None\n2025-09-20 23:41:04 - log_args - INFO - y = None\n2025-09-20 23:41:04 - log_args - INFO - yx = './ds_processing/hix/ds/ds_gix.zarr'\n2025-09-20 23:41:04 - log_args - INFO - ras_resolution = 2\n2025-09-20 23:41:04 - log_args - INFO - ras_chunks = (256, 256)\n2025-09-20 23:41:04 - log_args - INFO - pc_chunks = 65536\n2025-09-20 23:41:04 - log_args - INFO - processes = False\n2025-09-20 23:41:04 - log_args - INFO - n_workers = 1\n2025-09-20 23:41:04 - log_args - INFO - threads_per_worker = 2\n2025-09-20 23:41:04 - log_args - INFO - dask_cluster_arg = {}\n2025-09-20 23:41:04 - log_args - INFO - fetching args done.\n2025-09-20 23:41:04 - pc_pyramid - INFO - clean out dir\n2025-09-20 23:41:05 - zarr_info - INFO - ./ds_processing/hix/ds/ds_ph.zarr zarray shape, chunks, dtype: (293814, 17), (200000, 1), complex64\n2025-09-20 23:41:05 - pc_pyramid - INFO - rendering point cloud data coordinates:\n2025-09-20 23:41:05 - pc_pyramid - INFO - rasterizing point cloud data to grid with bounds: [np.int32(0), np.int32(0), np.int32(1832), np.int32(2498)].\n2025-09-20 23:41:05 - zarr_info - INFO - ds_processing/hix/ds/ds_ph_pyramid/x.zarr zarray shape, chunks, dtype: (293814,), (65536,), int32\n2025-09-20 23:41:05 - zarr_info - INFO - ds_processing/hix/ds/ds_ph_pyramid/y.zarr zarray shape, chunks, dtype: (293814,), (65536,), int32\n2025-09-20 23:41:05 - pc_pyramid - INFO - pc data coordinates rendering ends.\n2025-09-20 23:41:05 - zarr_info - INFO - ds_processing/hix/ds/ds_ph_pyramid/idx_0.zarr zarray shape, chunks, dtype: (1250, 917), (256, 256), int64\n2025-09-20 23:41:05 - zarr_info - INFO - ds_processing/hix/ds/ds_ph_pyramid/idx_1.zarr zarray shape, chunks, dtype: (625, 459), (256, 256), int64\n2025-09-20 23:41:05 - zarr_info - INFO - ds_processing/hix/ds/ds_ph_pyramid/idx_2.zarr zarray shape, chunks, dtype: (313, 230), (256, 256), int64\n2025-09-20 23:41:05 - zarr_info - INFO - ds_processing/hix/ds/ds_ph_pyramid/idx_3.zarr zarray shape, chunks, dtype: (157, 115), (256, 256), int64\n2025-09-20 23:41:05 - zarr_info - INFO - ds_processing/hix/ds/ds_ph_pyramid/idx_4.zarr zarray shape, chunks, dtype: (79, 58), (256, 256), int64\n2025-09-20 23:41:05 - zarr_info - INFO - ds_processing/hix/ds/ds_ph_pyramid/idx_5.zarr zarray shape, chunks, dtype: (40, 29), (256, 256), int64\n2025-09-20 23:41:05 - zarr_info - INFO - ds_processing/hix/ds/ds_ph_pyramid/idx_6.zarr zarray shape, chunks, dtype: (20, 15), (256, 256), int64\n2025-09-20 23:41:05 - zarr_info - INFO - ds_processing/hix/ds/ds_ph_pyramid/idx_7.zarr zarray shape, chunks, dtype: (10, 8), (256, 256), int64\n2025-09-20 23:41:05 - zarr_info - INFO - ds_processing/hix/ds/ds_ph_pyramid/idx_8.zarr zarray shape, chunks, dtype: (5, 4), (256, 256), int64\n2025-09-20 23:41:05 - zarr_info - INFO - ds_processing/hix/ds/ds_ph_pyramid/idx_9.zarr zarray shape, chunks, dtype: (3, 2), (256, 256), int64\n2025-09-20 23:41:05 - pc_pyramid - INFO - rasterized idx rendering ends\n2025-09-20 23:41:05 - pc_pyramid - INFO - dask local cluster started to render pc data.\n2025-09-20 23:41:05 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.10:8787/status', workers=1, threads=2, memory=1.95 TiB)\n2025-09-20 23:41:05 - zarr_info - INFO - ds_processing/hix/ds/ds_ph_pyramid/pc.zarr zarray shape, chunks, dtype: (293814, 17), (65536, 1), complex64\n2025-09-20 23:41:05 - zarr_info - INFO - ds_processing/hix/ds/ds_ph_pyramid/0.zarr zarray shape, chunks, dtype: (1250, 917, 17), (256, 256, 1), complex64\n2025-09-20 23:41:05 - zarr_info - INFO - ds_processing/hix/ds/ds_ph_pyramid/1.zarr zarray shape, chunks, dtype: (625, 459, 17), (256, 256, 1), complex64\n2025-09-20 23:41:05 - zarr_info - INFO - ds_processing/hix/ds/ds_ph_pyramid/2.zarr zarray shape, chunks, dtype: (313, 230, 17), (256, 256, 1), complex64\n2025-09-20 23:41:05 - zarr_info - INFO - ds_processing/hix/ds/ds_ph_pyramid/3.zarr zarray shape, chunks, dtype: (157, 115, 17), (256, 256, 1), complex64\n2025-09-20 23:41:05 - zarr_info - INFO - ds_processing/hix/ds/ds_ph_pyramid/4.zarr zarray shape, chunks, dtype: (79, 58, 17), (256, 256, 1), complex64\n2025-09-20 23:41:05 - zarr_info - INFO - ds_processing/hix/ds/ds_ph_pyramid/5.zarr zarray shape, chunks, dtype: (40, 29, 17), (256, 256, 1), complex64\n2025-09-20 23:41:05 - zarr_info - INFO - ds_processing/hix/ds/ds_ph_pyramid/6.zarr zarray shape, chunks, dtype: (20, 15, 17), (256, 256, 1), complex64\n2025-09-20 23:41:05 - zarr_info - INFO - ds_processing/hix/ds/ds_ph_pyramid/7.zarr zarray shape, chunks, dtype: (10, 8, 17), (256, 256, 1), complex64\n2025-09-20 23:41:05 - zarr_info - INFO - ds_processing/hix/ds/ds_ph_pyramid/8.zarr zarray shape, chunks, dtype: (5, 4, 17), (256, 256, 1), complex64\n2025-09-20 23:41:05 - zarr_info - INFO - ds_processing/hix/ds/ds_ph_pyramid/9.zarr zarray shape, chunks, dtype: (3, 2, 17), (256, 256, 1), complex64\n2025-09-20 23:41:06 - pc_pyramid - INFO - computing graph setted. doing all the computing.\n2025-09-20 23:41:07 - pc_pyramid - INFO - computing finished.  1.4s\n2025-09-20 23:41:07 - pc_pyramid - INFO - dask cluster closed.\n\n\n\nds_intf_plot = mc.pc_plot(\n    './ds_processing/hix/ds/ds_coh_pyramid',\n    post_proc_ras=co_phase_post_proc_ras,\n    post_proc_pc=co_phase_post_proc_pc,\n    n_kdim=2,\n    level_increase=0)\nraw_intf_plot = mc.ras_plot('./load_data/rslc_pyramid',post_proc='intf_all',n_kdim=2,level_increase=0)\nds_pl_intf_plot = mc.pc_plot('./ds_processing/hix/ds/ds_ph_pyramid',post_proc_ras='intf_all', post_proc_pc='intf_all',level_increase=0)\nds_intf_plots = raw_intf_plot.relabel('Raw Interferograms') + \\\nds_intf_plot.relabel('Adaptively multilooked Interferograms') + \\\nds_pl_intf_plot.relabel('Phase linked Interferograms')\n\n\nds_intf_plots = ds_intf_plots.redim(\n    i=hv.Dimension('i', label='Reference Image', range=(0,16), value_format=(lambda i: dates[i])),\n    j=hv.Dimension('j', label='Secondary Image', range=(0,16), value_format=(lambda i: dates[i])),\n    x=hv.Dimension('r', label='Range'),\n    y=hv.Dimension('az',label='Azimuth'),\n    z=hv.Dimension('Phase',range=(-np.pi,np.pi))\n)\n\n\nds_intf_plots.opts(\n    hv.opts.Image(\n        cmap='colorwheel',frame_width=400, frame_height=500, colorbar=True,\n        default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],\n        active_tools=['wheel_zoom'],\n        invert_yaxis=True,\n    ),\n    hv.opts.Points(\n        color='Phase', cmap='colorwheel',frame_width=400, frame_height=500, colorbar=True,\n        default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],\n        active_tools=['wheel_zoom'],\n        invert_yaxis=True,\n    ),\n)",
    "crumbs": [
      "Tutorials",
      "CLI",
      "DS Processing"
    ]
  },
  {
    "objectID": "Tutorials/CLI/ds_processing.html#visualize-phase-linked-interferograms-at-refined-ds-points-in-earth-coordinates",
    "href": "Tutorials/CLI/ds_processing.html#visualize-phase-linked-interferograms-at-refined-ds-points-in-earth-coordinates",
    "title": "DS Processing",
    "section": "Visualize phase linked interferograms at refined ds points in earth coordinates",
    "text": "Visualize phase linked interferograms at refined ds points in earth coordinates\nGet the needed data for ds:\n\nds_ph = './ds_processing/hix/ds/ds_ph.zarr'\nds_e = './ds_processing/hix/ds/ds_e.zarr'\nds_n = './ds_processing/hix/ds/ds_n.zarr'\n\n\nmc.ras2pc(ds_hix,\n          ras=['./load_data/e.zarr/','./load_data/n.zarr/'],\n          pc=[ds_e, ds_n],)\n\n2025-09-20 23:41:16 - log_args - INFO - running function: ras2pc\n2025-09-20 23:41:16 - log_args - INFO - fetching args:\n2025-09-20 23:41:16 - log_args - INFO - idx = './ds_processing/hix/ds/ds_hix.zarr'\n2025-09-20 23:41:16 - log_args - INFO - ras = ['./load_data/e.zarr/', './load_data/n.zarr/']\n2025-09-20 23:41:16 - log_args - INFO - pc = ['./ds_processing/hix/ds/ds_e.zarr', './ds_processing/hix/ds/ds_n.zarr']\n2025-09-20 23:41:16 - log_args - INFO - chunks = None\n2025-09-20 23:41:16 - log_args - INFO - processes = False\n2025-09-20 23:41:16 - log_args - INFO - n_workers = 1\n2025-09-20 23:41:16 - log_args - INFO - threads_per_worker = 1\n2025-09-20 23:41:16 - log_args - INFO - dask_cluster_arg = {}\n2025-09-20 23:41:16 - log_args - INFO - fetching args done.\n2025-09-20 23:41:16 - zarr_info - INFO - ./ds_processing/hix/ds/ds_hix.zarr zarray shape, chunks, dtype: (293814,), (200000,), int64\n2025-09-20 23:41:16 - ras2pc - INFO - loading hix into memory and convert to gix\n2025-09-20 23:41:16 - ras2pc - INFO - starting dask local cluster.\n2025-09-20 23:41:16 - ras2pc - INFO - dask local cluster started.\n2025-09-20 23:41:16 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.10:8787/status', workers=1, threads=1, memory=1.95 TiB)\n2025-09-20 23:41:16 - ras2pc - INFO - start to slice on ./load_data/e.zarr/\n2025-09-20 23:41:16 - zarr_info - INFO - ./load_data/e.zarr/ zarray shape, chunks, dtype: (2500, 1834), (1000, 1000), float64\n2025-09-20 23:41:16 - darr_info - INFO - ras dask array shape, chunksize, dtype: (2500, 1834), (2500, 1834), float64\n2025-09-20 23:41:16 - darr_info - INFO - pc dask array shape, chunksize, dtype: (293814,), (293814,), float64\n2025-09-20 23:41:16 - ras2pc - INFO - saving to ./ds_processing/hix/ds/ds_e.zarr.\n2025-09-20 23:41:16 - zarr_info - INFO - ./ds_processing/hix/ds/ds_e.zarr zarray shape, chunks, dtype: (293814,), (200000,), float64\n2025-09-20 23:41:16 - ras2pc - INFO - start to slice on ./load_data/n.zarr/\n2025-09-20 23:41:16 - zarr_info - INFO - ./load_data/n.zarr/ zarray shape, chunks, dtype: (2500, 1834), (1000, 1000), float64\n2025-09-20 23:41:16 - darr_info - INFO - ras dask array shape, chunksize, dtype: (2500, 1834), (2500, 1834), float64\n2025-09-20 23:41:16 - darr_info - INFO - pc dask array shape, chunksize, dtype: (293814,), (293814,), float64\n2025-09-20 23:41:16 - ras2pc - INFO - saving to ./ds_processing/hix/ds/ds_n.zarr.\n2025-09-20 23:41:16 - zarr_info - INFO - ./ds_processing/hix/ds/ds_n.zarr zarray shape, chunks, dtype: (293814,), (200000,), float64\n2025-09-20 23:41:16 - ras2pc - INFO - computing graph setted. doing all the computing.\n2025-09-20 23:41:16 - ras2pc - INFO - computing finished.ed |  0.2s\n2025-09-20 23:41:16 - ras2pc - INFO - dask cluster closed.\n\n\n\nmc.pc_pyramid(\n    './ds_processing/hix/ds/ds_ph.zarr',\n    './ds_processing/hix/ds/ds_ph_geo_pyramid',\n    x = ds_e,\n    y = ds_n,\n    ras_resolution=20,\n)\n\n2025-09-20 23:41:16 - log_args - INFO - running function: pc_pyramid\n2025-09-20 23:41:16 - log_args - INFO - fetching args:\n2025-09-20 23:41:16 - log_args - INFO - pc = './ds_processing/hix/ds/ds_ph.zarr'\n2025-09-20 23:41:16 - log_args - INFO - out_dir = './ds_processing/hix/ds/ds_ph_geo_pyramid'\n2025-09-20 23:41:16 - log_args - INFO - x = './ds_processing/hix/ds/ds_e.zarr'\n2025-09-20 23:41:16 - log_args - INFO - y = './ds_processing/hix/ds/ds_n.zarr'\n2025-09-20 23:41:16 - log_args - INFO - yx = None\n2025-09-20 23:41:16 - log_args - INFO - ras_resolution = 20\n2025-09-20 23:41:16 - log_args - INFO - ras_chunks = (256, 256)\n2025-09-20 23:41:16 - log_args - INFO - pc_chunks = 65536\n2025-09-20 23:41:16 - log_args - INFO - processes = False\n2025-09-20 23:41:16 - log_args - INFO - n_workers = 1\n2025-09-20 23:41:16 - log_args - INFO - threads_per_worker = 2\n2025-09-20 23:41:16 - log_args - INFO - dask_cluster_arg = {}\n2025-09-20 23:41:16 - log_args - INFO - fetching args done.\n2025-09-20 23:41:16 - pc_pyramid - INFO - clean out dir\n2025-09-20 23:41:17 - zarr_info - INFO - ./ds_processing/hix/ds/ds_ph.zarr zarray shape, chunks, dtype: (293814, 17), (200000, 1), complex64\n2025-09-20 23:41:17 - pc_pyramid - INFO - rendering point cloud data coordinates:\n2025-09-20 23:41:17 - pc_pyramid - INFO - rasterizing point cloud data to grid with bounds: [np.float64(-16498471.798140068), np.float64(8649651.33657227), np.float64(-16470131.798140068), np.float64(8674811.33657227)].\n2025-09-20 23:41:17 - zarr_info - INFO - ds_processing/hix/ds/ds_ph_geo_pyramid/x.zarr zarray shape, chunks, dtype: (293814,), (65536,), float64\n2025-09-20 23:41:17 - zarr_info - INFO - ds_processing/hix/ds/ds_ph_geo_pyramid/y.zarr zarray shape, chunks, dtype: (293814,), (65536,), float64\n2025-09-20 23:41:18 - pc_pyramid - INFO - pc data coordinates rendering ends.\n2025-09-20 23:41:18 - zarr_info - INFO - ds_processing/hix/ds/ds_ph_geo_pyramid/idx_0.zarr zarray shape, chunks, dtype: (1259, 1418), (256, 256), int64\n2025-09-20 23:41:18 - zarr_info - INFO - ds_processing/hix/ds/ds_ph_geo_pyramid/idx_1.zarr zarray shape, chunks, dtype: (630, 709), (256, 256), int64\n2025-09-20 23:41:18 - zarr_info - INFO - ds_processing/hix/ds/ds_ph_geo_pyramid/idx_2.zarr zarray shape, chunks, dtype: (315, 355), (256, 256), int64\n2025-09-20 23:41:18 - zarr_info - INFO - ds_processing/hix/ds/ds_ph_geo_pyramid/idx_3.zarr zarray shape, chunks, dtype: (158, 178), (256, 256), int64\n2025-09-20 23:41:18 - zarr_info - INFO - ds_processing/hix/ds/ds_ph_geo_pyramid/idx_4.zarr zarray shape, chunks, dtype: (79, 89), (256, 256), int64\n2025-09-20 23:41:18 - zarr_info - INFO - ds_processing/hix/ds/ds_ph_geo_pyramid/idx_5.zarr zarray shape, chunks, dtype: (40, 45), (256, 256), int64\n2025-09-20 23:41:18 - zarr_info - INFO - ds_processing/hix/ds/ds_ph_geo_pyramid/idx_6.zarr zarray shape, chunks, dtype: (20, 23), (256, 256), int64\n2025-09-20 23:41:18 - zarr_info - INFO - ds_processing/hix/ds/ds_ph_geo_pyramid/idx_7.zarr zarray shape, chunks, dtype: (10, 12), (256, 256), int64\n2025-09-20 23:41:18 - zarr_info - INFO - ds_processing/hix/ds/ds_ph_geo_pyramid/idx_8.zarr zarray shape, chunks, dtype: (5, 6), (256, 256), int64\n2025-09-20 23:41:18 - zarr_info - INFO - ds_processing/hix/ds/ds_ph_geo_pyramid/idx_9.zarr zarray shape, chunks, dtype: (3, 3), (256, 256), int64\n2025-09-20 23:41:18 - zarr_info - INFO - ds_processing/hix/ds/ds_ph_geo_pyramid/idx_10.zarr zarray shape, chunks, dtype: (2, 2), (256, 256), int64\n2025-09-20 23:41:18 - pc_pyramid - INFO - rasterized idx rendering ends\n2025-09-20 23:41:18 - pc_pyramid - INFO - dask local cluster started to render pc data.\n2025-09-20 23:41:18 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.10:8787/status', workers=1, threads=2, memory=1.95 TiB)\n2025-09-20 23:41:18 - zarr_info - INFO - ds_processing/hix/ds/ds_ph_geo_pyramid/pc.zarr zarray shape, chunks, dtype: (293814, 17), (65536, 1), complex64\n2025-09-20 23:41:18 - zarr_info - INFO - ds_processing/hix/ds/ds_ph_geo_pyramid/0.zarr zarray shape, chunks, dtype: (1259, 1418, 17), (256, 256, 1), complex64\n2025-09-20 23:41:18 - zarr_info - INFO - ds_processing/hix/ds/ds_ph_geo_pyramid/1.zarr zarray shape, chunks, dtype: (630, 709, 17), (256, 256, 1), complex64\n2025-09-20 23:41:18 - zarr_info - INFO - ds_processing/hix/ds/ds_ph_geo_pyramid/2.zarr zarray shape, chunks, dtype: (315, 355, 17), (256, 256, 1), complex64\n2025-09-20 23:41:18 - zarr_info - INFO - ds_processing/hix/ds/ds_ph_geo_pyramid/3.zarr zarray shape, chunks, dtype: (158, 178, 17), (256, 256, 1), complex64\n2025-09-20 23:41:18 - zarr_info - INFO - ds_processing/hix/ds/ds_ph_geo_pyramid/4.zarr zarray shape, chunks, dtype: (79, 89, 17), (256, 256, 1), complex64\n2025-09-20 23:41:18 - zarr_info - INFO - ds_processing/hix/ds/ds_ph_geo_pyramid/5.zarr zarray shape, chunks, dtype: (40, 45, 17), (256, 256, 1), complex64\n2025-09-20 23:41:18 - zarr_info - INFO - ds_processing/hix/ds/ds_ph_geo_pyramid/6.zarr zarray shape, chunks, dtype: (20, 23, 17), (256, 256, 1), complex64\n2025-09-20 23:41:18 - zarr_info - INFO - ds_processing/hix/ds/ds_ph_geo_pyramid/7.zarr zarray shape, chunks, dtype: (10, 12, 17), (256, 256, 1), complex64\n2025-09-20 23:41:18 - zarr_info - INFO - ds_processing/hix/ds/ds_ph_geo_pyramid/8.zarr zarray shape, chunks, dtype: (5, 6, 17), (256, 256, 1), complex64\n2025-09-20 23:41:18 - zarr_info - INFO - ds_processing/hix/ds/ds_ph_geo_pyramid/9.zarr zarray shape, chunks, dtype: (3, 3, 17), (256, 256, 1), complex64\n2025-09-20 23:41:18 - zarr_info - INFO - ds_processing/hix/ds/ds_ph_geo_pyramid/10.zarr zarray shape, chunks, dtype: (2, 2, 17), (256, 256, 1), complex64\n2025-09-20 23:41:19 - pc_pyramid - INFO - computing graph setted. doing all the computing.\n2025-09-20 23:41:21 - pc_pyramid - INFO - computing finished.  1.9s\n2025-09-20 23:41:21 - pc_pyramid - INFO - dask cluster closed.\n\n\n\nimport toml\nwith open('load_data/meta.toml','r') as f:\n    dates = toml.load(f)['dates']\nds_geo_intf_plot = mc.pc_plot('./ds_processing/hix/ds/ds_ph_geo_pyramid',post_proc_ras='intf_all', post_proc_pc='intf_all',level_increase=1)\nds_geo_intf_plot = ds_geo_intf_plot.redim(\n    i=hv.Dimension('i', label='Reference Image', range=(0,16), value_format=(lambda i: dates[i])),\n    j=hv.Dimension('j', label='Secondary Image', range=(0,16), value_format=(lambda i: dates[i])),\n    x=hv.Dimension('lon', label='Longitude'),\n    y=hv.Dimension('lat',label='Latitude'),\n    z=hv.Dimension('Phase',range=(-np.pi,np.pi))\n)\n\n\nhv.element.tiles.EsriImagery()*ds_geo_intf_plot.opts(\n    hv.opts.Image(\n        cmap='colorwheel',frame_width=500, frame_height=400, colorbar=True,\n        default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],\n        active_tools=['wheel_zoom']\n    ),\n    hv.opts.Points(\n        color='Phase', cmap='colorwheel',frame_width=500, frame_height=400, colorbar=True,\n        default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],\n        active_tools=['wheel_zoom']\n    ),\n)",
    "crumbs": [
      "Tutorials",
      "CLI",
      "DS Processing"
    ]
  },
  {
    "objectID": "CLI/math.html",
    "href": "CLI/math.html",
    "title": "math",
    "section": "",
    "text": "import zarr\nimport numpy as np\nimport moraine.cli as mc\n\n\nsource\n\nmath\n\n math (output:str, operation:str, **data)\n\nBasic math manipulation. Only elementwise operations are supported. Only one output is supported.\n\n\n\n\nType\nDetails\n\n\n\n\noutput\nstr\npath to output\n\n\noperation\nstr\noperation\n\n\ndata\nVAR_KEYWORD\n\n\n\n\nThis function is based on Numexpr. All operators and functions supported inNumexpr are supported except reduction operations.\nUsage:\n\na = np.random.rand(100,100).astype(np.float32)\nb = np.random.rand(100,100).astype(np.float32)\na_zarr = zarr.open('./math/a.zarr',mode='w',shape=a.shape,dtype=a.dtype,chunks=(10,10))\nb_zarr = zarr.open('./math/b.zarr',mode='w',shape=b.shape,dtype=b.dtype,chunks=(10,10))\na_zarr[:] = a; b_zarr[:] = b\n\n\nlogger = mc.get_logger()\n\n\nmath('./math/c.zarr','sin(a)*exp(b)/2',a='./math/a.zarr',b = './math/b.zarr')\n\n2025-09-18 12:18:32 - log_args - INFO - running function: math\n2025-09-18 12:18:32 - log_args - INFO - fetching args:\n2025-09-18 12:18:32 - log_args - INFO - output = './math/c.zarr'\n2025-09-18 12:18:32 - log_args - INFO - operation = 'sin(a)*exp(b)/2'\n2025-09-18 12:18:32 - log_args - INFO - data = {'a': './math/a.zarr', 'b': './math/b.zarr'}\n2025-09-18 12:18:32 - log_args - INFO - fetching args done.\n2025-09-18 12:18:32 - zarr_info - INFO - a zarray shape, chunks, dtype: (100, 100), (10, 10), float32\n2025-09-18 12:18:32 - zarr_info - INFO - b zarray shape, chunks, dtype: (100, 100), (10, 10), float32\n2025-09-18 12:18:32 - math - INFO - starting dask local cluster.\n2025-09-18 12:18:34 - math - INFO - dask local cluster started.\n2025-09-18 12:18:34 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.4:8787/status', workers=1, threads=2, memory=256.00 GiB)\n2025-09-18 12:18:34 - darr_info - INFO - a dask array shape, chunksize, dtype: (100, 100), (10, 10), float32\n2025-09-18 12:18:34 - darr_info - INFO - b dask array shape, chunksize, dtype: (100, 100), (10, 10), float32\n2025-09-18 12:18:35 - math - INFO - computing graph setted. doing all the computing.\n2025-09-18 12:18:36 - math - INFO - computing finished.eted |  1.4s\n2025-09-18 12:18:36 - math - INFO - dask cluster closed.\n\n\n\nc = zarr.open('./math/c.zarr',mode='r')[:]\nnp.testing.assert_array_almost_equal(c,np.sin(a)*np.exp(b)/2)",
    "crumbs": [
      "CLI",
      "math"
    ]
  },
  {
    "objectID": "CLI/plot.html",
    "href": "CLI/plot.html",
    "title": "plot",
    "section": "",
    "text": "import holoviews as hv\nfrom holoviews import opts\nimport numpy as np\nfrom bokeh.models import WheelZoomTool\nimport moraine.cli as mc",
    "crumbs": [
      "CLI",
      "plot"
    ]
  },
  {
    "objectID": "CLI/plot.html#raster-plot",
    "href": "CLI/plot.html#raster-plot",
    "title": "plot",
    "section": "raster plot",
    "text": "raster plot\n\nsource\n\nras_pyramid\n\n ras_pyramid (ras:str, out_dir:str, chunks:tuple[int,int]=(256, 256),\n              processes=False, n_workers=1, threads_per_worker=2,\n              **dask_cluster_arg)\n\nrender raster data to pyramid of difference zoom levels.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nras\nstr\n\npath to input data, 2D zarr array (one single raster) or 3D zarr array (a stack of rasters)\n\n\nout_dir\nstr\n\noutput directory to store rendered data\n\n\nchunks\ntuple\n(256, 256)\noutput raster tile size\n\n\nprocesses\nbool\nFalse\nuse process for dask worker over thread\n\n\nn_workers\nint\n1\nnumber of dask worker\n\n\nthreads_per_worker\nint\n2\nnumber of threads per dask worker\n\n\ndask_cluster_arg\nVAR_KEYWORD\n\n\n\n\n\n[ras_pyramid](https://kanglcn.github.io/moraine/CLI/plot.html#ras_pyramid) render one single raster (2D array) or a stack of rasters (2D array) into tiles of difference resolution (zoom level).\n\nadi = 'ps/adi.zarr'\nrslc = 'raw/rslc.zarr'\nadi_pyramid_dir = 'plot/adi_pyramid'\nrslc_pyramid_dir = 'plot/rslc_pyramid'\n\n\nlogger = mc.get_logger()\n\n\nras_pyramid(adi,adi_pyramid_dir)\n\n2025-09-19 23:52:21 - log_args - INFO - running function: ras_pyramid\n2025-09-19 23:52:21 - log_args - INFO - fetching args:\n2025-09-19 23:52:21 - log_args - INFO - ras = 'ps/adi.zarr'\n2025-09-19 23:52:21 - log_args - INFO - out_dir = 'plot/adi_pyramid'\n2025-09-19 23:52:21 - log_args - INFO - chunks = (256, 256)\n2025-09-19 23:52:21 - log_args - INFO - processes = False\n2025-09-19 23:52:21 - log_args - INFO - n_workers = 1\n2025-09-19 23:52:21 - log_args - INFO - threads_per_worker = 2\n2025-09-19 23:52:21 - log_args - INFO - dask_cluster_arg = {}\n2025-09-19 23:52:21 - log_args - INFO - fetching args done.\n2025-09-19 23:52:21 - ras_pyramid - INFO - clean out dir\n2025-09-19 23:52:21 - zarr_info - INFO - ps/adi.zarr zarray shape, chunks, dtype: (2500, 1834), (1000, 1000), float32\n2025-09-19 23:52:21 - ras_pyramid - INFO - rendered raster pyramid with zoom level ranging from 0 (finest resolution) to 10 (coarsest resolution).\n2025-09-19 23:52:24 - ras_pyramid - INFO - dask local cluster started.\n2025-09-19 23:52:24 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.19:8787/status', workers=1, threads=2, memory=1.95 TiB)\n2025-09-19 23:52:24 - zarr_info - INFO - plot/adi_pyramid/0.zarr zarray shape, chunks, dtype: (2500, 1834), (256, 256), float32\n2025-09-19 23:52:24 - zarr_info - INFO - plot/adi_pyramid/1.zarr zarray shape, chunks, dtype: (1250, 917), (256, 256), float32\n2025-09-19 23:52:24 - zarr_info - INFO - plot/adi_pyramid/2.zarr zarray shape, chunks, dtype: (625, 459), (256, 256), float32\n2025-09-19 23:52:24 - zarr_info - INFO - plot/adi_pyramid/3.zarr zarray shape, chunks, dtype: (313, 230), (256, 256), float32\n2025-09-19 23:52:24 - zarr_info - INFO - plot/adi_pyramid/4.zarr zarray shape, chunks, dtype: (157, 115), (256, 256), float32\n2025-09-19 23:52:24 - zarr_info - INFO - plot/adi_pyramid/5.zarr zarray shape, chunks, dtype: (79, 58), (256, 256), float32\n2025-09-19 23:52:24 - zarr_info - INFO - plot/adi_pyramid/6.zarr zarray shape, chunks, dtype: (40, 29), (256, 256), float32\n2025-09-19 23:52:24 - zarr_info - INFO - plot/adi_pyramid/7.zarr zarray shape, chunks, dtype: (20, 15), (256, 256), float32\n2025-09-19 23:52:24 - zarr_info - INFO - plot/adi_pyramid/8.zarr zarray shape, chunks, dtype: (10, 8), (256, 256), float32\n2025-09-19 23:52:24 - zarr_info - INFO - plot/adi_pyramid/9.zarr zarray shape, chunks, dtype: (5, 4), (256, 256), float32\n2025-09-19 23:52:24 - zarr_info - INFO - plot/adi_pyramid/10.zarr zarray shape, chunks, dtype: (3, 2), (256, 256), float32\n2025-09-19 23:52:24 - ras_pyramid - INFO - computing graph setted. doing all the computing.\n2025-09-19 23:52:24 - ras_pyramid - INFO - computing finished. 0.3s\n2025-09-19 23:52:24 - ras_pyramid - INFO - dask cluster closed.\n\n\n\nras_pyramid(rslc,rslc_pyramid_dir)\n\n2025-09-19 23:52:24 - log_args - INFO - running function: ras_pyramid\n2025-09-19 23:52:24 - log_args - INFO - fetching args:\n2025-09-19 23:52:24 - log_args - INFO - ras = 'raw/rslc.zarr'\n2025-09-19 23:52:24 - log_args - INFO - out_dir = 'plot/rslc_pyramid'\n2025-09-19 23:52:24 - log_args - INFO - chunks = (256, 256)\n2025-09-19 23:52:24 - log_args - INFO - processes = False\n2025-09-19 23:52:24 - log_args - INFO - n_workers = 1\n2025-09-19 23:52:24 - log_args - INFO - threads_per_worker = 2\n2025-09-19 23:52:24 - log_args - INFO - dask_cluster_arg = {}\n2025-09-19 23:52:24 - log_args - INFO - fetching args done.\n2025-09-19 23:52:24 - ras_pyramid - INFO - clean out dir\n2025-09-19 23:52:25 - zarr_info - INFO - raw/rslc.zarr zarray shape, chunks, dtype: (2500, 1834, 17), (1000, 1000, 1), complex64\n2025-09-19 23:52:25 - ras_pyramid - INFO - rendered raster pyramid with zoom level ranging from 0 (finest resolution) to 10 (coarsest resolution).\n2025-09-19 23:52:25 - ras_pyramid - INFO - dask local cluster started.\n2025-09-19 23:52:25 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.19:8787/status', workers=1, threads=2, memory=1.95 TiB)\n2025-09-19 23:52:25 - zarr_info - INFO - plot/rslc_pyramid/0.zarr zarray shape, chunks, dtype: (2500, 1834, 17), (256, 256, 1), complex64\n2025-09-19 23:52:25 - zarr_info - INFO - plot/rslc_pyramid/1.zarr zarray shape, chunks, dtype: (1250, 917, 17), (256, 256, 1), complex64\n2025-09-19 23:52:25 - zarr_info - INFO - plot/rslc_pyramid/2.zarr zarray shape, chunks, dtype: (625, 459, 17), (256, 256, 1), complex64\n2025-09-19 23:52:25 - zarr_info - INFO - plot/rslc_pyramid/3.zarr zarray shape, chunks, dtype: (313, 230, 17), (256, 256, 1), complex64\n2025-09-19 23:52:25 - zarr_info - INFO - plot/rslc_pyramid/4.zarr zarray shape, chunks, dtype: (157, 115, 17), (256, 256, 1), complex64\n2025-09-19 23:52:25 - zarr_info - INFO - plot/rslc_pyramid/5.zarr zarray shape, chunks, dtype: (79, 58, 17), (256, 256, 1), complex64\n2025-09-19 23:52:25 - zarr_info - INFO - plot/rslc_pyramid/6.zarr zarray shape, chunks, dtype: (40, 29, 17), (256, 256, 1), complex64\n2025-09-19 23:52:25 - zarr_info - INFO - plot/rslc_pyramid/7.zarr zarray shape, chunks, dtype: (20, 15, 17), (256, 256, 1), complex64\n2025-09-19 23:52:25 - zarr_info - INFO - plot/rslc_pyramid/8.zarr zarray shape, chunks, dtype: (10, 8, 17), (256, 256, 1), complex64\n2025-09-19 23:52:25 - zarr_info - INFO - plot/rslc_pyramid/9.zarr zarray shape, chunks, dtype: (5, 4, 17), (256, 256, 1), complex64\n2025-09-19 23:52:25 - zarr_info - INFO - plot/rslc_pyramid/10.zarr zarray shape, chunks, dtype: (3, 2, 17), (256, 256, 1), complex64\n2025-09-19 23:52:26 - ras_pyramid - INFO - computing graph setted. doing all the computing.\n2025-09-19 23:52:30 - ras_pyramid - INFO - computing finished. 4.0s\n2025-09-19 23:52:30 - ras_pyramid - INFO - dask cluster closed.\n\n\n\nsource\n\n\nras_plot\n\n ras_plot (pyramid_dir:str, post_proc:Callable=None, n_kdim:int=None,\n           bounds:tuple=None, level_increase=0)\n\nplot rendered stack of ras tiles.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\npyramid_dir\nstr\n\ndirectory to the rendered ras pyramid\n\n\npost_proc\nCallable\nNone\nfunction for the post processing, can be None, ‘intf_0’, ‘intf_seq’, ‘intf_all’ or user-defined function\n\n\nn_kdim\nint\nNone\nnumber of key dimensions, can only be 0 or 1 or 2, ndim of raster dataset -2 by default\n\n\nbounds\ntuple\nNone\nbounding box (x0, y0, x_max, y_max)\n\n\nlevel_increase\nint\n0\namount of zoom level increase for more clear point show and faster responds time\n\n\n\n\nhv.extension('bokeh')\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n  \n  \n\n\n\n\n\n\n\n\nⓘ\n\n\n\n\nras_plot take the rendered raster images as the input and return a Holoviews DynamicMap. It accept a post processing function for customized post processing and n_kdim to set number of kdims for returned DynamicMap.\nHere is an example to plot the amplitude dispersion index. We define a post processing function to mask pixels with ADI larger than 0.4:\n\ndef mask_adi(data_zarr,x_slice,y_slice,):\n    data = data_zarr[y_slice, x_slice]\n    data[data&gt;=0.4]=np.nan\n    return data\n\nNote that the first three arguments of post_proc_func have to be data_zarr, x_slice, y_slice.\n\nadi_plot = ras_plot(adi_pyramid_dir,post_proc=mask_adi,bounds=(0,0,1833,2499),level_increase=1)\n\nAdd annotations:\n\nadi_plot = adi_plot.redim(x=hv.Dimension('r', label='Range'), y=hv.Dimension('az',label='Azimuth'),\n                          z=hv.Dimension('adi',label='Amplitude Dispersion Index',range=(0,0.4)))\n\nSpecify plotting options and plot:\n\nadi_plot.opts(opts.Image(cmap='fire',width=600, height=400, colorbar=True,\n                         invert_yaxis=True, \n                         default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],\n                         active_tools=['wheel_zoom']\n                        ))\n\n\n\n\n\n  \n\n\n\n\n\n\n\nRaster Plot\n\n\nras_plot can also take stack of raster images. It will return DynamicMap with keys. Here we define a function to generate interferograms with the first SLC as reference:\n\ndef intf_0(data_zarr, xslice, yslice,i):\n    return np.angle(data_zarr[yslice,xslice,0]*data_zarr[yslice,xslice,i].conj())\n\n\nintf_plot = ras_plot(rslc_pyramid_dir,post_proc=intf_0, level_increase=0)\n\nWe have a set of convenient predefined post_proc functions, e.g., intf_0, intf_seq, intf_all. The above code equals to:\n\nintf_plot = ras_plot(rslc_pyramid_dir,post_proc='intf_0', level_increase=0)\n\nAdd annotations:\n\ndates = [\"20210802\", \"20210816\", \"20210830\", \"20210913\", \"20211011\", \"20211025\", \"20220606\", \"20220620\",\n         \"20220704\", \"20220718\", \"20220801\", \"20220815\", \"20220829\", \"20220912\", \"20220926\", \"20221010\",\n         \"20221024\",]\nintf_plot = intf_plot.redim(i=hv.Dimension('i', label='Interferogram', range=(0,16), value_format=(lambda i: dates[0]+'_'+dates[i])),\n                            x=hv.Dimension('r', label='Range'), y=hv.Dimension('az',label='Azimuth'), z=hv.Dimension('Phase',range=(-np.pi,np.pi)))\n\nSpecify plotting options and plot:\n\nhv.output(widget_location='bottom')\nintf_plot.opts(opts.Image(cmap='colorwheel',width=600, height=400, colorbar=True,\n                          invert_yaxis=True,\n                          default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],active_tools=['wheel_zoom']))\n\n\n\n\n\n  \n\n\n\n\n\n#![Raster Stack Plot](./plot/raster_stack_plot.gif)\n\nOr the intensity:\n\ndef intensity(data_zarr, xslice, yslice,i):\n    return np.log(np.abs(data_zarr[yslice,xslice,i])**2)\n\nint_plot = ras_plot(rslc_pyramid_dir,post_proc=intensity)\nint_plot = int_plot.redim(i=hv.Dimension('i', label='Intensity', range=(1,16), value_format=(lambda i: dates[i])),\n                          x=hv.Dimension('r', label='Range'), y=hv.Dimension('az',label='Azimuth'), z=hv.Dimension('Intensity'))\nint_plot.opts(opts.Image(cmap='gray',width=600, height=600, colorbar=True,\n                         invert_yaxis=True, default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],\n                         active_tools=['wheel_zoom']))\n\n\n\n\n\n  \n\n\n\n\nWe can also plot sequential interferograms. In this case, we only plot 26 interferograms.\n\ndef intf_seq(data_zarr, xslice, yslice,i):\n    return np.angle(data_zarr[yslice,xslice,i]*data_zarr[yslice,xslice,i+1].conj())\nintf_plot = ras_plot(rslc_pyramid_dir,post_proc=intf_seq)\n# or\nintf_plot = ras_plot(rslc_pyramid_dir,post_proc='intf_seq')\n\nintf_plot = intf_plot.redim(i=hv.Dimension('i', label='Interferogram', range=(0,15), value_format=(lambda i: dates[i]+'_'+dates[i+1])),\n                            x=hv.Dimension('r', label='Range'), y=hv.Dimension('az',label='Azimuth'), z=hv.Dimension('Phase',range=(-np.pi,np.pi)))\nintf_plot.opts(opts.Image(cmap='colorwheel',width=600, height=600, colorbar=True,\n                          invert_yaxis=True, default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],\n                          active_tools=['wheel_zoom']))\n\n\n\n\n\n  \n\n\n\n\nThe n_kdim don’t have to be data.ndim-2. Here is an example to show all interferograms.\n\ndef intf_all(data_zarr, xslice, yslice,i,j): # we have 2 kdims here\n    return np.angle(data_zarr[yslice,xslice,i]*data_zarr[yslice,xslice,j].conj())\n\n\nintf_plot = ras_plot(rslc_pyramid_dir,post_proc=intf_all,n_kdim=2,level_increase=0)\n# or\nintf_plot = ras_plot(rslc_pyramid_dir,post_proc='intf_all',n_kdim=2,level_increase=0)\n\nAdd annotations:\n\nintf_plot = intf_plot.redim(i=hv.Dimension('i', label='Reference Image', range=(0,16), value_format=(lambda i: dates[i])),\n                            j=hv.Dimension('j', label='Secondary Image', range=(0,16), value_format=(lambda i: dates[i])),\n                            x=hv.Dimension('r', label='Range'), y=hv.Dimension('az',label='Azimuth'), z=hv.Dimension('Phase',range=(-np.pi,np.pi)))\n\nSpecify plotting options and plot:\n\nhv.output(widget_location='bottom')\nintf_plot.opts(opts.Image(cmap='colorwheel',frame_width=500, frame_height=600, colorbar=True,\n                          invert_yaxis=True,\n                          default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],active_tools=['wheel_zoom']))",
    "crumbs": [
      "CLI",
      "plot"
    ]
  },
  {
    "objectID": "CLI/plot.html#point-cloud-plot",
    "href": "CLI/plot.html#point-cloud-plot",
    "title": "plot",
    "section": "point cloud plot",
    "text": "point cloud plot\n\nsource\n\npc_pyramid\n\n pc_pyramid (pc:str, out_dir:str, x:str=None, y:str=None, yx:str=None,\n             ras_resolution:float=20, ras_chunks:tuple[int,int]=(256,\n             256), pc_chunks:int=65536, processes=False, n_workers=1,\n             threads_per_worker=2, **dask_cluster_arg)\n\nrender point cloud data to pyramid of difference zoom levels.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\npc\nstr\n\npath to point cloud data, 1D array (one single pc image) or 2D zarr array (a stack of pc images)\n\n\nout_dir\nstr\n\noutput directory to store rendered data\n\n\nx\nstr\nNone\npath to x coordinate, e.g., longitude or web mercator x\n\n\ny\nstr\nNone\npath to y coordinate, e.g., latitude or web mercator y\n\n\nyx\nstr\nNone\npath to x and y coordinates. this coordinates should have shape [n_points,2]. e.g., gix\n\n\nras_resolution\nfloat\n20\nminimum resolution of rendered raster data,\n\n\nras_chunks\ntuple\n(256, 256)\noutput raster tile size\n\n\npc_chunks\nint\n65536\noutput pc tile size\n\n\nprocesses\nbool\nFalse\nuse process for dask worker over thread\n\n\nn_workers\nint\n1\nnumber of dask worker\n\n\nthreads_per_worker\nint\n2\nnumber of threads per dask worker\n\n\ndask_cluster_arg\nVAR_KEYWORD\n\n\n\n\n\npc_pyramid is a little bit more complex than ras_pyramid. The zoom level -1 is the point cloud data. From zoom level 0 to above, the point cloud data is rasterize at different resolution. ras_resolution is the parameter to set the resolution of zoom level 0.\n\nps_can_adi = 'ps/ps_can_adi.zarr/'\nps_can_rslc = 'ps/ps_can_rslc.zarr/'\nps_can_x = './ps/ps_can_e.zarr/'\nps_can_y = './ps/ps_can_n.zarr/'\nadi_pyramid_dir = 'plot/pc/adi_pyramid'\nrslc_pyramid_dir = 'plot/pc/rslc_pyramid'\n\n\npc_pyramid(ps_can_adi, adi_pyramid_dir, x=ps_can_x, y=ps_can_y, ras_resolution=20)\n\n2025-09-19 23:52:34 - log_args - INFO - running function: pc_pyramid\n2025-09-19 23:52:34 - log_args - INFO - fetching args:\n2025-09-19 23:52:34 - log_args - INFO - pc = 'ps/ps_can_adi.zarr/'\n2025-09-19 23:52:34 - log_args - INFO - out_dir = 'plot/pc/adi_pyramid'\n2025-09-19 23:52:34 - log_args - INFO - x = './ps/ps_can_e.zarr/'\n2025-09-19 23:52:34 - log_args - INFO - y = './ps/ps_can_n.zarr/'\n2025-09-19 23:52:34 - log_args - INFO - yx = None\n2025-09-19 23:52:34 - log_args - INFO - ras_resolution = 20\n2025-09-19 23:52:34 - log_args - INFO - ras_chunks = (256, 256)\n2025-09-19 23:52:34 - log_args - INFO - pc_chunks = 65536\n2025-09-19 23:52:34 - log_args - INFO - processes = False\n2025-09-19 23:52:34 - log_args - INFO - n_workers = 1\n2025-09-19 23:52:34 - log_args - INFO - threads_per_worker = 2\n2025-09-19 23:52:34 - log_args - INFO - dask_cluster_arg = {}\n2025-09-19 23:52:34 - log_args - INFO - fetching args done.\n2025-09-19 23:52:34 - pc_pyramid - INFO - clean out dir\n2025-09-19 23:52:34 - zarr_info - INFO - ps/ps_can_adi.zarr/ zarray shape, chunks, dtype: (43201,), (100000,), float32\n2025-09-19 23:52:34 - pc_pyramid - INFO - rendering point cloud data coordinates:\n2025-09-19 23:52:34 - pc_pyramid - INFO - rasterizing point cloud data to grid with bounds: [np.float64(-16498455.50940282), np.float64(8649634.094942318), np.float64(-16470215.50940282), np.float64(8674894.094942318)].\n2025-09-19 23:52:34 - zarr_info - INFO - plot/pc/adi_pyramid/x.zarr zarray shape, chunks, dtype: (43201,), (65536,), float64\n2025-09-19 23:52:34 - zarr_info - INFO - plot/pc/adi_pyramid/y.zarr zarray shape, chunks, dtype: (43201,), (65536,), float64\n2025-09-19 23:52:34 - pc_pyramid - INFO - pc data coordinates rendering ends.\n2025-09-19 23:52:34 - zarr_info - INFO - plot/pc/adi_pyramid/idx_0.zarr zarray shape, chunks, dtype: (1264, 1413), (256, 256), int64\n2025-09-19 23:52:34 - zarr_info - INFO - plot/pc/adi_pyramid/idx_1.zarr zarray shape, chunks, dtype: (632, 707), (256, 256), int64\n2025-09-19 23:52:35 - zarr_info - INFO - plot/pc/adi_pyramid/idx_2.zarr zarray shape, chunks, dtype: (316, 354), (256, 256), int64\n2025-09-19 23:52:35 - zarr_info - INFO - plot/pc/adi_pyramid/idx_3.zarr zarray shape, chunks, dtype: (158, 177), (256, 256), int64\n2025-09-19 23:52:35 - zarr_info - INFO - plot/pc/adi_pyramid/idx_4.zarr zarray shape, chunks, dtype: (79, 89), (256, 256), int64\n2025-09-19 23:52:35 - zarr_info - INFO - plot/pc/adi_pyramid/idx_5.zarr zarray shape, chunks, dtype: (40, 45), (256, 256), int64\n2025-09-19 23:52:35 - zarr_info - INFO - plot/pc/adi_pyramid/idx_6.zarr zarray shape, chunks, dtype: (20, 23), (256, 256), int64\n2025-09-19 23:52:35 - zarr_info - INFO - plot/pc/adi_pyramid/idx_7.zarr zarray shape, chunks, dtype: (10, 12), (256, 256), int64\n2025-09-19 23:52:35 - zarr_info - INFO - plot/pc/adi_pyramid/idx_8.zarr zarray shape, chunks, dtype: (5, 6), (256, 256), int64\n2025-09-19 23:52:35 - zarr_info - INFO - plot/pc/adi_pyramid/idx_9.zarr zarray shape, chunks, dtype: (3, 3), (256, 256), int64\n2025-09-19 23:52:35 - zarr_info - INFO - plot/pc/adi_pyramid/idx_10.zarr zarray shape, chunks, dtype: (2, 2), (256, 256), int64\n2025-09-19 23:52:35 - pc_pyramid - INFO - rasterized idx rendering ends\n2025-09-19 23:52:35 - pc_pyramid - INFO - dask local cluster started to render pc data.\n2025-09-19 23:52:35 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.19:8787/status', workers=1, threads=2, memory=1.95 TiB)\n2025-09-19 23:52:35 - zarr_info - INFO - plot/pc/adi_pyramid/pc.zarr zarray shape, chunks, dtype: (43201,), (65536,), float32\n2025-09-19 23:52:35 - zarr_info - INFO - plot/pc/adi_pyramid/0.zarr zarray shape, chunks, dtype: (1264, 1413), (256, 256), float32\n2025-09-19 23:52:35 - zarr_info - INFO - plot/pc/adi_pyramid/1.zarr zarray shape, chunks, dtype: (632, 707), (256, 256), float32\n2025-09-19 23:52:35 - zarr_info - INFO - plot/pc/adi_pyramid/2.zarr zarray shape, chunks, dtype: (316, 354), (256, 256), float32\n2025-09-19 23:52:35 - zarr_info - INFO - plot/pc/adi_pyramid/3.zarr zarray shape, chunks, dtype: (158, 177), (256, 256), float32\n2025-09-19 23:52:35 - zarr_info - INFO - plot/pc/adi_pyramid/4.zarr zarray shape, chunks, dtype: (79, 89), (256, 256), float32\n2025-09-19 23:52:35 - zarr_info - INFO - plot/pc/adi_pyramid/5.zarr zarray shape, chunks, dtype: (40, 45), (256, 256), float32\n2025-09-19 23:52:35 - zarr_info - INFO - plot/pc/adi_pyramid/6.zarr zarray shape, chunks, dtype: (20, 23), (256, 256), float32\n2025-09-19 23:52:35 - zarr_info - INFO - plot/pc/adi_pyramid/7.zarr zarray shape, chunks, dtype: (10, 12), (256, 256), float32\n2025-09-19 23:52:35 - zarr_info - INFO - plot/pc/adi_pyramid/8.zarr zarray shape, chunks, dtype: (5, 6), (256, 256), float32\n2025-09-19 23:52:35 - zarr_info - INFO - plot/pc/adi_pyramid/9.zarr zarray shape, chunks, dtype: (3, 3), (256, 256), float32\n2025-09-19 23:52:35 - zarr_info - INFO - plot/pc/adi_pyramid/10.zarr zarray shape, chunks, dtype: (2, 2), (256, 256), float32\n2025-09-19 23:52:35 - pc_pyramid - INFO - computing graph setted. doing all the computing.\n2025-09-19 23:52:35 - pc_pyramid - INFO - computing finished.  0.3s\n2025-09-19 23:52:35 - pc_pyramid - INFO - dask cluster closed.\nCPU times: user 26.5 s, sys: 12.8 s, total: 39.3 s\nWall time: 1.78 s\n\n\n\npc_pyramid(ps_can_rslc, rslc_pyramid_dir, x=ps_can_x, y=ps_can_y, ras_resolution=20)\n\n2025-09-19 23:52:35 - log_args - INFO - running function: pc_pyramid\n2025-09-19 23:52:35 - log_args - INFO - fetching args:\n2025-09-19 23:52:35 - log_args - INFO - pc = 'ps/ps_can_rslc.zarr/'\n2025-09-19 23:52:35 - log_args - INFO - out_dir = 'plot/pc/rslc_pyramid'\n2025-09-19 23:52:35 - log_args - INFO - x = './ps/ps_can_e.zarr/'\n2025-09-19 23:52:35 - log_args - INFO - y = './ps/ps_can_n.zarr/'\n2025-09-19 23:52:35 - log_args - INFO - yx = None\n2025-09-19 23:52:35 - log_args - INFO - ras_resolution = 20\n2025-09-19 23:52:35 - log_args - INFO - ras_chunks = (256, 256)\n2025-09-19 23:52:35 - log_args - INFO - pc_chunks = 65536\n2025-09-19 23:52:35 - log_args - INFO - processes = False\n2025-09-19 23:52:35 - log_args - INFO - n_workers = 1\n2025-09-19 23:52:35 - log_args - INFO - threads_per_worker = 2\n2025-09-19 23:52:35 - log_args - INFO - dask_cluster_arg = {}\n2025-09-19 23:52:35 - log_args - INFO - fetching args done.\n2025-09-19 23:52:35 - pc_pyramid - INFO - clean out dir\n2025-09-19 23:52:36 - zarr_info - INFO - ps/ps_can_rslc.zarr/ zarray shape, chunks, dtype: (43201, 17), (100000, 1), complex64\n2025-09-19 23:52:36 - pc_pyramid - INFO - rendering point cloud data coordinates:\n2025-09-19 23:52:36 - pc_pyramid - INFO - rasterizing point cloud data to grid with bounds: [np.float64(-16498455.50940282), np.float64(8649634.094942318), np.float64(-16470215.50940282), np.float64(8674894.094942318)].\n2025-09-19 23:52:36 - zarr_info - INFO - plot/pc/rslc_pyramid/x.zarr zarray shape, chunks, dtype: (43201,), (65536,), float64\n2025-09-19 23:52:36 - zarr_info - INFO - plot/pc/rslc_pyramid/y.zarr zarray shape, chunks, dtype: (43201,), (65536,), float64\n2025-09-19 23:52:36 - pc_pyramid - INFO - pc data coordinates rendering ends.\n2025-09-19 23:52:36 - zarr_info - INFO - plot/pc/rslc_pyramid/idx_0.zarr zarray shape, chunks, dtype: (1264, 1413), (256, 256), int64\n2025-09-19 23:52:36 - zarr_info - INFO - plot/pc/rslc_pyramid/idx_1.zarr zarray shape, chunks, dtype: (632, 707), (256, 256), int64\n2025-09-19 23:52:36 - zarr_info - INFO - plot/pc/rslc_pyramid/idx_2.zarr zarray shape, chunks, dtype: (316, 354), (256, 256), int64\n2025-09-19 23:52:36 - zarr_info - INFO - plot/pc/rslc_pyramid/idx_3.zarr zarray shape, chunks, dtype: (158, 177), (256, 256), int64\n2025-09-19 23:52:36 - zarr_info - INFO - plot/pc/rslc_pyramid/idx_4.zarr zarray shape, chunks, dtype: (79, 89), (256, 256), int64\n2025-09-19 23:52:36 - zarr_info - INFO - plot/pc/rslc_pyramid/idx_5.zarr zarray shape, chunks, dtype: (40, 45), (256, 256), int64\n2025-09-19 23:52:36 - zarr_info - INFO - plot/pc/rslc_pyramid/idx_6.zarr zarray shape, chunks, dtype: (20, 23), (256, 256), int64\n2025-09-19 23:52:36 - zarr_info - INFO - plot/pc/rslc_pyramid/idx_7.zarr zarray shape, chunks, dtype: (10, 12), (256, 256), int64\n2025-09-19 23:52:36 - zarr_info - INFO - plot/pc/rslc_pyramid/idx_8.zarr zarray shape, chunks, dtype: (5, 6), (256, 256), int64\n2025-09-19 23:52:36 - zarr_info - INFO - plot/pc/rslc_pyramid/idx_9.zarr zarray shape, chunks, dtype: (3, 3), (256, 256), int64\n2025-09-19 23:52:36 - zarr_info - INFO - plot/pc/rslc_pyramid/idx_10.zarr zarray shape, chunks, dtype: (2, 2), (256, 256), int64\n2025-09-19 23:52:36 - pc_pyramid - INFO - rasterized idx rendering ends\n2025-09-19 23:52:36 - pc_pyramid - INFO - dask local cluster started to render pc data.\n2025-09-19 23:52:36 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.19:8787/status', workers=1, threads=2, memory=1.95 TiB)\n2025-09-19 23:52:36 - zarr_info - INFO - plot/pc/rslc_pyramid/pc.zarr zarray shape, chunks, dtype: (43201, 17), (65536, 1), complex64\n2025-09-19 23:52:36 - zarr_info - INFO - plot/pc/rslc_pyramid/0.zarr zarray shape, chunks, dtype: (1264, 1413, 17), (256, 256, 1), complex64\n2025-09-19 23:52:36 - zarr_info - INFO - plot/pc/rslc_pyramid/1.zarr zarray shape, chunks, dtype: (632, 707, 17), (256, 256, 1), complex64\n2025-09-19 23:52:36 - zarr_info - INFO - plot/pc/rslc_pyramid/2.zarr zarray shape, chunks, dtype: (316, 354, 17), (256, 256, 1), complex64\n2025-09-19 23:52:36 - zarr_info - INFO - plot/pc/rslc_pyramid/3.zarr zarray shape, chunks, dtype: (158, 177, 17), (256, 256, 1), complex64\n2025-09-19 23:52:36 - zarr_info - INFO - plot/pc/rslc_pyramid/4.zarr zarray shape, chunks, dtype: (79, 89, 17), (256, 256, 1), complex64\n2025-09-19 23:52:36 - zarr_info - INFO - plot/pc/rslc_pyramid/5.zarr zarray shape, chunks, dtype: (40, 45, 17), (256, 256, 1), complex64\n2025-09-19 23:52:36 - zarr_info - INFO - plot/pc/rslc_pyramid/6.zarr zarray shape, chunks, dtype: (20, 23, 17), (256, 256, 1), complex64\n2025-09-19 23:52:36 - zarr_info - INFO - plot/pc/rslc_pyramid/7.zarr zarray shape, chunks, dtype: (10, 12, 17), (256, 256, 1), complex64\n2025-09-19 23:52:36 - zarr_info - INFO - plot/pc/rslc_pyramid/8.zarr zarray shape, chunks, dtype: (5, 6, 17), (256, 256, 1), complex64\n2025-09-19 23:52:36 - zarr_info - INFO - plot/pc/rslc_pyramid/9.zarr zarray shape, chunks, dtype: (3, 3, 17), (256, 256, 1), complex64\n2025-09-19 23:52:36 - zarr_info - INFO - plot/pc/rslc_pyramid/10.zarr zarray shape, chunks, dtype: (2, 2, 17), (256, 256, 1), complex64\n2025-09-19 23:52:37 - pc_pyramid - INFO - computing graph setted. doing all the computing.\n2025-09-19 23:52:39 - pc_pyramid - INFO - computing finished.  1.8s\n2025-09-19 23:52:39 - pc_pyramid - INFO - dask cluster closed.\nCPU times: user 31.5 s, sys: 9.67 s, total: 41.2 s\nWall time: 3.27 s\n\n\n\nsource\n\n\npc_plot\n\n pc_plot (pyramid_dir:str, post_proc_ras:Callable=None,\n          post_proc_pc:Callable=None, n_kdim:int=None, rtree=None,\n          level_increase=0)\n\nplot rendered point cloud pyramid.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\npyramid_dir\nstr\n\ndirectory to the rendered point cloud pyramid\n\n\npost_proc_ras\nCallable\nNone\nfunction for the post processing\n\n\npost_proc_pc\nCallable\nNone\nfunction for the post processing\n\n\nn_kdim\nint\nNone\nnumber of key dimensions, can only be 0 or 1 or 2, ndim of point cloud dataset -1 by default\n\n\nrtree\nNoneType\nNone\nrtree, if not provide, will be automatically generated but may slow the program\n\n\nlevel_increase\nint\n0\namount of zoom level increase for more clear point show and faster responds time\n\n\n\npc_plot take the rendered point cloud dataset as the input and return a Holoviews DynamicMap. When the zoom level is -1, it plot the the raw point cloud data. When the zoom level is 0 or over 0, it plot the rasterized images. Just as ras_plot, it accept post processing functions for both point cloud data and raster data to be plot. It is the user’s duty to esure the post processing fuctions coincide with each other. It also accept n_kdim to set number of kdims for returned DynamicMap.\nHere is an example to plot the amplitude dispersion index:\n\nadi_plot = pc_plot(adi_pyramid_dir,level_increase=1)\n\nAdd annotations:\n\nadi_plot = adi_plot.redim(x=hv.Dimension('lon', label='Longitude'), y=hv.Dimension('lat',label='Latitude'),\n                          z=hv.Dimension('adi',label='Amplitude Dispersion Index',range=(0,0.3))\n                         )\n\nSpecify plotting options and plot:\n\nadi_plot.opts(opts.Image(cmap='fire',width=600, height=400, colorbar=True,\n                         # invert_yaxis=True, \n                         default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],\n                         active_tools=['wheel_zoom']\n                        ),\n              opts.Points(color='adi', cmap='fire',width=600, height=400, colorbar=True,\n                         # invert_yaxis=True, \n                         default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],\n                         active_tools=['wheel_zoom']\n                        )\n             )\n\n\n\n\n\n  \n\n\n\n\n\n\n\npc_plot\n\n\nAdd the optical image as the background:\n\nhv.element.tiles.EsriImagery()*adi_plot\n\n\n\n\n\n  \n\n\n\n\n\n\n\npc_tiles_plot\n\n\nNote that, for displaying data over tiles, the data have to be projected to the Web Mercator Projection.\nAs ras_plot, pc_plot can also take stack of point cloud dataset. It will return DynamicMap with keys. Here we define a function to generate interferograms with the first SLC as reference:\n\ndef intf_0_pc(data_zarr,idx_array,i):\n    return np.angle(data_zarr[idx_array,0]*data_zarr[idx_array,i].conj())\ndef intf_0_ras(data_zarr, xslice, yslice,i):\n    return np.angle(data_zarr[yslice,xslice,0]*data_zarr[yslice,xslice,i].conj())\n\n\nintf_plot = pc_plot(rslc_pyramid_dir,post_proc_ras=intf_0_ras, post_proc_pc=intf_0_pc, level_increase=1)\n# or\nintf_plot = pc_plot(rslc_pyramid_dir,post_proc_ras='intf_0', post_proc_pc='intf_0', level_increase=1)\n\nAdd annotations:\n\ndates = [\"20210802\", \"20210816\", \"20210830\", \"20210913\", \"20211011\", \"20211025\", \"20220606\", \"20220620\",\n         \"20220704\", \"20220718\", \"20220801\", \"20220815\", \"20220829\", \"20220912\", \"20220926\", \"20221010\",\n         \"20221024\",]\nintf_plot = intf_plot.redim(i=hv.Dimension('i', label='Interferogram', range=(0,16), value_format=(lambda i: dates[0]+'_'+dates[i])),\n                            x=hv.Dimension('lon', label='Longitude'), y=hv.Dimension('lat',label='Latitude'), z=hv.Dimension('Phase',range=(-np.pi,np.pi)))\n\nSpecify plotting options and plot:\n\nhv.output(widget_location='bottom')\nintf_plot.opts(opts.Image(cmap='colorwheel',width=600, height=400, colorbar=True,\n                          default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],\n                          active_tools=['wheel_zoom']\n                         ),\n              opts.Points(color='Phase', cmap='colorwheel',width=600, height=400, colorbar=True,\n                         # invert_yaxis=True, \n                         default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],\n                         active_tools=['wheel_zoom']\n                        )\n              )\n\n\n\n\n\n  \n\n\n\n\n\n#![pc_stack_plot](./plot/pc_stack_plot.gif)\n\nThe n_kdim don’t have to be data.ndim-1. Here is an example to show all interferograms.\n\ndef intf_pc(data_zarr, idx_arr,i,j): # we have 2 kdims here\n    return np.angle(data_zarr[idx_arr,i]*data_zarr[idx_arr,j].conj())\ndef intf_ras(data_zarr, xslice, yslice,i,j): # we have 2 kdims here\n    return np.angle(data_zarr[yslice,xslice,i]*data_zarr[yslice,xslice,j].conj())\n\n\nintf_plot = pc_plot(rslc_pyramid_dir,post_proc_ras=intf_ras, post_proc_pc=intf_pc,n_kdim=2,level_increase=0)\n# or\nintf_plot = pc_plot(rslc_pyramid_dir,post_proc_ras='intf_all', post_proc_pc='intf_all',n_kdim=2,level_increase=0)\n\nAdd annotations:\n\nintf_plot = intf_plot.redim(i=hv.Dimension('i', label='Reference Image', range=(0,16), value_format=(lambda i: dates[i])),\n                            j=hv.Dimension('j', label='Secondary Image', range=(0,16), value_format=(lambda i: dates[i])),\n                            x=hv.Dimension('r', label='Range'), y=hv.Dimension('az',label='Azimuth'), z=hv.Dimension('Phase',range=(-np.pi,np.pi)))\n\nSpecify plotting options and plot:\n\nhv.output(widget_location='bottom')\nintf_plot.opts(opts.Image(cmap='colorwheel',width=600, height=400, colorbar=True,\n                          default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],\n                          active_tools=['wheel_zoom']\n                         ),\n              opts.Points(color='Phase', cmap='colorwheel',width=600, height=400, colorbar=True,\n                         # invert_yaxis=True, \n                         default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],\n                         active_tools=['wheel_zoom']\n                        )\n              )",
    "crumbs": [
      "CLI",
      "plot"
    ]
  },
  {
    "objectID": "CLI/dask_.html",
    "href": "CLI/dask_.html",
    "title": "dask",
    "section": "",
    "text": "source\n\nparallel_read_zarr\n\n parallel_read_zarr (data_zarr, slices, thread_pool_size=None,\n                     fill_slice=True)\n\n\nrslc_path = '/users/kangl/work/insar_denoising/NorthDallas_34_105_2019_ascending/moraine/load_data/rslc.zarr/'\nrslc_zarr = zarr.open(rslc_path,mode='r')\n\n\nrslc_zarr.shape\n\n(13165, 68467, 27)\n\n\n\nrslc_zarr.chunks\n\n(50, 68467, 1)\n\n\n\ndata_path = './dask_/data.zarr'\ndata_zarr = zarr.open(data_path,mode='r')\n\n\nout = parallel_read_zarr(data_zarr,(slice(0,13165),slice(0,68467),slice(0,1)))\n\nCPU times: user 18.8 s, sys: 5.84 s, total: 24.6 s\nWall time: 1.69 s\n\n\n\nout = data_zarr[:,:,0:1]\n\nCPU times: user 17 s, sys: 1.83 s, total: 18.8 s\nWall time: 2.27 s\n\n\n\nout = parallel_read_zarr(rslc_zarr,(slice(0,13165),slice(0,68467),slice(0,1)))\n\nCPU times: user 5.01 s, sys: 6.06 s, total: 11.1 s\nWall time: 1.32 s\n\n\n\nout = rslc_zarr[:,:,0:1]\n\nCPU times: user 3.36 s, sys: 2.4 s, total: 5.76 s\nWall time: 1.49 s\n\n\n\n# test with 128 core to see if parallel read really accelerate\n# in version 2, parallel_read takes 760 ms, directly read takes 3.5 s\n# 目前还是不是很清楚为什么升级到v3以后速度上有这些差异， \n# v2版本的数据为什么直接读取速度会比v3快？\n# 为什么parallel read 不会取得明显的加速效果？\n# 这些问题都需要等待zarr v3 稳定以后再说，包括plot 要不要用sharding，暂时先搁置\n\n\nnp.testing.assert_array_equal(data_zarr[:,:,2:3],parallel_read_zarr(data_zarr,(slice(0,13165),slice(0,68467),slice(2,3))))\n\n\nnp.testing.assert_array_equal(data_zarr[345:3845,299:29394,2:3],parallel_read_zarr(data_zarr,(slice(345,3845),slice(299,29394),slice(2,3))))\n\n\nsource\n\n\ndask_from_zarr\n\n dask_from_zarr (data_path:str, parallel_dims:int|tuple=None,\n                 chunks:tuple=None)\n\n\ndata_darr = dask_from_zarr('dask_/data.zarr/',parallel_dims=(0,1))\ndata_darr\n\n\n\n\n\n\n\n\n\n\n\n\nArray\nChunk\n\n\n\n\nBytes\n26.86 GiB\n6.72 GiB\n\n\nShape\n(13165, 68467, 4)\n(13165, 68467, 1)\n\n\nDask graph\n4 chunks in 9 graph layers\n\n\nData type\ncomplex64 numpy.ndarray\n\n\n\n\n                               4 68467 13165\n\n\n\n\n\n\n\ndata_darr.visualize()\n\n\n\n\n\n\n\n\n\nrslc_darr = dask_from_zarr('raw/rslc.zarr/',chunks=(1000,1000,1))\nrslc_darr\n\n\n\n\n\n\n\n\n\n\n\n\nArray\nChunk\n\n\n\n\nBytes\n594.67 MiB\n7.63 MiB\n\n\nShape\n(2500, 1834, 17)\n(1000, 1000, 1)\n\n\nDask graph\n102 chunks in 214 graph layers\n\n\nData type\ncomplex64 numpy.ndarray\n\n\n\n\n                                                               17 1834 2500\n\n\n\n\n\n\n\nnp.testing.assert_array_equal(rslc_darr.compute(),zarr.open('raw/rslc.zarr',mode='r')[:])\n\n\nsource\n\n\ndask_from_zarr_overlap\n\n dask_from_zarr_overlap (data_path:str, chunks:tuple, depth:tuple)\n\n\nrslc_darr = dask_from_zarr('raw/rslc.zarr/',chunks=(1000,1000,2))\nrslc_overlap_darr_ = da.overlap.overlap(rslc_darr,depth=(5,5,0),boundary = {0:'none',1:'none',2:'none'})\nrslc_overlap_darr = dask_from_zarr_overlap('raw/rslc.zarr/',chunks=(1000,1000,2),depth=(5,5,0))\nrslc_overlap_darr\n\n\n\n\n\n\n\n\n\n\n\n\nArray\nChunk\n\n\n\n\nBytes\n602.70 MiB\n15.49 MiB\n\n\nShape\n(2520, 1844, 17)\n(1010, 1005, 2)\n\n\nDask graph\n54 chunks in 118 graph layers\n\n\nData type\ncomplex64 numpy.ndarray\n\n\n\n\n                                               17 1844 2520\n\n\n\n\n\n\n\nnp.testing.assert_array_equal(rslc_overlap_darr_.compute(),rslc_overlap_darr.compute())\n\n\npc_data1 = np.random.rand(32,10).astype(np.float32)\npc_data2 = np.random.rand(64,10).astype(np.float32)\n\npc_zarr1 = zarr.open('dask_/pc/1.zarr',mode='w',shape=pc_data1.shape,dtype=pc_data1.dtype,chunks=(32,1))\npc_zarr2 = zarr.open('dask_/pc/2.zarr',mode='w',shape=pc_data2.shape,dtype=pc_data2.dtype,chunks=(64,1))\npc_zarr1[:] = pc_data1\npc_zarr2[:] = pc_data2\n\n\nzarr_dir = ZarrDir.from_dir('dask_/pc')\nnp.testing.assert_array_equal(np.concatenate((pc_data1,pc_data2),axis=0)[:,2],_parallel_read_pc_dir(zarr_dir,2))\n\n\npc_darr = _dask_from_pc_zarr_dir('dask_/pc')\nnp.testing.assert_array_equal(np.concatenate((pc_data1,pc_data2),axis=0),pc_darr.compute())\n\n\nsource\n\n\nparallel_write_zarr\n\n parallel_write_zarr (data, data_zarr, slices, thread_pool_size=None,\n                      fill_slice=True)\n\n\nout_rslc_path = './dask_/rslc.zarr'\n#rslc_path = './dask_/data.zarr/'\nrslc_path = '/users/kangl/work/insar_denoising/NorthDallas_34_105_2019_ascending/moraine/load_data/rslc.zarr/'\nrslc_zarr = zarr.open(rslc_path,mode='r')\none_rslc = rslc_zarr[slice(0,13165),slice(0,68467),slice(0,1)]\n\n\nout_rslc_zarr = zarr.open(out_rslc_path,mode='w',shape=rslc_zarr.shape,dtype=rslc_zarr.dtype,chunks=rslc_zarr.chunks)\n\n\nout_rslc_zarr[slice(0,13165),slice(0,68467),slice(0,1)] = one_rslc\n\nCPU times: user 10.8 s, sys: 4.69 s, total: 15.5 s\nWall time: 2.06 s\n\n\n\nparallel_write_zarr(one_rslc,out_rslc_zarr,(slice(0,13165),slice(0,68467),slice(0,1)))\n\nCPU times: user 11.2 s, sys: 11.1 s, total: 22.4 s\nWall time: 1.81 s\n\n\n\n# also test here\n# 但是现在看起来用不用parallel对于速度没啥大的影响\n\n\nsource\n\n\ndask_to_zarr\n\n dask_to_zarr (data_darr, url, chunks, path=None, log_zarr=True)\n\n\nrslc_darr = dask_from_zarr('raw/rslc.zarr/',parallel_dims=(1,2))\n\n\nrslc_darr = rslc_darr.persist()\n\n\nrslc_darr.visualize()\n\n\n\n\n\n\n\n\n\nrslc_darr\n\n\n\n\n\n\n\n\n\n\n\n\nArray\nChunk\n\n\n\n\nBytes\n594.67 MiB\n237.87 MiB\n\n\nShape\n(2500, 1834, 17)\n(1000, 1834, 17)\n\n\nDask graph\n3 chunks in 1 graph layer\n\n\nData type\ncomplex64 numpy.ndarray\n\n\n\n\n                             17 1834 2500\n\n\n\n\n\n\n\nout_delayed = dask_to_zarr(rslc_darr,'./dask_/rslc.zarr/',chunks=(rslc_darr.chunksize[0],rslc_darr.shape[1],1))\n\n\nda.compute(out_delayed)\n\n(array([], dtype=float64),)\n\n\n\nnp.testing.assert_array_equal(zarr.open('./dask_/rslc.zarr',mode='r')[:], zarr.open('./raw/rslc.zarr',mode='r')[:])"
  },
  {
    "objectID": "CLI/pc.html",
    "href": "CLI/pc.html",
    "title": "pc",
    "section": "",
    "text": "import zarr\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport moraine.cli as mc\nimport moraine as mr\n\n\nsource\n\ngix2bool\n\n gix2bool (gix:str, is_pc:str, shape:tuple[int], chunks:tuple[int]=(1000,\n           1000))\n\nConvert pc grid index to bool 2d array\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ngix\nstr\n\npoint cloud grid index\n\n\nis_pc\nstr\n\noutput, output bool array\n\n\nshape\ntuple\n\nshape of one image (nlines,width)\n\n\nchunks\ntuple\n(1000, 1000)\noutput chunk size\n\n\n\n\nsource\n\n\nbool2gix\n\n bool2gix (is_pc:str, gix:str, chunks:int=100000)\n\nConvert bool 2d array to grid index\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nis_pc\nstr\n\ninput bool array\n\n\ngix\nstr\n\noutput, point cloud grid index\n\n\nchunks\nint\n100000\noutput point chunk size\n\n\n\n\nsource\n\n\nras2pc\n\n ras2pc (idx:str, ras:str|list, pc:str|list, chunks:int=None,\n         processes=False, n_workers=1, threads_per_worker=1,\n         **dask_cluster_arg)\n\nConvert raster data to point cloud data\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nidx\nstr\n\npoint cloud grid index or hillbert index\n\n\nras\nstr | list\n\npath (in string) or list of path for raster data\n\n\npc\nstr | list\n\noutput, path (in string) or list of path for point cloud data\n\n\nchunks\nint\nNone\noutput point chunk size, same as gix by default\n\n\nprocesses\nbool\nFalse\nuse process for dask worker or thread\n\n\nn_workers\nint\n1\nnumber of dask worker\n\n\nthreads_per_worker\nint\n1\nnumber of threads per dask worker\n\n\ndask_cluster_arg\nVAR_KEYWORD\n\n\n\n\n\nUsage:\n\nlogger = mc.get_logger()\n\n\nras_data1 = np.random.rand(100,100).astype(np.float32)\nras_data2 = np.random.rand(100,100,3).astype(np.float32)+1j*np.random.rand(100,100,3).astype(np.float32)\n\ngix = np.random.choice(np.arange(100*100,dtype=np.int32),size=1000,replace=False)\ngix.sort()\ngix = np.stack(np.unravel_index(gix,shape=(100,100)),axis=-1).astype(np.int32)\n\npc_data1 = ras_data1[gix[:,0],gix[:,1]]\npc_data2 = ras_data2[gix[:,0],gix[:,1]]\n\ngix_zarr = zarr.open('pc/gix.zarr',mode='w',shape=gix.shape,dtype=gix.dtype,chunks=(200,1))\nras_zarr1 = zarr.open('pc/ras1.zarr',mode='w',shape=ras_data1.shape,dtype=ras_data1.dtype,chunks=(20,100))\nras_zarr2 = zarr.open('pc/ras2.zarr',mode='w',shape=ras_data2.shape,dtype=ras_data2.dtype,chunks=(20,100,1))\ngix_zarr[:] = gix\nras_zarr1[:] = ras_data1\nras_zarr2[:] = ras_data2\n\n\nras2pc('pc/gix.zarr','pc/ras1.zarr','pc/pc1.zarr')\npc_zarr1 = zarr.open('pc/pc1.zarr',mode='r')\nnp.testing.assert_array_equal(pc_data1,pc_zarr1[:])\n\nras2pc('pc/gix.zarr',ras=['pc/ras1.zarr','pc/ras2.zarr'],pc=['pc/pc1.zarr','pc/pc2.zarr'])\npc_zarr1 = zarr.open('pc/pc1.zarr',mode='r')\npc_zarr2 = zarr.open('pc/pc2.zarr',mode='r')\nnp.testing.assert_array_equal(pc_data1,pc_zarr1[:])\nnp.testing.assert_array_equal(pc_data2,pc_zarr2[:])\n\n2025-09-18 12:28:18 - log_args - INFO - running function: ras2pc\n2025-09-18 12:28:18 - log_args - INFO - fetching args:\n2025-09-18 12:28:18 - log_args - INFO - idx = 'pc/gix.zarr'\n2025-09-18 12:28:18 - log_args - INFO - ras = 'pc/ras1.zarr'\n2025-09-18 12:28:18 - log_args - INFO - pc = 'pc/pc1.zarr'\n2025-09-18 12:28:18 - log_args - INFO - chunks = None\n2025-09-18 12:28:18 - log_args - INFO - processes = False\n2025-09-18 12:28:18 - log_args - INFO - n_workers = 1\n2025-09-18 12:28:18 - log_args - INFO - threads_per_worker = 1\n2025-09-18 12:28:18 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 12:28:18 - log_args - INFO - fetching args done.\n2025-09-18 12:28:18 - zarr_info - INFO - pc/gix.zarr zarray shape, chunks, dtype: (1000, 2), (200, 1), int32\n2025-09-18 12:28:18 - ras2pc - INFO - loading gix into memory.\n2025-09-18 12:28:18 - ras2pc - INFO - starting dask local cluster.\n2025-09-18 12:28:20 - ras2pc - INFO - dask local cluster started.\n2025-09-18 12:28:20 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.4:8787/status', workers=1, threads=1, memory=256.00 GiB)\n2025-09-18 12:28:20 - ras2pc - INFO - start to slice on pc/ras1.zarr\n2025-09-18 12:28:20 - zarr_info - INFO - pc/ras1.zarr zarray shape, chunks, dtype: (100, 100), (20, 100), float32\n2025-09-18 12:28:20 - darr_info - INFO - ras dask array shape, chunksize, dtype: (100, 100), (100, 100), float32\n2025-09-18 12:28:20 - darr_info - INFO - pc dask array shape, chunksize, dtype: (1000,), (1000,), float32\n2025-09-18 12:28:20 - ras2pc - INFO - saving to pc/pc1.zarr.\n2025-09-18 12:28:20 - zarr_info - INFO - pc/pc1.zarr zarray shape, chunks, dtype: (1000,), (200,), float32\n2025-09-18 12:28:20 - ras2pc - INFO - computing graph setted. doing all the computing.\n2025-09-18 12:28:21 - ras2pc - INFO - computing finished.ed |  0.1s\n2025-09-18 12:28:21 - ras2pc - INFO - dask cluster closed.\n2025-09-18 12:28:21 - log_args - INFO - running function: ras2pc\n2025-09-18 12:28:21 - log_args - INFO - fetching args:\n2025-09-18 12:28:21 - log_args - INFO - idx = 'pc/gix.zarr'\n2025-09-18 12:28:21 - log_args - INFO - ras = ['pc/ras1.zarr', 'pc/ras2.zarr']\n2025-09-18 12:28:21 - log_args - INFO - pc = ['pc/pc1.zarr', 'pc/pc2.zarr']\n2025-09-18 12:28:21 - log_args - INFO - chunks = None\n2025-09-18 12:28:21 - log_args - INFO - processes = False\n2025-09-18 12:28:21 - log_args - INFO - n_workers = 1\n2025-09-18 12:28:21 - log_args - INFO - threads_per_worker = 1\n2025-09-18 12:28:21 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 12:28:21 - log_args - INFO - fetching args done.\n2025-09-18 12:28:21 - zarr_info - INFO - pc/gix.zarr zarray shape, chunks, dtype: (1000, 2), (200, 1), int32\n2025-09-18 12:28:21 - ras2pc - INFO - loading gix into memory.\n2025-09-18 12:28:21 - ras2pc - INFO - starting dask local cluster.\n2025-09-18 12:28:21 - ras2pc - INFO - dask local cluster started.\n2025-09-18 12:28:21 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.4:8787/status', workers=1, threads=1, memory=256.00 GiB)\n2025-09-18 12:28:21 - ras2pc - INFO - start to slice on pc/ras1.zarr\n2025-09-18 12:28:21 - zarr_info - INFO - pc/ras1.zarr zarray shape, chunks, dtype: (100, 100), (20, 100), float32\n2025-09-18 12:28:21 - darr_info - INFO - ras dask array shape, chunksize, dtype: (100, 100), (100, 100), float32\n2025-09-18 12:28:21 - darr_info - INFO - pc dask array shape, chunksize, dtype: (1000,), (1000,), float32\n2025-09-18 12:28:21 - ras2pc - INFO - saving to pc/pc1.zarr.\n2025-09-18 12:28:21 - zarr_info - INFO - pc/pc1.zarr zarray shape, chunks, dtype: (1000,), (200,), float32\n2025-09-18 12:28:21 - ras2pc - INFO - start to slice on pc/ras2.zarr\n2025-09-18 12:28:21 - zarr_info - INFO - pc/ras2.zarr zarray shape, chunks, dtype: (100, 100, 3), (20, 100, 1), complex64\n2025-09-18 12:28:21 - darr_info - INFO - ras dask array shape, chunksize, dtype: (100, 100, 3), (100, 100, 1), complex64\n2025-09-18 12:28:21 - darr_info - INFO - pc dask array shape, chunksize, dtype: (1000, 3), (1000, 1), complex64\n2025-09-18 12:28:21 - ras2pc - INFO - saving to pc/pc2.zarr.\n2025-09-18 12:28:21 - zarr_info - INFO - pc/pc2.zarr zarray shape, chunks, dtype: (1000, 3), (200, 1), complex64\n2025-09-18 12:28:21 - ras2pc - INFO - computing graph setted. doing all the computing.\n2025-09-18 12:28:21 - ras2pc - INFO - computing finished.ed |  0.1s\n2025-09-18 12:28:21 - ras2pc - INFO - dask cluster closed.\n\n\n\nsource\n\n\npc_concat\n\n pc_concat (pcs:list|str, pc:list|str, key:list|str=None, chunks:int=None,\n            processes=False, n_workers=1, threads_per_worker=1,\n            **dask_cluster_arg)\n\nconcatenate (and sort) point cloud dataset.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\npcs\nlist | str\n\nlist of path to pc or directory that hold one pc, or a list of that\n\n\npc\nlist | str\n\noutput, path of output or a list of that\n\n\nkey\nlist | str\nNone\nkeys that sort the pc data, no sort by default\n\n\nchunks\nint\nNone\npc chunk size in output data, optional, same as first pc in pcs by default\n\n\nprocesses\nbool\nFalse\nuse process for dask worker or thread\n\n\nn_workers\nint\n1\nnumber of dask worker\n\n\nthreads_per_worker\nint\n1\nnumber of threads per dask worker\n\n\ndask_cluster_arg\nVAR_KEYWORD\n\n\n\n\n\n\npc_data = np.random.rand(1000,3).astype(np.float32)+1j*np.random.rand(1000,3).astype(np.float32)\npc1_zarr = zarr.open('pc/pc1.zarr',mode='w',shape=(300,3),dtype=pc_data.dtype,chunks=(300,1))\npc2_zarr = zarr.open('pc/pc2.zarr',mode='w',shape=(700,3),dtype=pc_data.dtype,chunks=(700,1))\npc1_zarr[:] = pc_data[:300]\npc2_zarr[:] = pc_data[300:]\n\n\npc_concat(['pc/pc1.zarr','pc/pc2.zarr'],'pc/pc.zarr',chunks=500)\nnp.testing.assert_array_equal(zarr.open('pc/pc.zarr',mode='r')[:],pc_data)\n\n2025-09-18 12:28:21 - log_args - INFO - running function: pc_concat\n2025-09-18 12:28:21 - log_args - INFO - fetching args:\n2025-09-18 12:28:21 - log_args - INFO - pcs = ['pc/pc1.zarr', 'pc/pc2.zarr']\n2025-09-18 12:28:21 - log_args - INFO - pc = 'pc/pc.zarr'\n2025-09-18 12:28:21 - log_args - INFO - key = None\n2025-09-18 12:28:21 - log_args - INFO - chunks = 500\n2025-09-18 12:28:21 - log_args - INFO - processes = False\n2025-09-18 12:28:21 - log_args - INFO - n_workers = 1\n2025-09-18 12:28:21 - log_args - INFO - threads_per_worker = 1\n2025-09-18 12:28:21 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 12:28:21 - log_args - INFO - fetching args done.\n2025-09-18 12:28:21 - pc_concat - INFO - input pcs: [['pc/pc1.zarr', 'pc/pc2.zarr']]\n2025-09-18 12:28:21 - pc_concat - INFO - output pc: ['pc/pc.zarr']\n2025-09-18 12:28:21 - pc_concat - INFO - starting dask local cluster.\n2025-09-18 12:28:21 - pc_concat - INFO - dask local cluster started.\n2025-09-18 12:28:21 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.4:8787/status', workers=1, threads=1, memory=256.00 GiB)\n2025-09-18 12:28:21 - pc_concat - INFO - read pc from ['pc/pc1.zarr', 'pc/pc2.zarr']\n2025-09-18 12:28:21 - darr_info - INFO - concatenated pc dask array shape, chunksize, dtype: (1000, 3), (1000, 1), complex64\n2025-09-18 12:28:21 - pc_concat - INFO - save pc to pc/pc.zarr\n2025-09-18 12:28:21 - zarr_info - INFO - pc/pc.zarr zarray shape, chunks, dtype: (1000, 3), (500, 1), complex64\n2025-09-18 12:28:21 - pc_concat - INFO - computing graph setted. doing all the computing.\n2025-09-18 12:28:21 - pc_concat - INFO - computing finished.|  0.1s\n2025-09-18 12:28:21 - pc_concat - INFO - dask cluster closed.\n\n\n\nsource\n\n\nras2pc_ras_chunk\n\n ras2pc_ras_chunk (gix:str, ras:str|list, pc:str|list, key:str,\n                   chunks:tuple=None, processes=False, n_workers=1,\n                   threads_per_worker=1, **dask_cluster_arg)\n\nConvert raster data to point cloud data that sorted by ras chunk\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ngix\nstr\n\npoint cloud grid index\n\n\nras\nstr | list\n\npath (in string) or list of path for raster data\n\n\npc\nstr | list\n\noutput, path (directory) or list of path for point cloud data\n\n\nkey\nstr\n\noutput, path for the key to sort generated pc in the directory back to gix order\n\n\nchunks\ntuple\nNone\nras chunks, same as the first ras by default\n\n\nprocesses\nbool\nFalse\nuse process for dask worker or thread\n\n\nn_workers\nint\n1\nnumber of dask worker\n\n\nthreads_per_worker\nint\n1\nnumber of threads per dask worker\n\n\ndask_cluster_arg\nVAR_KEYWORD\n\n\n\n\n\n\nras2pc_ras_chunk('pc/gix.zarr','pc/ras1.zarr','pc/pc1',key='pc/key.zarr')\npc_concat('pc/pc1','pc/pc1.zarr',key='pc/key.zarr',chunks=200)\npc_zarr1 = zarr.open('pc/pc1.zarr',mode='r')\nnp.testing.assert_array_equal(pc_data1,pc_zarr1[:])\n\nras2pc_ras_chunk('pc/gix.zarr',ras=['pc/ras1.zarr','pc/ras2.zarr'],pc=['pc/pc1','pc/pc2'],key='pc/key.zarr')\npc_concat('pc/pc1','pc/pc1.zarr',key='pc/key.zarr',chunks=200)\npc_concat('pc/pc2','pc/pc2.zarr',key='pc/key.zarr',chunks=200)\npc_zarr1 = zarr.open('pc/pc1.zarr',mode='r')\npc_zarr2 = zarr.open('pc/pc2.zarr',mode='r')\nnp.testing.assert_array_equal(pc_data1,pc_zarr1[:])\nnp.testing.assert_array_equal(pc_data2,pc_zarr2[:])\n\n2025-09-18 12:28:21 - log_args - INFO - running function: ras2pc_ras_chunk\n2025-09-18 12:28:21 - log_args - INFO - fetching args:\n2025-09-18 12:28:21 - log_args - INFO - gix = 'pc/gix.zarr'\n2025-09-18 12:28:21 - log_args - INFO - ras = 'pc/ras1.zarr'\n2025-09-18 12:28:21 - log_args - INFO - pc = 'pc/pc1'\n2025-09-18 12:28:21 - log_args - INFO - key = 'pc/key.zarr'\n2025-09-18 12:28:21 - log_args - INFO - chunks = None\n2025-09-18 12:28:21 - log_args - INFO - processes = False\n2025-09-18 12:28:21 - log_args - INFO - n_workers = 1\n2025-09-18 12:28:21 - log_args - INFO - threads_per_worker = 1\n2025-09-18 12:28:21 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 12:28:21 - log_args - INFO - fetching args done.\n2025-09-18 12:28:21 - zarr_info - INFO - pc/gix.zarr zarray shape, chunks, dtype: (1000, 2), (200, 1), int32\n2025-09-18 12:28:21 - ras2pc_ras_chunk - INFO - loading gix into memory.\n2025-09-18 12:28:21 - ras2pc_ras_chunk - INFO - convert gix to the order of ras chunk\n2025-09-18 12:28:28 - ras2pc_ras_chunk - INFO - save key\n2025-09-18 12:28:28 - ras2pc_ras_chunk - INFO - starting dask local cluster.\n2025-09-18 12:28:29 - ras2pc_ras_chunk - INFO - dask local cluster started.\n2025-09-18 12:28:29 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.4:8787/status', workers=1, threads=1, memory=256.00 GiB)\n2025-09-18 12:28:29 - ras2pc_ras_chunk - INFO - start to slice on pc/ras1.zarr\n2025-09-18 12:28:29 - zarr_info - INFO - pc/ras1.zarr zarray shape, chunks, dtype: (100, 100), (20, 20), float32\n2025-09-18 12:28:29 - darr_info - INFO - ras dask array shape, chunksize, dtype: (100, 100), (20, 20), float32\n2025-09-18 12:28:29 - darr_info - INFO - pc dask array shape, chunksize, dtype: (1000,), (49,), float32\n2025-09-18 12:28:29 - ras2pc_ras_chunk - INFO - saving to pc/pc1.\n2025-09-18 12:28:29 - ras2pc_ras_chunk - INFO - computing graph setted. doing all the computing.\n2025-09-18 12:28:29 - ras2pc_ras_chunk - INFO - computing finished.\n2025-09-18 12:28:29 - ras2pc_ras_chunk - INFO - dask cluster closed.\n2025-09-18 12:28:29 - log_args - INFO - running function: pc_concat\n2025-09-18 12:28:29 - log_args - INFO - fetching args:\n2025-09-18 12:28:29 - log_args - INFO - pcs = 'pc/pc1'\n2025-09-18 12:28:29 - log_args - INFO - pc = 'pc/pc1.zarr'\n2025-09-18 12:28:29 - log_args - INFO - key = 'pc/key.zarr'\n2025-09-18 12:28:29 - log_args - INFO - chunks = 200\n2025-09-18 12:28:29 - log_args - INFO - processes = False\n2025-09-18 12:28:29 - log_args - INFO - n_workers = 1\n2025-09-18 12:28:29 - log_args - INFO - threads_per_worker = 1\n2025-09-18 12:28:29 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 12:28:29 - log_args - INFO - fetching args done.\n2025-09-18 12:28:29 - pc_concat - INFO - input pcs: [[Path('pc/pc1/0.zarr'), Path('pc/pc1/1.zarr'), Path('pc/pc1/2.zarr'), Path('pc/pc1/3.zarr'), Path('pc/pc1/4.zarr'), Path('pc/pc1/5.zarr'), Path('pc/pc1/6.zarr'), Path('pc/pc1/7.zarr'), Path('pc/pc1/8.zarr'), Path('pc/pc1/9.zarr'), Path('pc/pc1/10.zarr'), Path('pc/pc1/11.zarr'), Path('pc/pc1/12.zarr'), Path('pc/pc1/13.zarr'), Path('pc/pc1/14.zarr'), Path('pc/pc1/15.zarr'), Path('pc/pc1/16.zarr'), Path('pc/pc1/17.zarr'), Path('pc/pc1/18.zarr'), Path('pc/pc1/19.zarr'), Path('pc/pc1/20.zarr'), Path('pc/pc1/21.zarr'), Path('pc/pc1/22.zarr'), Path('pc/pc1/23.zarr'), Path('pc/pc1/24.zarr')]]\n2025-09-18 12:28:29 - pc_concat - INFO - output pc: ['pc/pc1.zarr']\n2025-09-18 12:28:29 - pc_concat - INFO - load key\n2025-09-18 12:28:29 - zarr_info - INFO - pc/key.zarr zarray shape, chunks, dtype: (1000,), (200,), int64\n2025-09-18 12:28:30 - pc_concat - INFO - starting dask local cluster.\n2025-09-18 12:28:30 - pc_concat - INFO - dask local cluster started.\n2025-09-18 12:28:30 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.4:8787/status', workers=1, threads=1, memory=256.00 GiB)\n2025-09-18 12:28:30 - pc_concat - INFO - read pc from [Path('pc/pc1/0.zarr'), Path('pc/pc1/1.zarr'), Path('pc/pc1/2.zarr'), Path('pc/pc1/3.zarr'), Path('pc/pc1/4.zarr'), Path('pc/pc1/5.zarr'), Path('pc/pc1/6.zarr'), Path('pc/pc1/7.zarr'), Path('pc/pc1/8.zarr'), Path('pc/pc1/9.zarr'), Path('pc/pc1/10.zarr'), Path('pc/pc1/11.zarr'), Path('pc/pc1/12.zarr'), Path('pc/pc1/13.zarr'), Path('pc/pc1/14.zarr'), Path('pc/pc1/15.zarr'), Path('pc/pc1/16.zarr'), Path('pc/pc1/17.zarr'), Path('pc/pc1/18.zarr'), Path('pc/pc1/19.zarr'), Path('pc/pc1/20.zarr'), Path('pc/pc1/21.zarr'), Path('pc/pc1/22.zarr'), Path('pc/pc1/23.zarr'), Path('pc/pc1/24.zarr')]\n2025-09-18 12:28:30 - darr_info - INFO - concatenated pc dask array shape, chunksize, dtype: (1000,), (1000,), float32\n2025-09-18 12:28:30 - pc_concat - INFO - sort pc according to key\n2025-09-18 12:28:30 - darr_info - INFO - sorted pc dask array shape, chunksize, dtype: (1000,), (1000,), float32\n2025-09-18 12:28:30 - pc_concat - INFO - save pc to pc/pc1.zarr\n2025-09-18 12:28:30 - zarr_info - INFO - pc/pc1.zarr zarray shape, chunks, dtype: (1000,), (200,), float32\n2025-09-18 12:28:30 - pc_concat - INFO - computing graph setted. doing all the computing.\n2025-09-18 12:28:30 - pc_concat - INFO - computing finished.|  0.1s\n2025-09-18 12:28:30 - pc_concat - INFO - dask cluster closed.\n2025-09-18 12:28:30 - log_args - INFO - running function: ras2pc_ras_chunk\n2025-09-18 12:28:30 - log_args - INFO - fetching args:\n2025-09-18 12:28:30 - log_args - INFO - gix = 'pc/gix.zarr'\n2025-09-18 12:28:30 - log_args - INFO - ras = ['pc/ras1.zarr', 'pc/ras2.zarr']\n2025-09-18 12:28:30 - log_args - INFO - pc = ['pc/pc1', 'pc/pc2']\n2025-09-18 12:28:30 - log_args - INFO - key = 'pc/key.zarr'\n2025-09-18 12:28:30 - log_args - INFO - chunks = None\n2025-09-18 12:28:30 - log_args - INFO - processes = False\n2025-09-18 12:28:30 - log_args - INFO - n_workers = 1\n2025-09-18 12:28:30 - log_args - INFO - threads_per_worker = 1\n2025-09-18 12:28:30 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 12:28:30 - log_args - INFO - fetching args done.\n2025-09-18 12:28:30 - zarr_info - INFO - pc/gix.zarr zarray shape, chunks, dtype: (1000, 2), (200, 1), int32\n2025-09-18 12:28:30 - ras2pc_ras_chunk - INFO - loading gix into memory.\n2025-09-18 12:28:30 - ras2pc_ras_chunk - INFO - convert gix to the order of ras chunk\n2025-09-18 12:28:30 - ras2pc_ras_chunk - INFO - save key\n2025-09-18 12:28:30 - ras2pc_ras_chunk - INFO - starting dask local cluster.\n2025-09-18 12:28:30 - ras2pc_ras_chunk - INFO - dask local cluster started.\n2025-09-18 12:28:30 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.4:8787/status', workers=1, threads=1, memory=256.00 GiB)\n2025-09-18 12:28:30 - ras2pc_ras_chunk - INFO - start to slice on pc/ras1.zarr\n2025-09-18 12:28:30 - zarr_info - INFO - pc/ras1.zarr zarray shape, chunks, dtype: (100, 100), (20, 20), float32\n2025-09-18 12:28:30 - darr_info - INFO - ras dask array shape, chunksize, dtype: (100, 100), (20, 20), float32\n2025-09-18 12:28:30 - darr_info - INFO - pc dask array shape, chunksize, dtype: (1000,), (49,), float32\n2025-09-18 12:28:30 - ras2pc_ras_chunk - INFO - saving to pc/pc1.\n2025-09-18 12:28:30 - ras2pc_ras_chunk - INFO - start to slice on pc/ras2.zarr\n2025-09-18 12:28:30 - zarr_info - INFO - pc/ras2.zarr zarray shape, chunks, dtype: (100, 100, 3), (20, 20, 1), complex64\n2025-09-18 12:28:30 - darr_info - INFO - ras dask array shape, chunksize, dtype: (100, 100, 3), (20, 20, 3), complex64\n2025-09-18 12:28:30 - darr_info - INFO - pc dask array shape, chunksize, dtype: (1000, 3), (49, 3), complex64\n2025-09-18 12:28:30 - ras2pc_ras_chunk - INFO - saving to pc/pc2.\n2025-09-18 12:28:31 - ras2pc_ras_chunk - INFO - computing graph setted. doing all the computing.\n2025-09-18 12:28:32 - ras2pc_ras_chunk - INFO - computing finished.\n2025-09-18 12:28:32 - ras2pc_ras_chunk - INFO - dask cluster closed.\n2025-09-18 12:28:32 - log_args - INFO - running function: pc_concat\n2025-09-18 12:28:32 - log_args - INFO - fetching args:\n2025-09-18 12:28:32 - log_args - INFO - pcs = 'pc/pc1'\n2025-09-18 12:28:32 - log_args - INFO - pc = 'pc/pc1.zarr'\n2025-09-18 12:28:32 - log_args - INFO - key = 'pc/key.zarr'\n2025-09-18 12:28:32 - log_args - INFO - chunks = 200\n2025-09-18 12:28:32 - log_args - INFO - processes = False\n2025-09-18 12:28:32 - log_args - INFO - n_workers = 1\n2025-09-18 12:28:32 - log_args - INFO - threads_per_worker = 1\n2025-09-18 12:28:32 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 12:28:32 - log_args - INFO - fetching args done.\n2025-09-18 12:28:32 - pc_concat - INFO - input pcs: [[Path('pc/pc1/0.zarr'), Path('pc/pc1/1.zarr'), Path('pc/pc1/2.zarr'), Path('pc/pc1/3.zarr'), Path('pc/pc1/4.zarr'), Path('pc/pc1/5.zarr'), Path('pc/pc1/6.zarr'), Path('pc/pc1/7.zarr'), Path('pc/pc1/8.zarr'), Path('pc/pc1/9.zarr'), Path('pc/pc1/10.zarr'), Path('pc/pc1/11.zarr'), Path('pc/pc1/12.zarr'), Path('pc/pc1/13.zarr'), Path('pc/pc1/14.zarr'), Path('pc/pc1/15.zarr'), Path('pc/pc1/16.zarr'), Path('pc/pc1/17.zarr'), Path('pc/pc1/18.zarr'), Path('pc/pc1/19.zarr'), Path('pc/pc1/20.zarr'), Path('pc/pc1/21.zarr'), Path('pc/pc1/22.zarr'), Path('pc/pc1/23.zarr'), Path('pc/pc1/24.zarr')]]\n2025-09-18 12:28:32 - pc_concat - INFO - output pc: ['pc/pc1.zarr']\n2025-09-18 12:28:32 - pc_concat - INFO - load key\n2025-09-18 12:28:32 - zarr_info - INFO - pc/key.zarr zarray shape, chunks, dtype: (1000,), (200,), int64\n2025-09-18 12:28:32 - pc_concat - INFO - starting dask local cluster.\n2025-09-18 12:28:32 - pc_concat - INFO - dask local cluster started.\n2025-09-18 12:28:32 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.4:8787/status', workers=1, threads=1, memory=256.00 GiB)\n2025-09-18 12:28:32 - pc_concat - INFO - read pc from [Path('pc/pc1/0.zarr'), Path('pc/pc1/1.zarr'), Path('pc/pc1/2.zarr'), Path('pc/pc1/3.zarr'), Path('pc/pc1/4.zarr'), Path('pc/pc1/5.zarr'), Path('pc/pc1/6.zarr'), Path('pc/pc1/7.zarr'), Path('pc/pc1/8.zarr'), Path('pc/pc1/9.zarr'), Path('pc/pc1/10.zarr'), Path('pc/pc1/11.zarr'), Path('pc/pc1/12.zarr'), Path('pc/pc1/13.zarr'), Path('pc/pc1/14.zarr'), Path('pc/pc1/15.zarr'), Path('pc/pc1/16.zarr'), Path('pc/pc1/17.zarr'), Path('pc/pc1/18.zarr'), Path('pc/pc1/19.zarr'), Path('pc/pc1/20.zarr'), Path('pc/pc1/21.zarr'), Path('pc/pc1/22.zarr'), Path('pc/pc1/23.zarr'), Path('pc/pc1/24.zarr')]\n2025-09-18 12:28:32 - darr_info - INFO - concatenated pc dask array shape, chunksize, dtype: (1000,), (1000,), float32\n2025-09-18 12:28:32 - pc_concat - INFO - sort pc according to key\n2025-09-18 12:28:32 - darr_info - INFO - sorted pc dask array shape, chunksize, dtype: (1000,), (1000,), float32\n2025-09-18 12:28:32 - pc_concat - INFO - save pc to pc/pc1.zarr\n2025-09-18 12:28:32 - zarr_info - INFO - pc/pc1.zarr zarray shape, chunks, dtype: (1000,), (200,), float32\n2025-09-18 12:28:32 - pc_concat - INFO - computing graph setted. doing all the computing.\n2025-09-18 12:28:32 - pc_concat - INFO - computing finished.|  0.1s\n2025-09-18 12:28:32 - pc_concat - INFO - dask cluster closed.\n2025-09-18 12:28:32 - log_args - INFO - running function: pc_concat\n2025-09-18 12:28:32 - log_args - INFO - fetching args:\n2025-09-18 12:28:32 - log_args - INFO - pcs = 'pc/pc2'\n2025-09-18 12:28:32 - log_args - INFO - pc = 'pc/pc2.zarr'\n2025-09-18 12:28:32 - log_args - INFO - key = 'pc/key.zarr'\n2025-09-18 12:28:32 - log_args - INFO - chunks = 200\n2025-09-18 12:28:32 - log_args - INFO - processes = False\n2025-09-18 12:28:32 - log_args - INFO - n_workers = 1\n2025-09-18 12:28:32 - log_args - INFO - threads_per_worker = 1\n2025-09-18 12:28:32 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 12:28:32 - log_args - INFO - fetching args done.\n2025-09-18 12:28:32 - pc_concat - INFO - input pcs: [[Path('pc/pc2/0.zarr'), Path('pc/pc2/1.zarr'), Path('pc/pc2/2.zarr'), Path('pc/pc2/3.zarr'), Path('pc/pc2/4.zarr'), Path('pc/pc2/5.zarr'), Path('pc/pc2/6.zarr'), Path('pc/pc2/7.zarr'), Path('pc/pc2/8.zarr'), Path('pc/pc2/9.zarr'), Path('pc/pc2/10.zarr'), Path('pc/pc2/11.zarr'), Path('pc/pc2/12.zarr'), Path('pc/pc2/13.zarr'), Path('pc/pc2/14.zarr'), Path('pc/pc2/15.zarr'), Path('pc/pc2/16.zarr'), Path('pc/pc2/17.zarr'), Path('pc/pc2/18.zarr'), Path('pc/pc2/19.zarr'), Path('pc/pc2/20.zarr'), Path('pc/pc2/21.zarr'), Path('pc/pc2/22.zarr'), Path('pc/pc2/23.zarr'), Path('pc/pc2/24.zarr')]]\n2025-09-18 12:28:32 - pc_concat - INFO - output pc: ['pc/pc2.zarr']\n2025-09-18 12:28:32 - pc_concat - INFO - load key\n2025-09-18 12:28:32 - zarr_info - INFO - pc/key.zarr zarray shape, chunks, dtype: (1000,), (200,), int64\n2025-09-18 12:28:32 - pc_concat - INFO - starting dask local cluster.\n2025-09-18 12:28:32 - pc_concat - INFO - dask local cluster started.\n2025-09-18 12:28:32 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.4:8787/status', workers=1, threads=1, memory=256.00 GiB)\n2025-09-18 12:28:32 - pc_concat - INFO - read pc from [Path('pc/pc2/0.zarr'), Path('pc/pc2/1.zarr'), Path('pc/pc2/2.zarr'), Path('pc/pc2/3.zarr'), Path('pc/pc2/4.zarr'), Path('pc/pc2/5.zarr'), Path('pc/pc2/6.zarr'), Path('pc/pc2/7.zarr'), Path('pc/pc2/8.zarr'), Path('pc/pc2/9.zarr'), Path('pc/pc2/10.zarr'), Path('pc/pc2/11.zarr'), Path('pc/pc2/12.zarr'), Path('pc/pc2/13.zarr'), Path('pc/pc2/14.zarr'), Path('pc/pc2/15.zarr'), Path('pc/pc2/16.zarr'), Path('pc/pc2/17.zarr'), Path('pc/pc2/18.zarr'), Path('pc/pc2/19.zarr'), Path('pc/pc2/20.zarr'), Path('pc/pc2/21.zarr'), Path('pc/pc2/22.zarr'), Path('pc/pc2/23.zarr'), Path('pc/pc2/24.zarr')]\n2025-09-18 12:28:32 - darr_info - INFO - concatenated pc dask array shape, chunksize, dtype: (1000, 3), (1000, 1), complex64\n2025-09-18 12:28:32 - pc_concat - INFO - sort pc according to key\n2025-09-18 12:28:32 - darr_info - INFO - sorted pc dask array shape, chunksize, dtype: (1000, 3), (1000, 1), complex64\n2025-09-18 12:28:32 - pc_concat - INFO - save pc to pc/pc2.zarr\n2025-09-18 12:28:32 - zarr_info - INFO - pc/pc2.zarr zarray shape, chunks, dtype: (1000, 3), (200, 1), complex64\n2025-09-18 12:28:32 - pc_concat - INFO - computing graph setted. doing all the computing.\n2025-09-18 12:28:33 - pc_concat - INFO - computing finished.|  0.2s\n2025-09-18 12:28:33 - pc_concat - INFO - dask cluster closed.\n\n\n\nsource\n\n\npc2ras\n\n pc2ras (idx:str, pc:str|list, ras:str|list, shape:tuple[int],\n         chunks:tuple[int]=(1000, 1000), processes=False, n_workers=1,\n         threads_per_worker=1, **dask_cluster_arg)\n\nConvert point cloud data to raster data, filled with nan\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nidx\nstr\n\npoint cloud grid index or hillbert index\n\n\npc\nstr | list\n\npath (in string) or list of path for point cloud data\n\n\nras\nstr | list\n\noutput, path (in string) or list of path for raster data\n\n\nshape\ntuple\n\nshape of one image (nlines,width)\n\n\nchunks\ntuple\n(1000, 1000)\noutput chunk size\n\n\nprocesses\nbool\nFalse\nuse process for dask worker or thread\n\n\nn_workers\nint\n1\nnumber of dask worker\n\n\nthreads_per_worker\nint\n1\nnumber of threads per dask worker\n\n\ndask_cluster_arg\nVAR_KEYWORD\n\n\n\n\n\nUsage:\n\npc_data1 = np.random.rand(1000).astype(np.float32)\npc_data2 = np.random.rand(1000,3).astype(np.float32)+1j*np.random.rand(1000,3).astype(np.float32)\n\ngix = np.random.choice(np.arange(100*100,dtype=np.int32),size=1000,replace=False)\ngix.sort()\ngix = np.stack(np.unravel_index(gix,shape=(100,100)),axis=-1).astype(np.int32)\n\nras_data1 = np.zeros((100,100),dtype=np.float32)\nras_data2 = np.zeros((100,100,3),dtype=np.complex64)\nras_data1[:] = np.nan\nras_data2[:] = np.nan\n\nras_data1[gix[:,0],gix[:,1]] = pc_data1\nras_data2[gix[:,0],gix[:,1]] = pc_data2\n\ngix_zarr = zarr.open('pc/gix.zarr',mode='w',shape=gix.shape,dtype=gix.dtype,chunks=(200,1))\npc_zarr1 = zarr.open('pc/pc1.zarr',mode='w',shape=pc_data1.shape,dtype=pc_data1.dtype,chunks=(200,))\npc_zarr2 = zarr.open('pc/pc2.zarr',mode='w',shape=pc_data2.shape,dtype=pc_data2.dtype,chunks=(200,1))\ngix_zarr[:] = gix\npc_zarr1[:] = pc_data1\npc_zarr2[:] = pc_data2\n\n\npc2ras('pc/gix.zarr','pc/pc1.zarr','pc/ras1.zarr',shape=(100,100),chunks=(20,100))\nras_zarr1 = zarr.open('pc/ras1.zarr',mode='r')\nnp.testing.assert_array_equal(ras_data1,ras_zarr1[:])\n\npc2ras('pc/gix.zarr',['pc/pc1.zarr','pc/pc2.zarr'],['pc/ras1.zarr','pc/ras2.zarr'],shape=(100,100),chunks=(20,100))\nras_zarr1 = zarr.open('pc/ras1.zarr',mode='r')\nras_zarr2 = zarr.open('pc/ras2.zarr',mode='r')\nnp.testing.assert_array_equal(ras_data1,ras_zarr1[:])\nnp.testing.assert_array_equal(ras_data2,ras_zarr2[:])\n\n2025-09-18 12:28:34 - log_args - INFO - running function: pc2ras\n2025-09-18 12:28:34 - log_args - INFO - fetching args:\n2025-09-18 12:28:34 - log_args - INFO - idx = 'pc/gix.zarr'\n2025-09-18 12:28:34 - log_args - INFO - pc = 'pc/pc1.zarr'\n2025-09-18 12:28:34 - log_args - INFO - ras = 'pc/ras1.zarr'\n2025-09-18 12:28:34 - log_args - INFO - shape = (100, 100)\n2025-09-18 12:28:34 - log_args - INFO - chunks = (20, 100)\n2025-09-18 12:28:34 - log_args - INFO - processes = False\n2025-09-18 12:28:34 - log_args - INFO - n_workers = 1\n2025-09-18 12:28:34 - log_args - INFO - threads_per_worker = 1\n2025-09-18 12:28:34 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 12:28:34 - log_args - INFO - fetching args done.\n2025-09-18 12:28:34 - zarr_info - INFO - pc/gix.zarr zarray shape, chunks, dtype: (1000, 2), (200, 1), int32\n2025-09-18 12:28:34 - pc2ras - INFO - loading gix into memory.\n2025-09-18 12:28:34 - pc2ras - INFO - starting dask local cluster.\n2025-09-18 12:28:34 - pc2ras - INFO - dask local cluster started.\n2025-09-18 12:28:34 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.4:8787/status', workers=1, threads=1, memory=256.00 GiB)\n2025-09-18 12:28:34 - pc2ras - INFO - start to work on pc/pc1.zarr\n2025-09-18 12:28:34 - zarr_info - INFO - pc/pc1.zarr zarray shape, chunks, dtype: (1000,), (200,), float32\n2025-09-18 12:28:34 - darr_info - INFO - pc dask array shape, chunksize, dtype: (1000,), (1000,), float32\n2025-09-18 12:28:34 - pc2ras - INFO - create ras dask array\n2025-09-18 12:28:34 - darr_info - INFO - ras dask array shape, chunksize, dtype: (100, 100), (100, 100), float32\n2025-09-18 12:28:34 - pc2ras - INFO - save ras to pc/ras1.zarr\n2025-09-18 12:28:34 - zarr_info - INFO - pc/ras1.zarr zarray shape, chunks, dtype: (100, 100), (20, 100), float32\n2025-09-18 12:28:34 - pc2ras - INFO - computing graph setted. doing all the computing.\n2025-09-18 12:28:34 - pc2ras - INFO - computing finished.ed |  0.1s\n2025-09-18 12:28:34 - pc2ras - INFO - dask cluster closed.\n2025-09-18 12:28:34 - log_args - INFO - running function: pc2ras\n2025-09-18 12:28:34 - log_args - INFO - fetching args:\n2025-09-18 12:28:34 - log_args - INFO - idx = 'pc/gix.zarr'\n2025-09-18 12:28:34 - log_args - INFO - pc = ['pc/pc1.zarr', 'pc/pc2.zarr']\n2025-09-18 12:28:34 - log_args - INFO - ras = ['pc/ras1.zarr', 'pc/ras2.zarr']\n2025-09-18 12:28:34 - log_args - INFO - shape = (100, 100)\n2025-09-18 12:28:34 - log_args - INFO - chunks = (20, 100)\n2025-09-18 12:28:34 - log_args - INFO - processes = False\n2025-09-18 12:28:34 - log_args - INFO - n_workers = 1\n2025-09-18 12:28:34 - log_args - INFO - threads_per_worker = 1\n2025-09-18 12:28:34 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 12:28:34 - log_args - INFO - fetching args done.\n2025-09-18 12:28:34 - zarr_info - INFO - pc/gix.zarr zarray shape, chunks, dtype: (1000, 2), (200, 1), int32\n2025-09-18 12:28:34 - pc2ras - INFO - loading gix into memory.\n2025-09-18 12:28:34 - pc2ras - INFO - starting dask local cluster.\n2025-09-18 12:28:34 - pc2ras - INFO - dask local cluster started.\n2025-09-18 12:28:34 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.4:8787/status', workers=1, threads=1, memory=256.00 GiB)\n2025-09-18 12:28:34 - pc2ras - INFO - start to work on pc/pc1.zarr\n2025-09-18 12:28:34 - zarr_info - INFO - pc/pc1.zarr zarray shape, chunks, dtype: (1000,), (200,), float32\n2025-09-18 12:28:34 - darr_info - INFO - pc dask array shape, chunksize, dtype: (1000,), (1000,), float32\n2025-09-18 12:28:34 - pc2ras - INFO - create ras dask array\n2025-09-18 12:28:34 - darr_info - INFO - ras dask array shape, chunksize, dtype: (100, 100), (100, 100), float32\n2025-09-18 12:28:34 - pc2ras - INFO - save ras to pc/ras1.zarr\n2025-09-18 12:28:34 - zarr_info - INFO - pc/ras1.zarr zarray shape, chunks, dtype: (100, 100), (20, 100), float32\n2025-09-18 12:28:34 - pc2ras - INFO - start to work on pc/pc2.zarr\n2025-09-18 12:28:34 - zarr_info - INFO - pc/pc2.zarr zarray shape, chunks, dtype: (1000, 3), (200, 1), complex64\n2025-09-18 12:28:34 - darr_info - INFO - pc dask array shape, chunksize, dtype: (1000, 3), (1000, 1), complex64\n2025-09-18 12:28:34 - pc2ras - INFO - create ras dask array\n2025-09-18 12:28:34 - darr_info - INFO - ras dask array shape, chunksize, dtype: (100, 100, 3), (100, 100, 1), complex64\n2025-09-18 12:28:34 - pc2ras - INFO - save ras to pc/ras2.zarr\n2025-09-18 12:28:34 - zarr_info - INFO - pc/ras2.zarr zarray shape, chunks, dtype: (100, 100, 3), (20, 100, 1), complex64\n2025-09-18 12:28:34 - pc2ras - INFO - computing graph setted. doing all the computing.\n2025-09-18 12:28:34 - pc2ras - INFO - computing finished.ed |  0.1s\n2025-09-18 12:28:34 - pc2ras - INFO - dask cluster closed.\n\n\n\nsource\n\n\npc_hix\n\n pc_hix (gix:str, hix:str, shape:tuple)\n\nCompute the hillbert index from grid index for point cloud data.\n\n\n\n\nType\nDetails\n\n\n\n\ngix\nstr\ngrid index\n\n\nhix\nstr\noutput, path\n\n\nshape\ntuple\n(nlines, width)\n\n\n\nUsage:\n\nbbox = [0,0,100,100]\ngix = np.random.choice(np.arange(100*100,dtype=np.int32),size=1000,replace=False)\ngix.sort()\ngix = np.stack(np.unravel_index(gix,shape=(100,100)),axis=-1).astype(np.int32)\ngix_zarr = zarr.open('pc/gix.zarr',mode='w',shape=gix.shape, chunks=(100,1),dtype=gix.dtype)\ngix_zarr[:] = gix\n\n\npc_hix('pc/gix.zarr', 'pc/hix.zarr',shape=(100,100))\n\n2025-09-18 12:28:34 - log_args - INFO - running function: pc_hix\n2025-09-18 12:28:34 - log_args - INFO - fetching args:\n2025-09-18 12:28:34 - log_args - INFO - gix = 'pc/gix.zarr'\n2025-09-18 12:28:34 - log_args - INFO - hix = 'pc/hix.zarr'\n2025-09-18 12:28:34 - log_args - INFO - shape = (100, 100)\n2025-09-18 12:28:34 - log_args - INFO - fetching args done.\n2025-09-18 12:28:34 - zarr_info - INFO - pc/gix.zarr zarray shape, chunks, dtype: (1000, 2), (100, 1), int32\n2025-09-18 12:28:34 - zarr_info - INFO - pc/hix.zarr zarray shape, chunks, dtype: (1000,), (100,), int64\n2025-09-18 12:28:34 - pc_hix - INFO - calculating the hillbert index based on grid index\n2025-09-18 12:28:36 - pc_hix - INFO - writing the hillbert index\n2025-09-18 12:28:36 - pc_hix - INFO - done.\n\n\n\nhix = zarr.open('pc/hix.zarr',mode='r')[:]\nplt.scatter(gix[:,1], gix[:,0], c=hix)\nplt.colorbar()\nplt.show()\n\n\n\n\n\n\n\n\n\nsource\n\n\npc_gix\n\n pc_gix (hix:str, gix:str, shape:tuple)\n\nCompute the hillbert index from grid index for point cloud data.\n\n\n\n\nType\nDetails\n\n\n\n\nhix\nstr\ngrid index\n\n\ngix\nstr\noutput, path\n\n\nshape\ntuple\n(nlines, width)\n\n\n\n\nbbox = [0,0,100,100]\ngix = np.random.choice(np.arange(100*100,dtype=np.int32),size=1000,replace=False)\ngix.sort()\ngix = np.stack(np.unravel_index(gix,shape=(100,100)),axis=-1).astype(np.int32)\ngix_zarr = zarr.open('pc/gix.zarr',mode='w',shape=gix.shape, chunks=(100,1),dtype=gix.dtype)\ngix_zarr[:] = gix\npc_hix('pc/gix.zarr', 'pc/hix.zarr',shape=(100,100))\npc_gix('pc/hix.zarr','pc/gix_.zarr', (100,100))\nnp.testing.assert_array_equal(zarr.open('pc/gix_.zarr',mode='r')[:], gix)\n\n2025-09-18 12:28:36 - log_args - INFO - running function: pc_hix\n2025-09-18 12:28:36 - log_args - INFO - fetching args:\n2025-09-18 12:28:36 - log_args - INFO - gix = 'pc/gix.zarr'\n2025-09-18 12:28:36 - log_args - INFO - hix = 'pc/hix.zarr'\n2025-09-18 12:28:36 - log_args - INFO - shape = (100, 100)\n2025-09-18 12:28:36 - log_args - INFO - fetching args done.\n2025-09-18 12:28:36 - zarr_info - INFO - pc/gix.zarr zarray shape, chunks, dtype: (1000, 2), (100, 1), int32\n2025-09-18 12:28:36 - zarr_info - INFO - pc/hix.zarr zarray shape, chunks, dtype: (1000,), (100,), int64\n2025-09-18 12:28:36 - pc_hix - INFO - calculating the hillbert index based on grid index\n2025-09-18 12:28:36 - pc_hix - INFO - writing the hillbert index\n2025-09-18 12:28:36 - pc_hix - INFO - done.\n2025-09-18 12:28:36 - log_args - INFO - running function: pc_gix\n2025-09-18 12:28:36 - log_args - INFO - fetching args:\n2025-09-18 12:28:36 - log_args - INFO - hix = 'pc/hix.zarr'\n2025-09-18 12:28:36 - log_args - INFO - gix = 'pc/gix_.zarr'\n2025-09-18 12:28:36 - log_args - INFO - shape = (100, 100)\n2025-09-18 12:28:36 - log_args - INFO - fetching args done.\n2025-09-18 12:28:36 - zarr_info - INFO - pc/hix.zarr zarray shape, chunks, dtype: (1000,), (100,), int64\n2025-09-18 12:28:36 - zarr_info - INFO - pc/gix_.zarr zarray shape, chunks, dtype: (1000, 2), (100, 1), int32\n2025-09-18 12:28:36 - pc_gix - INFO - calculating the grid index from hillbert index\n2025-09-18 12:28:37 - pc_gix - INFO - writing the grid index\n2025-09-18 12:28:37 - pc_gix - INFO - done.\n\n\n\nsource\n\n\npc_sort\n\n pc_sort (idx_in:str, idx:str, pc_in:str|list=None, pc:str|list=None,\n          shape:tuple=None, chunks:int=None, key:str=None,\n          processes=False, n_workers=1, threads_per_worker=1,\n          **dask_cluster_arg)\n\nSort point cloud data according to the indices that sort idx_in.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nidx_in\nstr\n\nthe unsorted grid index or hillbert index of the input data\n\n\nidx\nstr\n\noutput, the sorted grid index or hillbert index\n\n\npc_in\nstr | list\nNone\npath (in string) or list of path for the input point cloud data\n\n\npc\nstr | list\nNone\noutput, path (in string) or list of path for the output point cloud data\n\n\nshape\ntuple\nNone\n(nline, width), faster if provided for grid index input\n\n\nchunks\nint\nNone\nchunk size in output data, same as idx_in by default\n\n\nkey\nstr\nNone\noutput, path (in string) for the key of sorting\n\n\nprocesses\nbool\nFalse\nuse process for dask worker or thread\n\n\nn_workers\nint\n1\nnumber of dask worker\n\n\nthreads_per_worker\nint\n1\nnumber of threads per dask worker\n\n\ndask_cluster_arg\nVAR_KEYWORD\n\n\n\n\n\n\npc_in = np.random.rand(1000).astype(np.float32)\ngix_in = np.random.choice(np.arange(100*100,dtype=np.int32),size=1000,replace=False)\ngix_in = np.stack(np.unravel_index(gix_in,shape=(100,100)),axis=-1).astype(np.int32)\nind = np.lexsort((gix_in[:,1],gix_in[:,0]))\npc = pc_in[ind]; gix = gix_in[ind]\n\npc_in_zarr = zarr.open('pc/pc_in.zarr',mode='w',shape=pc_in.shape,dtype=pc_in.dtype,chunks=(100,))\ngix_in_zarr = zarr.open('pc/gix_in.zarr',mode='w',shape=gix_in.shape,dtype=gix_in.dtype,chunks=(100,1))\npc_in_zarr[:] = pc_in; gix_in_zarr[:] = gix_in\n\n\npc_sort('pc/gix_in.zarr','pc/gix.zarr','pc/pc_in.zarr','pc/pc.zarr',shape=(100,100))\npc_zarr = zarr.open('pc/pc.zarr',mode='r'); gix_zarr = zarr.open('pc/gix.zarr',mode='r')\nnp.testing.assert_array_equal(pc_zarr[:],pc)\nnp.testing.assert_array_equal(gix_zarr[:],gix)\n\n2025-09-18 12:28:55 - log_args - INFO - running function: pc_sort\n2025-09-18 12:28:55 - log_args - INFO - fetching args:\n2025-09-18 12:28:55 - log_args - INFO - idx_in = 'pc/gix_in.zarr'\n2025-09-18 12:28:55 - log_args - INFO - idx = 'pc/gix.zarr'\n2025-09-18 12:28:55 - log_args - INFO - pc_in = 'pc/pc_in.zarr'\n2025-09-18 12:28:55 - log_args - INFO - pc = 'pc/pc.zarr'\n2025-09-18 12:28:55 - log_args - INFO - shape = (100, 100)\n2025-09-18 12:28:55 - log_args - INFO - chunks = None\n2025-09-18 12:28:55 - log_args - INFO - key = None\n2025-09-18 12:28:55 - log_args - INFO - processes = False\n2025-09-18 12:28:55 - log_args - INFO - n_workers = 1\n2025-09-18 12:28:55 - log_args - INFO - threads_per_worker = 1\n2025-09-18 12:28:55 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 12:28:55 - log_args - INFO - fetching args done.\n2025-09-18 12:28:55 - zarr_info - INFO - pc/gix_in.zarr zarray shape, chunks, dtype: (1000, 2), (100, 1), int32\n2025-09-18 12:28:55 - pc_sort - INFO - loading idx_in and calculate the sorting indices.\n2025-09-18 12:28:55 - pc_sort - INFO - output pc chunk size is 100\n2025-09-18 12:28:55 - pc_sort - INFO - write idx\n2025-09-18 12:28:55 - zarr_info - INFO - idx zarray shape, chunks, dtype: (1000, 2), (100, 1), int32\n2025-09-18 12:28:55 - pc_sort - INFO - starting dask local cluster.\n2025-09-18 12:28:55 - pc_sort - INFO - dask local cluster started.\n2025-09-18 12:28:55 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.4:8787/status', workers=1, threads=1, memory=256.00 GiB)\n2025-09-18 12:28:55 - zarr_info - INFO - pc/pc_in.zarr zarray shape, chunks, dtype: (1000,), (100,), float32\n2025-09-18 12:28:55 - darr_info - INFO - pc_in dask array shape, chunksize, dtype: (1000,), (1000,), float32\n2025-09-18 12:28:55 - pc_sort - INFO - set up sorted pc data dask array.\n2025-09-18 12:28:55 - darr_info - INFO - pc dask array shape, chunksize, dtype: (1000,), (1000,), float32\n2025-09-18 12:28:55 - pc_sort - INFO - write pc to pc/pc.zarr\n2025-09-18 12:28:55 - zarr_info - INFO - pc/pc.zarr zarray shape, chunks, dtype: (1000,), (100,), float32\n2025-09-18 12:28:55 - pc_sort - INFO - computing graph setted. doing all the computing.\n2025-09-18 12:28:55 - pc_sort - INFO - computing finished.d |  0.1s\n2025-09-18 12:28:55 - pc_sort - INFO - dask cluster closed.\n\n\n\npc_in = np.random.rand(1000).astype(np.float32)\nhix_in = np.random.choice(np.arange(100*100,dtype=np.int64),size=1000,replace=False)\nind = np.argsort(hix_in,kind='stable')\npc = pc_in[ind]; hix = hix_in[ind]\n\npc_in_zarr = zarr.open('pc/pc_in.zarr',mode='w',shape=pc_in.shape,dtype=pc_in.dtype,chunks=(100,))\nhix_in_zarr = zarr.open('pc/hix_in.zarr',mode='w',shape=hix_in.shape,dtype=hix_in.dtype,chunks=(100,))\npc_in_zarr[:] = pc_in; hix_in_zarr[:] = hix_in\n\npc_sort('pc/hix_in.zarr','pc/hix.zarr','pc/pc_in.zarr','pc/pc.zarr')\npc_zarr = zarr.open('pc/pc.zarr',mode='r'); hix_zarr = zarr.open('pc/hix.zarr',mode='r')\nnp.testing.assert_array_equal(pc_zarr[:],pc)\nnp.testing.assert_array_equal(hix_zarr[:],hix)\n\n2025-09-18 12:28:56 - log_args - INFO - running function: pc_sort\n2025-09-18 12:28:56 - log_args - INFO - fetching args:\n2025-09-18 12:28:56 - log_args - INFO - idx_in = 'pc/hix_in.zarr'\n2025-09-18 12:28:56 - log_args - INFO - idx = 'pc/hix.zarr'\n2025-09-18 12:28:56 - log_args - INFO - pc_in = 'pc/pc_in.zarr'\n2025-09-18 12:28:56 - log_args - INFO - pc = 'pc/pc.zarr'\n2025-09-18 12:28:56 - log_args - INFO - shape = None\n2025-09-18 12:28:56 - log_args - INFO - chunks = None\n2025-09-18 12:28:56 - log_args - INFO - key = None\n2025-09-18 12:28:56 - log_args - INFO - processes = False\n2025-09-18 12:28:56 - log_args - INFO - n_workers = 1\n2025-09-18 12:28:56 - log_args - INFO - threads_per_worker = 1\n2025-09-18 12:28:56 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 12:28:56 - log_args - INFO - fetching args done.\n2025-09-18 12:28:56 - zarr_info - INFO - pc/hix_in.zarr zarray shape, chunks, dtype: (1000,), (100,), int64\n2025-09-18 12:28:56 - pc_sort - INFO - loading idx_in and calculate the sorting indices.\n2025-09-18 12:28:56 - pc_sort - INFO - output pc chunk size is 100\n2025-09-18 12:28:56 - pc_sort - INFO - write idx\n2025-09-18 12:28:56 - zarr_info - INFO - idx zarray shape, chunks, dtype: (1000,), (100,), int64\n2025-09-18 12:28:56 - pc_sort - INFO - starting dask local cluster.\n2025-09-18 12:28:56 - pc_sort - INFO - dask local cluster started.\n2025-09-18 12:28:56 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.4:8787/status', workers=1, threads=1, memory=256.00 GiB)\n2025-09-18 12:28:56 - zarr_info - INFO - pc/pc_in.zarr zarray shape, chunks, dtype: (1000,), (100,), float32\n2025-09-18 12:28:56 - darr_info - INFO - pc_in dask array shape, chunksize, dtype: (1000,), (1000,), float32\n2025-09-18 12:28:56 - pc_sort - INFO - set up sorted pc data dask array.\n2025-09-18 12:28:56 - darr_info - INFO - pc dask array shape, chunksize, dtype: (1000,), (1000,), float32\n2025-09-18 12:28:56 - pc_sort - INFO - write pc to pc/pc.zarr\n2025-09-18 12:28:56 - zarr_info - INFO - pc/pc.zarr zarray shape, chunks, dtype: (1000,), (100,), float32\n2025-09-18 12:28:56 - pc_sort - INFO - computing graph setted. doing all the computing.\n2025-09-18 12:28:56 - pc_sort - INFO - computing finished.d |  0.1s\n2025-09-18 12:28:56 - pc_sort - INFO - dask cluster closed.\n\n\n\nsource\n\n\npc_union\n\n pc_union (idx1:str, idx2:str, idx:str, pc1:str|list=None,\n           pc2:str|list=None, pc:str|list=None, shape:tuple=None,\n           chunks:int=None, processes=False, n_workers=1,\n           threads_per_worker=1, **dask_cluster_arg)\n\nGet the union of two point cloud dataset. For points at their intersection, pc_data1 rather than pc_data2 is copied to the result pc_data. pc_chunk_size and n_pc_chunk are used to determine the final pc_chunk_size. If non of them are provided, the pc_chunk_size is setted as it in idx1.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nidx1\nstr\n\ngrid index or hillbert index of the first point cloud\n\n\nidx2\nstr\n\ngrid index or hillbert index of the second point cloud\n\n\nidx\nstr\n\noutput, grid index or hillbert index of the union point cloud\n\n\npc1\nstr | list\nNone\npath (in string) or list of path for the first point cloud data\n\n\npc2\nstr | list\nNone\npath (in string) or list of path for the second point cloud data\n\n\npc\nstr | list\nNone\noutput, path (in string) or list of path for the union point cloud data\n\n\nshape\ntuple\nNone\nimage shape, faster if provided for grid index input\n\n\nchunks\nint\nNone\nchunk size in output data, same as idx1 by default\n\n\nprocesses\nbool\nFalse\nuse process for dask worker or thread\n\n\nn_workers\nint\n1\nnumber of dask worker\n\n\nthreads_per_worker\nint\n1\nnumber of threads per dask worker\n\n\ndask_cluster_arg\nVAR_KEYWORD\n\n\n\n\n\nUsage:\n\npc_data1 = np.random.rand(1000,3).astype(np.float32)+1j*np.random.rand(1000,3).astype(np.float32)\npc_data2 = np.random.rand(800,3).astype(np.float32)+1j*np.random.rand(800,3).astype(np.float32)\n\ngix1 = np.random.choice(np.arange(100*100,dtype=np.int32),size=1000,replace=False)\ngix1.sort()\ngix1 = np.stack(np.unravel_index(gix1,shape=(100,100)),axis=-1).astype(np.int32)\n\ngix2 = np.random.choice(np.arange(100*100,dtype=np.int32),size=800,replace=False)\ngix2.sort()\ngix2 = np.stack(np.unravel_index(gix2,shape=(100,100)),axis=-1).astype(np.int32)\n\ngix, inv_iidx1, inv_iidx2, iidx2 = mr.pc_union(gix1,gix2)\n\npc_data = np.empty((gix.shape[0],*pc_data1.shape[1:]),dtype=pc_data1.dtype)\npc_data[inv_iidx1] = pc_data1\npc_data[inv_iidx2] = pc_data2[iidx2]\n\ngix1_zarr = zarr.open('pc/gix1.zarr',mode='w',shape=gix1.shape,dtype=gix1.dtype,chunks=(200,1))\ngix2_zarr = zarr.open('pc/gix2.zarr',mode='w',shape=gix2.shape,dtype=gix2.dtype,chunks=(200,1))\npc1_zarr = zarr.open('pc/pc1.zarr',mode='w',shape=pc_data1.shape,dtype=pc_data1.dtype,chunks=(200,1))\npc2_zarr = zarr.open('pc/pc2.zarr',mode='w',shape=pc_data2.shape,dtype=pc_data2.dtype,chunks=(200,1))\ngix1_zarr[:] = gix1\ngix2_zarr[:] = gix2\npc1_zarr[:] = pc_data1\npc2_zarr[:] = pc_data2\n\n\npc_union('pc/gix1.zarr','pc/gix2.zarr','pc/gix.zarr', shape=(100,100))\npc_union('pc/gix1.zarr','pc/gix2.zarr','pc/gix.zarr','pc/pc1.zarr','pc/pc2.zarr','pc/pc.zarr')\ngix_zarr = zarr.open('pc/gix.zarr',mode='r')\npc_zarr = zarr.open('pc/pc.zarr',mode='r')\nnp.testing.assert_array_equal(gix_zarr[:],gix)\nnp.testing.assert_array_equal(pc_zarr[:],pc_data)\n\n2025-09-18 12:28:58 - log_args - INFO - running function: pc_union\n2025-09-18 12:28:58 - log_args - INFO - fetching args:\n2025-09-18 12:28:58 - log_args - INFO - idx1 = 'pc/gix1.zarr'\n2025-09-18 12:28:58 - log_args - INFO - idx2 = 'pc/gix2.zarr'\n2025-09-18 12:28:58 - log_args - INFO - idx = 'pc/gix.zarr'\n2025-09-18 12:28:58 - log_args - INFO - pc1 = None\n2025-09-18 12:28:58 - log_args - INFO - pc2 = None\n2025-09-18 12:28:58 - log_args - INFO - pc = None\n2025-09-18 12:28:58 - log_args - INFO - shape = (100, 100)\n2025-09-18 12:28:58 - log_args - INFO - chunks = None\n2025-09-18 12:28:58 - log_args - INFO - processes = False\n2025-09-18 12:28:58 - log_args - INFO - n_workers = 1\n2025-09-18 12:28:58 - log_args - INFO - threads_per_worker = 1\n2025-09-18 12:28:58 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 12:28:58 - log_args - INFO - fetching args done.\n2025-09-18 12:28:58 - zarr_info - INFO - pc/gix1.zarr zarray shape, chunks, dtype: (1000, 2), (200, 1), int32\n2025-09-18 12:28:58 - zarr_info - INFO - pc/gix2.zarr zarray shape, chunks, dtype: (800, 2), (200, 1), int32\n2025-09-18 12:28:58 - pc_union - INFO - loading idx1 and idx2 into memory.\n2025-09-18 12:28:58 - pc_union - INFO - calculate the union\n2025-09-18 12:28:58 - pc_union - INFO - number of points in the union: 1725\n2025-09-18 12:28:58 - pc_union - INFO - write union idx\n2025-09-18 12:28:59 - pc_union - INFO - write done\n2025-09-18 12:28:59 - zarr_info - INFO - pc/gix.zarr zarray shape, chunks, dtype: (1725, 2), (200, 1), int32\n2025-09-18 12:28:59 - pc_union - INFO - no point cloud data provided, exit.\n2025-09-18 12:28:59 - log_args - INFO - running function: pc_union\n2025-09-18 12:28:59 - log_args - INFO - fetching args:\n2025-09-18 12:28:59 - log_args - INFO - idx1 = 'pc/gix1.zarr'\n2025-09-18 12:28:59 - log_args - INFO - idx2 = 'pc/gix2.zarr'\n2025-09-18 12:28:59 - log_args - INFO - idx = 'pc/gix.zarr'\n2025-09-18 12:28:59 - log_args - INFO - pc1 = 'pc/pc1.zarr'\n2025-09-18 12:28:59 - log_args - INFO - pc2 = 'pc/pc2.zarr'\n2025-09-18 12:28:59 - log_args - INFO - pc = 'pc/pc.zarr'\n2025-09-18 12:28:59 - log_args - INFO - shape = None\n2025-09-18 12:28:59 - log_args - INFO - chunks = None\n2025-09-18 12:28:59 - log_args - INFO - processes = False\n2025-09-18 12:28:59 - log_args - INFO - n_workers = 1\n2025-09-18 12:28:59 - log_args - INFO - threads_per_worker = 1\n2025-09-18 12:28:59 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 12:28:59 - log_args - INFO - fetching args done.\n2025-09-18 12:28:59 - zarr_info - INFO - pc/gix1.zarr zarray shape, chunks, dtype: (1000, 2), (200, 1), int32\n2025-09-18 12:28:59 - zarr_info - INFO - pc/gix2.zarr zarray shape, chunks, dtype: (800, 2), (200, 1), int32\n2025-09-18 12:28:59 - pc_union - INFO - loading idx1 and idx2 into memory.\n2025-09-18 12:28:59 - pc_union - INFO - calculate the union\n2025-09-18 12:28:59 - pc_union - INFO - number of points in the union: 1725\n2025-09-18 12:28:59 - pc_union - INFO - write union idx\n2025-09-18 12:28:59 - pc_union - INFO - write done\n2025-09-18 12:28:59 - zarr_info - INFO - pc/gix.zarr zarray shape, chunks, dtype: (1725, 2), (200, 1), int32\n2025-09-18 12:28:59 - pc_union - INFO - starting dask local cluster.\n2025-09-18 12:28:59 - pc_union - INFO - dask local cluster started.\n2025-09-18 12:28:59 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.4:8787/status', workers=1, threads=1, memory=256.00 GiB)\n2025-09-18 12:28:59 - zarr_info - INFO - pc/pc1.zarr zarray shape, chunks, dtype: (1000, 3), (200, 1), complex64\n2025-09-18 12:28:59 - zarr_info - INFO - pc/pc2.zarr zarray shape, chunks, dtype: (800, 3), (200, 1), complex64\n2025-09-18 12:28:59 - darr_info - INFO - pc1 dask array shape, chunksize, dtype: (1000, 3), (1000, 1), complex64\n2025-09-18 12:28:59 - darr_info - INFO - pc2 dask array shape, chunksize, dtype: (800, 3), (800, 1), complex64\n2025-09-18 12:28:59 - pc_union - INFO - set up union pc data dask array.\n2025-09-18 12:28:59 - darr_info - INFO - pc dask array shape, chunksize, dtype: (1725, 3), (1725, 1), complex64\n2025-09-18 12:28:59 - pc_union - INFO - write pc to pc/pc.zarr\n2025-09-18 12:28:59 - zarr_info - INFO - pc/pc.zarr zarray shape, chunks, dtype: (1725, 3), (200, 1), complex64\n2025-09-18 12:28:59 - pc_union - INFO - computing graph setted. doing all the computing.\n2025-09-18 12:28:59 - pc_union - INFO - computing finished. |  0.2s\n2025-09-18 12:28:59 - pc_union - INFO - dask cluster closed.\n\n\n\npc_data1 = np.random.rand(1000,3).astype(np.float32)+1j*np.random.rand(1000,3).astype(np.float32)\npc_data2 = np.random.rand(800,3).astype(np.float32)+1j*np.random.rand(800,3).astype(np.float32)\n\nhix1 = np.random.choice(np.arange(100*100,dtype=np.int64),size=1000,replace=False)\nhix1.sort()\n\nhix2 = np.random.choice(np.arange(100*100,dtype=np.int64),size=800,replace=False)\nhix2.sort()\n\nhix, inv_iidx1, inv_iidx2, iidx2 = mr.pc_union(hix1,hix2)\n\npc_data = np.empty((hix.shape[0],*pc_data1.shape[1:]),dtype=pc_data1.dtype)\npc_data[inv_iidx1] = pc_data1\npc_data[inv_iidx2] = pc_data2[iidx2]\n\nhix1_zarr = zarr.open('pc/hix1.zarr',mode='w',shape=hix1.shape,dtype=hix1.dtype,chunks=(200,))\nhix2_zarr = zarr.open('pc/hix2.zarr',mode='w',shape=hix2.shape,dtype=hix2.dtype,chunks=(200,))\npc1_zarr = zarr.open('pc/pc1.zarr',mode='w',shape=pc_data1.shape,dtype=pc_data1.dtype,chunks=(200,1))\npc2_zarr = zarr.open('pc/pc2.zarr',mode='w',shape=pc_data2.shape,dtype=pc_data2.dtype,chunks=(200,1))\nhix1_zarr[:] = hix1\nhix2_zarr[:] = hix2\npc1_zarr[:] = pc_data1\npc2_zarr[:] = pc_data2\n\n\npc_union('pc/hix1.zarr','pc/hix2.zarr','pc/hix.zarr')\npc_union('pc/hix1.zarr','pc/hix2.zarr','pc/hix.zarr','pc/pc1.zarr','pc/pc2.zarr','pc/pc.zarr')\nhix_zarr = zarr.open('pc/hix.zarr',mode='r')\npc_zarr = zarr.open('pc/pc.zarr',mode='r')\nnp.testing.assert_array_equal(hix_zarr[:],hix)\nnp.testing.assert_array_equal(pc_zarr[:],pc_data)\n\n2025-09-18 12:29:00 - log_args - INFO - running function: pc_union\n2025-09-18 12:29:00 - log_args - INFO - fetching args:\n2025-09-18 12:29:00 - log_args - INFO - idx1 = 'pc/hix1.zarr'\n2025-09-18 12:29:00 - log_args - INFO - idx2 = 'pc/hix2.zarr'\n2025-09-18 12:29:00 - log_args - INFO - idx = 'pc/hix.zarr'\n2025-09-18 12:29:00 - log_args - INFO - pc1 = None\n2025-09-18 12:29:00 - log_args - INFO - pc2 = None\n2025-09-18 12:29:00 - log_args - INFO - pc = None\n2025-09-18 12:29:00 - log_args - INFO - shape = None\n2025-09-18 12:29:00 - log_args - INFO - chunks = None\n2025-09-18 12:29:00 - log_args - INFO - processes = False\n2025-09-18 12:29:00 - log_args - INFO - n_workers = 1\n2025-09-18 12:29:00 - log_args - INFO - threads_per_worker = 1\n2025-09-18 12:29:00 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 12:29:00 - log_args - INFO - fetching args done.\n2025-09-18 12:29:00 - zarr_info - INFO - pc/hix1.zarr zarray shape, chunks, dtype: (1000,), (200,), int64\n2025-09-18 12:29:00 - zarr_info - INFO - pc/hix2.zarr zarray shape, chunks, dtype: (800,), (200,), int64\n2025-09-18 12:29:00 - pc_union - INFO - loading idx1 and idx2 into memory.\n2025-09-18 12:29:00 - pc_union - INFO - calculate the union\n2025-09-18 12:29:00 - pc_union - INFO - number of points in the union: 1720\n2025-09-18 12:29:00 - pc_union - INFO - write union idx\n2025-09-18 12:29:00 - pc_union - INFO - write done\n2025-09-18 12:29:00 - zarr_info - INFO - pc/hix.zarr zarray shape, chunks, dtype: (1720,), (200,), int64\n2025-09-18 12:29:00 - pc_union - INFO - no point cloud data provided, exit.\n2025-09-18 12:29:00 - log_args - INFO - running function: pc_union\n2025-09-18 12:29:00 - log_args - INFO - fetching args:\n2025-09-18 12:29:00 - log_args - INFO - idx1 = 'pc/hix1.zarr'\n2025-09-18 12:29:00 - log_args - INFO - idx2 = 'pc/hix2.zarr'\n2025-09-18 12:29:00 - log_args - INFO - idx = 'pc/hix.zarr'\n2025-09-18 12:29:00 - log_args - INFO - pc1 = 'pc/pc1.zarr'\n2025-09-18 12:29:00 - log_args - INFO - pc2 = 'pc/pc2.zarr'\n2025-09-18 12:29:00 - log_args - INFO - pc = 'pc/pc.zarr'\n2025-09-18 12:29:00 - log_args - INFO - shape = None\n2025-09-18 12:29:00 - log_args - INFO - chunks = None\n2025-09-18 12:29:00 - log_args - INFO - processes = False\n2025-09-18 12:29:00 - log_args - INFO - n_workers = 1\n2025-09-18 12:29:00 - log_args - INFO - threads_per_worker = 1\n2025-09-18 12:29:00 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 12:29:00 - log_args - INFO - fetching args done.\n2025-09-18 12:29:00 - zarr_info - INFO - pc/hix1.zarr zarray shape, chunks, dtype: (1000,), (200,), int64\n2025-09-18 12:29:00 - zarr_info - INFO - pc/hix2.zarr zarray shape, chunks, dtype: (800,), (200,), int64\n2025-09-18 12:29:00 - pc_union - INFO - loading idx1 and idx2 into memory.\n2025-09-18 12:29:00 - pc_union - INFO - calculate the union\n2025-09-18 12:29:00 - pc_union - INFO - number of points in the union: 1720\n2025-09-18 12:29:00 - pc_union - INFO - write union idx\n2025-09-18 12:29:00 - pc_union - INFO - write done\n2025-09-18 12:29:00 - zarr_info - INFO - pc/hix.zarr zarray shape, chunks, dtype: (1720,), (200,), int64\n2025-09-18 12:29:00 - pc_union - INFO - starting dask local cluster.\n2025-09-18 12:29:00 - pc_union - INFO - dask local cluster started.\n2025-09-18 12:29:00 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.4:8787/status', workers=1, threads=1, memory=256.00 GiB)\n2025-09-18 12:29:00 - zarr_info - INFO - pc/pc1.zarr zarray shape, chunks, dtype: (1000, 3), (200, 1), complex64\n2025-09-18 12:29:00 - zarr_info - INFO - pc/pc2.zarr zarray shape, chunks, dtype: (800, 3), (200, 1), complex64\n2025-09-18 12:29:00 - darr_info - INFO - pc1 dask array shape, chunksize, dtype: (1000, 3), (1000, 1), complex64\n2025-09-18 12:29:00 - darr_info - INFO - pc2 dask array shape, chunksize, dtype: (800, 3), (800, 1), complex64\n2025-09-18 12:29:00 - pc_union - INFO - set up union pc data dask array.\n2025-09-18 12:29:00 - darr_info - INFO - pc dask array shape, chunksize, dtype: (1720, 3), (1720, 1), complex64\n2025-09-18 12:29:00 - pc_union - INFO - write pc to pc/pc.zarr\n2025-09-18 12:29:00 - zarr_info - INFO - pc/pc.zarr zarray shape, chunks, dtype: (1720, 3), (200, 1), complex64\n2025-09-18 12:29:00 - pc_union - INFO - computing graph setted. doing all the computing.\n2025-09-18 12:29:00 - pc_union - INFO - computing finished. |  0.2s\n2025-09-18 12:29:00 - pc_union - INFO - dask cluster closed.\n\n\n\nsource\n\n\npc_intersect\n\n pc_intersect (idx1:str, idx2:str, idx:str, pc1:str|list=None,\n               pc2:str|list=None, pc:str|list=None, shape:tuple=None,\n               chunks:int=None, prefer_1=True, processes=False,\n               n_workers=1, threads_per_worker=1, **dask_cluster_arg)\n\nGet the intersection of two point cloud dataset. pc_chunk_size and n_pc_chunk are used to determine the final pc_chunk_size. If non of them are provided, the n_pc_chunk is set to n_chunk in idx1.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nidx1\nstr\n\ngrid index or hillbert index of the first point cloud\n\n\nidx2\nstr\n\ngrid index or hillbert index of the second point cloud\n\n\nidx\nstr\n\noutput, grid index or hillbert index of the union point cloud\n\n\npc1\nstr | list\nNone\npath (in string) or list of path for the first point cloud data\n\n\npc2\nstr | list\nNone\npath (in string) or list of path for the second point cloud data\n\n\npc\nstr | list\nNone\noutput, path (in string) or list of path for the union point cloud data\n\n\nshape\ntuple\nNone\nimage shape, faster if provided for grid index input\n\n\nchunks\nint\nNone\nchunk size in output data, same as idx1 by default\n\n\nprefer_1\nbool\nTrue\nsave pc1 on intersection to output pc dataset by default True. Otherwise, save data from pc2\n\n\nprocesses\nbool\nFalse\nuse process for dask worker or thread\n\n\nn_workers\nint\n1\nnumber of dask worker\n\n\nthreads_per_worker\nint\n1\nnumber of threads per dask worker\n\n\ndask_cluster_arg\nVAR_KEYWORD\n\n\n\n\n\nUsage:\n\npc_data1 = np.random.rand(1000,3).astype(np.float32)+1j*np.random.rand(1000,3).astype(np.float32)\npc_data2 = np.random.rand(800,3).astype(np.float32)+1j*np.random.rand(800,3).astype(np.float32)\n\ngix1 = np.random.choice(np.arange(100*100,dtype=np.int32),size=1000,replace=False)\ngix1.sort()\ngix1 = np.stack(np.unravel_index(gix1,shape=(100,100)),axis=-1).astype(np.int32)\n\ngix2 = np.random.choice(np.arange(100*100,dtype=np.int32),size=800,replace=False)\ngix2.sort()\ngix2 = np.stack(np.unravel_index(gix2,shape=(100,100)),axis=-1).astype(np.int32)\n\ngix, iidx1, iidx2 = mr.pc_intersect(gix1,gix2)\n\npc_data = np.empty((gix.shape[0],*pc_data1.shape[1:]),dtype=pc_data1.dtype)\npc_data[:] = pc_data2[iidx2]\n\ngix1_zarr = zarr.open('pc/gix1.zarr',mode='w',shape=gix1.shape,dtype=gix1.dtype,chunks=(200,1))\ngix2_zarr = zarr.open('pc/gix2.zarr',mode='w',shape=gix2.shape,dtype=gix2.dtype,chunks=(200,1))\npc1_zarr = zarr.open('pc/pc1.zarr',mode='w',shape=pc_data1.shape,dtype=pc_data1.dtype,chunks=(200,1))\npc2_zarr = zarr.open('pc/pc2.zarr',mode='w',shape=pc_data2.shape,dtype=pc_data2.dtype,chunks=(200,1))\ngix1_zarr[:] = gix1\ngix2_zarr[:] = gix2\npc1_zarr[:] = pc_data1\npc2_zarr[:] = pc_data2\n\n\npc_intersect('pc/gix1.zarr','pc/gix2.zarr','pc/gix.zarr', shape=(100,100))\npc_intersect('pc/gix1.zarr','pc/gix2.zarr','pc/gix.zarr',pc2='pc/pc2.zarr', pc='pc/pc.zarr',prefer_1=False)\ngix_zarr = zarr.open('pc/gix.zarr',mode='r')\npc_zarr = zarr.open('pc/pc.zarr',mode='r')\nnp.testing.assert_array_equal(gix_zarr[:],gix)\nnp.testing.assert_array_equal(pc_zarr[:],pc_data)\n\n2025-09-18 12:29:02 - log_args - INFO - running function: pc_intersect\n2025-09-18 12:29:02 - log_args - INFO - fetching args:\n2025-09-18 12:29:02 - log_args - INFO - idx1 = 'pc/gix1.zarr'\n2025-09-18 12:29:02 - log_args - INFO - idx2 = 'pc/gix2.zarr'\n2025-09-18 12:29:02 - log_args - INFO - idx = 'pc/gix.zarr'\n2025-09-18 12:29:02 - log_args - INFO - pc1 = None\n2025-09-18 12:29:02 - log_args - INFO - pc2 = None\n2025-09-18 12:29:02 - log_args - INFO - pc = None\n2025-09-18 12:29:02 - log_args - INFO - shape = (100, 100)\n2025-09-18 12:29:02 - log_args - INFO - chunks = None\n2025-09-18 12:29:02 - log_args - INFO - prefer_1 = True\n2025-09-18 12:29:02 - log_args - INFO - processes = False\n2025-09-18 12:29:02 - log_args - INFO - n_workers = 1\n2025-09-18 12:29:02 - log_args - INFO - threads_per_worker = 1\n2025-09-18 12:29:02 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 12:29:02 - log_args - INFO - fetching args done.\n2025-09-18 12:29:02 - zarr_info - INFO - pc/gix1.zarr zarray shape, chunks, dtype: (1000, 2), (200, 1), int32\n2025-09-18 12:29:02 - zarr_info - INFO - pc/gix2.zarr zarray shape, chunks, dtype: (800, 2), (200, 1), int32\n2025-09-18 12:29:02 - pc_intersect - INFO - loading idx1 and idx2 into memory.\n2025-09-18 12:29:02 - pc_intersect - INFO - calculate the intersection\n2025-09-18 12:29:02 - pc_intersect - INFO - number of points in the intersection: 84\n2025-09-18 12:29:02 - pc_intersect - INFO - write intersect idx\n2025-09-18 12:29:02 - pc_intersect - INFO - write done\n2025-09-18 12:29:02 - zarr_info - INFO - pc/gix.zarr zarray shape, chunks, dtype: (84, 2), (200, 1), int32\n2025-09-18 12:29:02 - pc_intersect - INFO - no point cloud data provided, exit.\n2025-09-18 12:29:02 - log_args - INFO - running function: pc_intersect\n2025-09-18 12:29:02 - log_args - INFO - fetching args:\n2025-09-18 12:29:02 - log_args - INFO - idx1 = 'pc/gix1.zarr'\n2025-09-18 12:29:02 - log_args - INFO - idx2 = 'pc/gix2.zarr'\n2025-09-18 12:29:02 - log_args - INFO - idx = 'pc/gix.zarr'\n2025-09-18 12:29:02 - log_args - INFO - pc1 = None\n2025-09-18 12:29:02 - log_args - INFO - pc2 = 'pc/pc2.zarr'\n2025-09-18 12:29:02 - log_args - INFO - pc = 'pc/pc.zarr'\n2025-09-18 12:29:02 - log_args - INFO - shape = None\n2025-09-18 12:29:02 - log_args - INFO - chunks = None\n2025-09-18 12:29:02 - log_args - INFO - prefer_1 = False\n2025-09-18 12:29:02 - log_args - INFO - processes = False\n2025-09-18 12:29:02 - log_args - INFO - n_workers = 1\n2025-09-18 12:29:02 - log_args - INFO - threads_per_worker = 1\n2025-09-18 12:29:02 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 12:29:02 - log_args - INFO - fetching args done.\n2025-09-18 12:29:02 - zarr_info - INFO - pc/gix1.zarr zarray shape, chunks, dtype: (1000, 2), (200, 1), int32\n2025-09-18 12:29:02 - zarr_info - INFO - pc/gix2.zarr zarray shape, chunks, dtype: (800, 2), (200, 1), int32\n2025-09-18 12:29:02 - pc_intersect - INFO - loading idx1 and idx2 into memory.\n2025-09-18 12:29:02 - pc_intersect - INFO - calculate the intersection\n2025-09-18 12:29:02 - pc_intersect - INFO - number of points in the intersection: 84\n2025-09-18 12:29:02 - pc_intersect - INFO - write intersect idx\n2025-09-18 12:29:02 - pc_intersect - INFO - write done\n2025-09-18 12:29:02 - zarr_info - INFO - pc/gix.zarr zarray shape, chunks, dtype: (84, 2), (200, 1), int32\n2025-09-18 12:29:02 - pc_intersect - INFO - select pc2 as pc_input.\n2025-09-18 12:29:02 - pc_intersect - INFO - starting dask local cluster.\n2025-09-18 12:29:02 - pc_intersect - INFO - dask local cluster started.\n2025-09-18 12:29:02 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.4:8787/status', workers=1, threads=1, memory=256.00 GiB)\n2025-09-18 12:29:02 - zarr_info - INFO - pc/pc2.zarr zarray shape, chunks, dtype: (800, 3), (200, 1), complex64\n2025-09-18 12:29:02 - darr_info - INFO - pc_input dask array shape, chunksize, dtype: (800, 3), (800, 1), complex64\n2025-09-18 12:29:02 - pc_intersect - INFO - set up intersect pc data dask array.\n2025-09-18 12:29:02 - darr_info - INFO - pc dask array shape, chunksize, dtype: (84, 3), (84, 1), complex64\n2025-09-18 12:29:02 - pc_intersect - INFO - write pc to pc/pc.zarr\n2025-09-18 12:29:02 - zarr_info - INFO - pc/pc.zarr zarray shape, chunks, dtype: (84, 3), (200, 1), complex64\n2025-09-18 12:29:02 - pc_intersect - INFO - computing graph setted. doing all the computing.\n2025-09-18 12:29:03 - pc_intersect - INFO - computing finished.0.1s\n2025-09-18 12:29:03 - pc_intersect - INFO - dask cluster closed.\n\n\n\npc_data1 = np.random.rand(1000,3).astype(np.float32)+1j*np.random.rand(1000,3).astype(np.float32)\npc_data2 = np.random.rand(800,3).astype(np.float32)+1j*np.random.rand(800,3).astype(np.float32)\n\nhix1 = np.random.choice(np.arange(100*100,dtype=np.int64),size=1000,replace=False)\nhix1.sort()\n\nhix2 = np.random.choice(np.arange(100*100,dtype=np.int64),size=800,replace=False)\nhix2.sort()\n\nhix, iidx1, iidx2 = mr.pc_intersect(hix1,hix2)\n\npc_data = np.empty((hix.shape[-1],*pc_data1.shape[1:]),dtype=pc_data1.dtype)\npc_data[:] = pc_data2[iidx2]\n\nhix1_zarr = zarr.open('pc/hix1.zarr',mode='w',shape=hix1.shape,dtype=hix1.dtype,chunks=(200,))\nhix2_zarr = zarr.open('pc/hix2.zarr',mode='w',shape=hix2.shape,dtype=hix2.dtype,chunks=(200,))\npc1_zarr = zarr.open('pc/pc1.zarr',mode='w',shape=pc_data1.shape,dtype=pc_data1.dtype,chunks=(200,1))\npc2_zarr = zarr.open('pc/pc2.zarr',mode='w',shape=pc_data2.shape,dtype=pc_data2.dtype,chunks=(200,1))\nhix1_zarr[:] = hix1\nhix2_zarr[:] = hix2\npc1_zarr[:] = pc_data1\npc2_zarr[:] = pc_data2\n\n\npc_intersect('pc/hix1.zarr','pc/hix2.zarr','pc/hix.zarr')\npc_intersect('pc/hix1.zarr','pc/hix2.zarr','pc/hix.zarr',pc2='pc/pc2.zarr', pc='pc/pc.zarr',prefer_1=False)\nhix_zarr = zarr.open('pc/hix.zarr',mode='r')\npc_zarr = zarr.open('pc/pc.zarr',mode='r')\nnp.testing.assert_array_equal(hix_zarr[:],hix)\nnp.testing.assert_array_equal(pc_zarr[:],pc_data)\n\n2025-09-18 12:29:04 - log_args - INFO - running function: pc_intersect\n2025-09-18 12:29:04 - log_args - INFO - fetching args:\n2025-09-18 12:29:04 - log_args - INFO - idx1 = 'pc/hix1.zarr'\n2025-09-18 12:29:04 - log_args - INFO - idx2 = 'pc/hix2.zarr'\n2025-09-18 12:29:04 - log_args - INFO - idx = 'pc/hix.zarr'\n2025-09-18 12:29:04 - log_args - INFO - pc1 = None\n2025-09-18 12:29:04 - log_args - INFO - pc2 = None\n2025-09-18 12:29:04 - log_args - INFO - pc = None\n2025-09-18 12:29:04 - log_args - INFO - shape = None\n2025-09-18 12:29:04 - log_args - INFO - chunks = None\n2025-09-18 12:29:04 - log_args - INFO - prefer_1 = True\n2025-09-18 12:29:04 - log_args - INFO - processes = False\n2025-09-18 12:29:04 - log_args - INFO - n_workers = 1\n2025-09-18 12:29:04 - log_args - INFO - threads_per_worker = 1\n2025-09-18 12:29:04 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 12:29:04 - log_args - INFO - fetching args done.\n2025-09-18 12:29:04 - zarr_info - INFO - pc/hix1.zarr zarray shape, chunks, dtype: (1000,), (200,), int64\n2025-09-18 12:29:04 - zarr_info - INFO - pc/hix2.zarr zarray shape, chunks, dtype: (800,), (200,), int64\n2025-09-18 12:29:04 - pc_intersect - INFO - loading idx1 and idx2 into memory.\n2025-09-18 12:29:04 - pc_intersect - INFO - calculate the intersection\n2025-09-18 12:29:04 - pc_intersect - INFO - number of points in the intersection: 73\n2025-09-18 12:29:04 - pc_intersect - INFO - write intersect idx\n2025-09-18 12:29:04 - pc_intersect - INFO - write done\n2025-09-18 12:29:04 - zarr_info - INFO - pc/hix.zarr zarray shape, chunks, dtype: (73,), (200,), int64\n2025-09-18 12:29:04 - pc_intersect - INFO - no point cloud data provided, exit.\n2025-09-18 12:29:04 - log_args - INFO - running function: pc_intersect\n2025-09-18 12:29:04 - log_args - INFO - fetching args:\n2025-09-18 12:29:04 - log_args - INFO - idx1 = 'pc/hix1.zarr'\n2025-09-18 12:29:04 - log_args - INFO - idx2 = 'pc/hix2.zarr'\n2025-09-18 12:29:04 - log_args - INFO - idx = 'pc/hix.zarr'\n2025-09-18 12:29:04 - log_args - INFO - pc1 = None\n2025-09-18 12:29:04 - log_args - INFO - pc2 = 'pc/pc2.zarr'\n2025-09-18 12:29:04 - log_args - INFO - pc = 'pc/pc.zarr'\n2025-09-18 12:29:04 - log_args - INFO - shape = None\n2025-09-18 12:29:04 - log_args - INFO - chunks = None\n2025-09-18 12:29:04 - log_args - INFO - prefer_1 = False\n2025-09-18 12:29:04 - log_args - INFO - processes = False\n2025-09-18 12:29:04 - log_args - INFO - n_workers = 1\n2025-09-18 12:29:04 - log_args - INFO - threads_per_worker = 1\n2025-09-18 12:29:04 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 12:29:04 - log_args - INFO - fetching args done.\n2025-09-18 12:29:04 - zarr_info - INFO - pc/hix1.zarr zarray shape, chunks, dtype: (1000,), (200,), int64\n2025-09-18 12:29:04 - zarr_info - INFO - pc/hix2.zarr zarray shape, chunks, dtype: (800,), (200,), int64\n2025-09-18 12:29:04 - pc_intersect - INFO - loading idx1 and idx2 into memory.\n2025-09-18 12:29:04 - pc_intersect - INFO - calculate the intersection\n2025-09-18 12:29:04 - pc_intersect - INFO - number of points in the intersection: 73\n2025-09-18 12:29:04 - pc_intersect - INFO - write intersect idx\n2025-09-18 12:29:04 - pc_intersect - INFO - write done\n2025-09-18 12:29:04 - zarr_info - INFO - pc/hix.zarr zarray shape, chunks, dtype: (73,), (200,), int64\n2025-09-18 12:29:04 - pc_intersect - INFO - select pc2 as pc_input.\n2025-09-18 12:29:04 - pc_intersect - INFO - starting dask local cluster.\n2025-09-18 12:29:04 - pc_intersect - INFO - dask local cluster started.\n2025-09-18 12:29:04 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.4:8787/status', workers=1, threads=1, memory=256.00 GiB)\n2025-09-18 12:29:04 - zarr_info - INFO - pc/pc2.zarr zarray shape, chunks, dtype: (800, 3), (200, 1), complex64\n2025-09-18 12:29:04 - darr_info - INFO - pc_input dask array shape, chunksize, dtype: (800, 3), (800, 1), complex64\n2025-09-18 12:29:04 - pc_intersect - INFO - set up intersect pc data dask array.\n2025-09-18 12:29:04 - darr_info - INFO - pc dask array shape, chunksize, dtype: (73, 3), (73, 1), complex64\n2025-09-18 12:29:04 - pc_intersect - INFO - write pc to pc/pc.zarr\n2025-09-18 12:29:04 - zarr_info - INFO - pc/pc.zarr zarray shape, chunks, dtype: (73, 3), (200, 1), complex64\n2025-09-18 12:29:04 - pc_intersect - INFO - computing graph setted. doing all the computing.\n2025-09-18 12:29:04 - pc_intersect - INFO - computing finished.0.1s\n2025-09-18 12:29:04 - pc_intersect - INFO - dask cluster closed.\n\n\n\nsource\n\n\npc_diff\n\n pc_diff (idx1:str, idx2:str, idx:str, pc1:str|list=None,\n          pc:str|list=None, shape:tuple=None, chunks:int=None,\n          processes=False, n_workers=1, threads_per_worker=1,\n          **dask_cluster_arg)\n\nGet the point cloud in idx1 that are not in idx2. pc_chunk_size and n_pc_chunk are used to determine the final pc_chunk_size. If non of them are provided, the n_pc_chunk is set to n_chunk in idx1.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nidx1\nstr\n\ngrid index or hillbert index of the first point cloud\n\n\nidx2\nstr\n\ngrid index or hillbert index of the second point cloud\n\n\nidx\nstr\n\noutput, grid index or hillbert index of the union point cloud\n\n\npc1\nstr | list\nNone\npath (in string) or list of path for the first point cloud data\n\n\npc\nstr | list\nNone\noutput, path (in string) or list of path for the union point cloud data\n\n\nshape\ntuple\nNone\nimage shape, faster if provided for grid index input\n\n\nchunks\nint\nNone\nchunk size in output data,optional\n\n\nprocesses\nbool\nFalse\nuse process for dask worker or thread\n\n\nn_workers\nint\n1\nnumber of dask worker\n\n\nthreads_per_worker\nint\n1\nnumber of threads per dask worker\n\n\ndask_cluster_arg\nVAR_KEYWORD\n\n\n\n\n\nUsage:\n\npc_data1 = np.random.rand(1000,3).astype(np.float32)+1j*np.random.rand(1000,3).astype(np.float32)\n\ngix1 = np.random.choice(np.arange(100*100,dtype=np.int32),size=1000,replace=False)\ngix1.sort()\ngix1 = np.stack(np.unravel_index(gix1,shape=(100,100)),axis=-1).astype(np.int32)\n\ngix2 = np.random.choice(np.arange(100*100,dtype=np.int32),size=800,replace=False)\ngix2.sort()\ngix2 = np.stack(np.unravel_index(gix2,shape=(100,100)),axis=-1).astype(np.int32)\n\ngix, iidx1 = mr.pc_diff(gix1,gix2)\n\npc_data = np.empty((gix.shape[0],*pc_data1.shape[1:]),dtype=pc_data1.dtype)\npc_data[:] = pc_data1[iidx1]\n\ngix1_zarr = zarr.open('pc/gix1.zarr',mode='w',shape=gix1.shape,dtype=gix1.dtype,chunks=(200,1))\ngix2_zarr = zarr.open('pc/gix2.zarr',mode='w',shape=gix2.shape,dtype=gix2.dtype,chunks=(200,1))\npc1_zarr = zarr.open('pc/pc1.zarr',mode='w',shape=pc_data1.shape,dtype=pc_data1.dtype,chunks=(200,1))\ngix1_zarr[:] = gix1\ngix2_zarr[:] = gix2\npc1_zarr[:] = pc_data1\n\n\npc_diff('pc/gix1.zarr','pc/gix2.zarr','pc/gix.zarr')\npc_diff('pc/gix1.zarr','pc/gix2.zarr','pc/gix.zarr',pc1='pc/pc1.zarr', pc='pc/pc.zarr')\ngix_zarr = zarr.open('pc/gix.zarr',mode='r')\npc_zarr = zarr.open('pc/pc.zarr',mode='r')\nnp.testing.assert_array_equal(gix_zarr[:],gix)\nnp.testing.assert_array_equal(pc_zarr[:],pc_data)\n\n2025-09-18 12:29:05 - log_args - INFO - running function: pc_diff\n2025-09-18 12:29:05 - log_args - INFO - fetching args:\n2025-09-18 12:29:05 - log_args - INFO - idx1 = 'pc/gix1.zarr'\n2025-09-18 12:29:05 - log_args - INFO - idx2 = 'pc/gix2.zarr'\n2025-09-18 12:29:05 - log_args - INFO - idx = 'pc/gix.zarr'\n2025-09-18 12:29:05 - log_args - INFO - pc1 = None\n2025-09-18 12:29:05 - log_args - INFO - pc = None\n2025-09-18 12:29:05 - log_args - INFO - shape = None\n2025-09-18 12:29:05 - log_args - INFO - chunks = None\n2025-09-18 12:29:05 - log_args - INFO - processes = False\n2025-09-18 12:29:05 - log_args - INFO - n_workers = 1\n2025-09-18 12:29:05 - log_args - INFO - threads_per_worker = 1\n2025-09-18 12:29:05 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 12:29:05 - log_args - INFO - fetching args done.\n2025-09-18 12:29:05 - zarr_info - INFO - pc/gix1.zarr zarray shape, chunks, dtype: (1000, 2), (200, 1), int32\n2025-09-18 12:29:05 - zarr_info - INFO - pc/gix2.zarr zarray shape, chunks, dtype: (800, 2), (200, 1), int32\n2025-09-18 12:29:05 - pc_diff - INFO - loading idx1 and idx2 into memory.\n2025-09-18 12:29:05 - pc_diff - INFO - calculate the diff.\n2025-09-18 12:29:05 - pc_diff - INFO - number of points in the diff: 915\n2025-09-18 12:29:06 - pc_diff - INFO - write intersect idx\n2025-09-18 12:29:06 - pc_diff - INFO - write done\n2025-09-18 12:29:06 - zarr_info - INFO - pc/gix.zarr zarray shape, chunks, dtype: (915, 2), (200, 1), int32\n2025-09-18 12:29:06 - pc_diff - INFO - no point cloud data provided, exit.\n2025-09-18 12:29:06 - log_args - INFO - running function: pc_diff\n2025-09-18 12:29:06 - log_args - INFO - fetching args:\n2025-09-18 12:29:06 - log_args - INFO - idx1 = 'pc/gix1.zarr'\n2025-09-18 12:29:06 - log_args - INFO - idx2 = 'pc/gix2.zarr'\n2025-09-18 12:29:06 - log_args - INFO - idx = 'pc/gix.zarr'\n2025-09-18 12:29:06 - log_args - INFO - pc1 = 'pc/pc1.zarr'\n2025-09-18 12:29:06 - log_args - INFO - pc = 'pc/pc.zarr'\n2025-09-18 12:29:06 - log_args - INFO - shape = None\n2025-09-18 12:29:06 - log_args - INFO - chunks = None\n2025-09-18 12:29:06 - log_args - INFO - processes = False\n2025-09-18 12:29:06 - log_args - INFO - n_workers = 1\n2025-09-18 12:29:06 - log_args - INFO - threads_per_worker = 1\n2025-09-18 12:29:06 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 12:29:06 - log_args - INFO - fetching args done.\n2025-09-18 12:29:06 - zarr_info - INFO - pc/gix1.zarr zarray shape, chunks, dtype: (1000, 2), (200, 1), int32\n2025-09-18 12:29:06 - zarr_info - INFO - pc/gix2.zarr zarray shape, chunks, dtype: (800, 2), (200, 1), int32\n2025-09-18 12:29:06 - pc_diff - INFO - loading idx1 and idx2 into memory.\n2025-09-18 12:29:06 - pc_diff - INFO - calculate the diff.\n2025-09-18 12:29:06 - pc_diff - INFO - number of points in the diff: 915\n2025-09-18 12:29:06 - pc_diff - INFO - write intersect idx\n2025-09-18 12:29:06 - pc_diff - INFO - write done\n2025-09-18 12:29:06 - zarr_info - INFO - pc/gix.zarr zarray shape, chunks, dtype: (915, 2), (200, 1), int32\n2025-09-18 12:29:06 - pc_diff - INFO - starting dask local cluster.\n2025-09-18 12:29:06 - pc_diff - INFO - dask local cluster started.\n2025-09-18 12:29:06 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.4:8787/status', workers=1, threads=1, memory=256.00 GiB)\n2025-09-18 12:29:06 - zarr_info - INFO - pc/pc1.zarr zarray shape, chunks, dtype: (1000, 3), (200, 1), complex64\n2025-09-18 12:29:06 - darr_info - INFO - pc1 dask array shape, chunksize, dtype: (1000, 3), (1000, 1), complex64\n2025-09-18 12:29:06 - pc_diff - INFO - set up diff pc data dask array.\n2025-09-18 12:29:06 - darr_info - INFO - pc dask array shape, chunksize, dtype: (915, 3), (915, 1), complex64\n2025-09-18 12:29:06 - pc_diff - INFO - write pc to pc/pc.zarr\n2025-09-18 12:29:06 - zarr_info - INFO - pc/pc.zarr zarray shape, chunks, dtype: (915, 3), (200, 1), complex64\n2025-09-18 12:29:06 - pc_diff - INFO - computing graph setted. doing all the computing.\n2025-09-18 12:29:06 - pc_diff - INFO - computing finished.d |  0.1s\n2025-09-18 12:29:06 - pc_diff - INFO - dask cluster closed.\n\n\n\npc_data1 = np.random.rand(1000,3).astype(np.float32)+1j*np.random.rand(1000,3).astype(np.float32)\n\nhix1 = np.random.choice(np.arange(100*100,dtype=np.int64),size=1000,replace=False)\nhix1.sort()\n\nhix2 = np.random.choice(np.arange(100*100,dtype=np.int64),size=800,replace=False)\nhix2.sort()\n\nhix, iidx1 = mr.pc_diff(hix1,hix2)\n\npc_data = np.empty((hix.shape[-1],*pc_data1.shape[1:]),dtype=pc_data1.dtype)\npc_data[:] = pc_data1[iidx1]\n\nhix1_zarr = zarr.open('pc/hix1.zarr',mode='w',shape=hix1.shape,dtype=hix1.dtype,chunks=(200,))\nhix2_zarr = zarr.open('pc/hix2.zarr',mode='w',shape=hix2.shape,dtype=hix2.dtype,chunks=(200,))\npc1_zarr = zarr.open('pc/pc1.zarr',mode='w',shape=pc_data1.shape,dtype=pc_data1.dtype,chunks=(200,1))\nhix1_zarr[:] = hix1\nhix2_zarr[:] = hix2\npc1_zarr[:] = pc_data1\n\n\npc_diff('pc/hix1.zarr','pc/hix2.zarr','pc/hix.zarr')\npc_diff('pc/hix1.zarr','pc/hix2.zarr','pc/hix.zarr',pc1='pc/pc1.zarr', pc='pc/pc.zarr')\nhix_zarr = zarr.open('pc/hix.zarr',mode='r')\npc_zarr = zarr.open('pc/pc.zarr',mode='r')\nnp.testing.assert_array_equal(hix_zarr[:],hix)\nnp.testing.assert_array_equal(pc_zarr[:],pc_data)\n\n2025-09-18 12:29:07 - log_args - INFO - running function: pc_diff\n2025-09-18 12:29:07 - log_args - INFO - fetching args:\n2025-09-18 12:29:07 - log_args - INFO - idx1 = 'pc/hix1.zarr'\n2025-09-18 12:29:07 - log_args - INFO - idx2 = 'pc/hix2.zarr'\n2025-09-18 12:29:07 - log_args - INFO - idx = 'pc/hix.zarr'\n2025-09-18 12:29:07 - log_args - INFO - pc1 = None\n2025-09-18 12:29:07 - log_args - INFO - pc = None\n2025-09-18 12:29:07 - log_args - INFO - shape = None\n2025-09-18 12:29:07 - log_args - INFO - chunks = None\n2025-09-18 12:29:07 - log_args - INFO - processes = False\n2025-09-18 12:29:07 - log_args - INFO - n_workers = 1\n2025-09-18 12:29:07 - log_args - INFO - threads_per_worker = 1\n2025-09-18 12:29:07 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 12:29:07 - log_args - INFO - fetching args done.\n2025-09-18 12:29:07 - zarr_info - INFO - pc/hix1.zarr zarray shape, chunks, dtype: (1000,), (200,), int64\n2025-09-18 12:29:07 - zarr_info - INFO - pc/hix2.zarr zarray shape, chunks, dtype: (800,), (200,), int64\n2025-09-18 12:29:07 - pc_diff - INFO - loading idx1 and idx2 into memory.\n2025-09-18 12:29:07 - pc_diff - INFO - calculate the diff.\n2025-09-18 12:29:07 - pc_diff - INFO - number of points in the diff: 911\n2025-09-18 12:29:07 - pc_diff - INFO - write intersect idx\n2025-09-18 12:29:07 - pc_diff - INFO - write done\n2025-09-18 12:29:07 - zarr_info - INFO - pc/hix.zarr zarray shape, chunks, dtype: (911,), (200,), int64\n2025-09-18 12:29:07 - pc_diff - INFO - no point cloud data provided, exit.\n2025-09-18 12:29:07 - log_args - INFO - running function: pc_diff\n2025-09-18 12:29:07 - log_args - INFO - fetching args:\n2025-09-18 12:29:07 - log_args - INFO - idx1 = 'pc/hix1.zarr'\n2025-09-18 12:29:07 - log_args - INFO - idx2 = 'pc/hix2.zarr'\n2025-09-18 12:29:07 - log_args - INFO - idx = 'pc/hix.zarr'\n2025-09-18 12:29:07 - log_args - INFO - pc1 = 'pc/pc1.zarr'\n2025-09-18 12:29:07 - log_args - INFO - pc = 'pc/pc.zarr'\n2025-09-18 12:29:07 - log_args - INFO - shape = None\n2025-09-18 12:29:07 - log_args - INFO - chunks = None\n2025-09-18 12:29:07 - log_args - INFO - processes = False\n2025-09-18 12:29:07 - log_args - INFO - n_workers = 1\n2025-09-18 12:29:07 - log_args - INFO - threads_per_worker = 1\n2025-09-18 12:29:07 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 12:29:07 - log_args - INFO - fetching args done.\n2025-09-18 12:29:07 - zarr_info - INFO - pc/hix1.zarr zarray shape, chunks, dtype: (1000,), (200,), int64\n2025-09-18 12:29:07 - zarr_info - INFO - pc/hix2.zarr zarray shape, chunks, dtype: (800,), (200,), int64\n2025-09-18 12:29:07 - pc_diff - INFO - loading idx1 and idx2 into memory.\n2025-09-18 12:29:07 - pc_diff - INFO - calculate the diff.\n2025-09-18 12:29:07 - pc_diff - INFO - number of points in the diff: 911\n2025-09-18 12:29:07 - pc_diff - INFO - write intersect idx\n2025-09-18 12:29:07 - pc_diff - INFO - write done\n2025-09-18 12:29:07 - zarr_info - INFO - pc/hix.zarr zarray shape, chunks, dtype: (911,), (200,), int64\n2025-09-18 12:29:07 - pc_diff - INFO - starting dask local cluster.\n2025-09-18 12:29:07 - pc_diff - INFO - dask local cluster started.\n2025-09-18 12:29:07 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.4:8787/status', workers=1, threads=1, memory=256.00 GiB)\n2025-09-18 12:29:07 - zarr_info - INFO - pc/pc1.zarr zarray shape, chunks, dtype: (1000, 3), (200, 1), complex64\n2025-09-18 12:29:07 - darr_info - INFO - pc1 dask array shape, chunksize, dtype: (1000, 3), (1000, 1), complex64\n2025-09-18 12:29:07 - pc_diff - INFO - set up diff pc data dask array.\n2025-09-18 12:29:07 - darr_info - INFO - pc dask array shape, chunksize, dtype: (911, 3), (911, 1), complex64\n2025-09-18 12:29:07 - pc_diff - INFO - write pc to pc/pc.zarr\n2025-09-18 12:29:07 - zarr_info - INFO - pc/pc.zarr zarray shape, chunks, dtype: (911, 3), (200, 1), complex64\n2025-09-18 12:29:07 - pc_diff - INFO - computing graph setted. doing all the computing.\n2025-09-18 12:29:07 - pc_diff - INFO - computing finished.d |  0.1s\n2025-09-18 12:29:07 - pc_diff - INFO - dask cluster closed.\n\n\n\nsource\n\n\npc_logic_ras\n\n pc_logic_ras (ras, gix, operation:str, chunks:int=100000)\n\ngenerate point cloud index based on logical operation of one raster image.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nras\n\n\nthe raster image used for thresholding\n\n\ngix\n\n\noutput, grid index of selected pixels\n\n\noperation\nstr\n\nlogical operation on input ras\n\n\nchunks\nint\n100000\nchunk size in output data, optional\n\n\n\n\nras = np.random.rand(100,100).astype(np.float32)\nmin_thres = 0.1; max_thres=0.5\nis_pc = (ras&gt;=min_thres) & (ras&lt;=max_thres)\ngix = np.stack(np.where(is_pc),axis=-1).astype(np.int32)\nras_zarr = zarr.open('pc/ras.zarr',mode='w',shape=ras.shape,dtype=ras.dtype,chunks=(10,100))\nras_zarr[:] = ras\n\n\npc_logic_ras('pc/ras.zarr','pc/gix.zarr',f'(ras&gt;={min_thres})&(ras&lt;={max_thres})')\ngix_zarr = zarr.open('pc/gix.zarr',mode='r')\nnp.testing.assert_array_equal(gix_zarr[:],gix)\n\n2025-09-18 12:29:08 - log_args - INFO - running function: pc_logic_ras\n2025-09-18 12:29:08 - log_args - INFO - fetching args:\n2025-09-18 12:29:08 - log_args - INFO - ras = 'pc/ras.zarr'\n2025-09-18 12:29:08 - log_args - INFO - gix = 'pc/gix.zarr'\n2025-09-18 12:29:08 - log_args - INFO - operation = '(ras&gt;=0.1)&(ras&lt;=0.5)'\n2025-09-18 12:29:08 - log_args - INFO - chunks = 100000\n2025-09-18 12:29:08 - log_args - INFO - fetching args done.\n2025-09-18 12:29:08 - zarr_info - INFO - pc/ras.zarr zarray shape, chunks, dtype: (100, 100), (10, 100), float32\n2025-09-18 12:29:08 - pc_logic_ras - INFO - loading ras into memory.\n2025-09-18 12:29:08 - pc_logic_ras - INFO - select pc based on operation: (ras&gt;=0.1)&(ras&lt;=0.5)\n2025-09-18 12:29:08 - pc_logic_ras - INFO - number of selected pixels: 3928.\n2025-09-18 12:29:08 - zarr_info - INFO - pc/gix.zarr zarray shape, chunks, dtype: (3928, 2), (100000, 1), int32\n2025-09-18 12:29:08 - pc_logic_ras - INFO - writing gix.\n2025-09-18 12:29:08 - pc_logic_ras - INFO - write done.\n\n\n\nsource\n\n\npc_logic_pc\n\n pc_logic_pc (idx_in:str, pc_in:str, idx:str, operation:str,\n              chunks:int=None)\n\ngenerate point cloud index and data based on logical operation one point cloud data.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nidx_in\nstr\n\nthe grid index or hillbert index of input pc data\n\n\npc_in\nstr\n\nthe grid index or hillbert index cloud data used for thresholding\n\n\nidx\nstr\n\noutput, grid index or hillbert index of selected pixels\n\n\noperation\nstr\n\noperator\n\n\nchunks\nint\nNone\nchunk size in output data,optional\n\n\n\nUsage:\n\npc_in = np.random.rand(1000).astype(np.float32)\ngix_in = np.random.choice(np.arange(100*100,dtype=np.int32),size=1000,replace=False)\ngix_in.sort()\ngix_in = np.stack(np.unravel_index(gix_in,shape=(100,100)),axis=-1).astype(np.int32)\n\nmin_thres = 0.1; max_thres=0.5\nis_pc = (pc_in&gt;=min_thres) & (pc_in&lt;=max_thres)\ngix = gix_in[is_pc]\npc_in_zarr = zarr.open('pc/pc_in.zarr',mode='w',shape=pc_in.shape,dtype=pc_in.dtype,chunks=(100,))\ngix_in_zarr = zarr.open('pc/gix_in.zarr',mode='w',shape=gix_in.shape,dtype=gix_in.dtype,chunks=(100,1))\npc_in_zarr[:] = pc_in; gix_in_zarr[:] = gix_in\n\n\npc_logic_pc('pc/gix_in.zarr','pc/pc_in.zarr','pc/gix.zarr',f'(pc_in&gt;={min_thres})&(pc_in&lt;={max_thres})')\ngix_zarr = zarr.open('pc/gix.zarr',mode='r')\nnp.testing.assert_array_equal(gix_zarr[:],gix)\n\n2025-09-18 12:29:10 - log_args - INFO - running function: pc_logic_pc\n2025-09-18 12:29:10 - log_args - INFO - fetching args:\n2025-09-18 12:29:10 - log_args - INFO - idx_in = 'pc/gix_in.zarr'\n2025-09-18 12:29:10 - log_args - INFO - pc_in = 'pc/pc_in.zarr'\n2025-09-18 12:29:10 - log_args - INFO - idx = 'pc/gix.zarr'\n2025-09-18 12:29:10 - log_args - INFO - operation = '(pc_in&gt;=0.1)&(pc_in&lt;=0.5)'\n2025-09-18 12:29:10 - log_args - INFO - chunks = None\n2025-09-18 12:29:10 - log_args - INFO - fetching args done.\n2025-09-18 12:29:10 - zarr_info - INFO - pc/gix_in.zarr zarray shape, chunks, dtype: (1000, 2), (100, 1), int32\n2025-09-18 12:29:10 - zarr_info - INFO - pc/pc_in.zarr zarray shape, chunks, dtype: (1000,), (100,), float32\n2025-09-18 12:29:10 - pc_logic_pc - INFO - loading idx_in into memory.\n2025-09-18 12:29:10 - pc_logic_pc - INFO - loading pc_in into memory.\n2025-09-18 12:29:10 - pc_logic_pc - INFO - select pc based on operation: (pc_in&gt;=0.1)&(pc_in&lt;=0.5)\n2025-09-18 12:29:10 - pc_logic_pc - INFO - number of selected pixels: 399.\n2025-09-18 12:29:10 - zarr_info - INFO - idx zarray shape, chunks, dtype: (399, 2), (100, 1), int32\n2025-09-18 12:29:10 - pc_logic_pc - INFO - writing idx.\n2025-09-18 12:29:10 - pc_logic_pc - INFO - write done.\n\n\n\npc_in = np.random.rand(1000).astype(np.float32)\nhix_in = np.random.choice(np.arange(100*100,dtype=np.int64),size=1000,replace=False)\nhix_in.sort()\n\nmin_thres = 0.1; max_thres=0.5\nis_pc = (pc_in&gt;=min_thres) & (pc_in&lt;=max_thres)\nhix = hix_in[is_pc]\npc_in_zarr = zarr.open('pc/pc_in.zarr',mode='w',shape=pc_in.shape,dtype=pc_in.dtype,chunks=(100,))\nhix_in_zarr = zarr.open('pc/hix_in.zarr',mode='w',shape=hix_in.shape,dtype=hix_in.dtype,chunks=(100,))\npc_in_zarr[:] = pc_in; hix_in_zarr[:] = hix_in\n\npc_logic_pc('pc/hix_in.zarr','pc/pc_in.zarr','pc/hix.zarr',f'(pc_in&gt;={min_thres})&(pc_in&lt;={max_thres})')\nhix_zarr = zarr.open('pc/hix.zarr',mode='r')\nnp.testing.assert_array_equal(hix_zarr[:],hix)\n\n2025-09-18 12:29:11 - log_args - INFO - running function: pc_logic_pc\n2025-09-18 12:29:11 - log_args - INFO - fetching args:\n2025-09-18 12:29:11 - log_args - INFO - idx_in = 'pc/hix_in.zarr'\n2025-09-18 12:29:11 - log_args - INFO - pc_in = 'pc/pc_in.zarr'\n2025-09-18 12:29:11 - log_args - INFO - idx = 'pc/hix.zarr'\n2025-09-18 12:29:11 - log_args - INFO - operation = '(pc_in&gt;=0.1)&(pc_in&lt;=0.5)'\n2025-09-18 12:29:11 - log_args - INFO - chunks = None\n2025-09-18 12:29:11 - log_args - INFO - fetching args done.\n2025-09-18 12:29:11 - zarr_info - INFO - pc/hix_in.zarr zarray shape, chunks, dtype: (1000,), (100,), int64\n2025-09-18 12:29:11 - zarr_info - INFO - pc/pc_in.zarr zarray shape, chunks, dtype: (1000,), (100,), float32\n2025-09-18 12:29:11 - pc_logic_pc - INFO - loading idx_in into memory.\n2025-09-18 12:29:11 - pc_logic_pc - INFO - loading pc_in into memory.\n2025-09-18 12:29:11 - pc_logic_pc - INFO - select pc based on operation: (pc_in&gt;=0.1)&(pc_in&lt;=0.5)\n2025-09-18 12:29:11 - pc_logic_pc - INFO - number of selected pixels: 393.\n2025-09-18 12:29:11 - zarr_info - INFO - idx zarray shape, chunks, dtype: (393,), (100,), int64\n2025-09-18 12:29:11 - pc_logic_pc - INFO - writing idx.\n2025-09-18 12:29:11 - pc_logic_pc - INFO - write done.\n\n\n\nsource\n\n\npc_select_data\n\n pc_select_data (idx_in:str, idx:str, pc_in:str|list, pc:str|list,\n                 shape:tuple=None, chunks:int=None, processes=False,\n                 n_workers=1, threads_per_worker=1, **dask_cluster_arg)\n\ngenerate point cloud data based on its index and one point cloud data. The index of generated point cloud data must in the index of the old one.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nidx_in\nstr\n\nthe grid index or hillbert index of the input data\n\n\nidx\nstr\n\nthe grid index or hillbert index of the output data\n\n\npc_in\nstr | list\n\npath (in string) or list of path for the input point cloud data\n\n\npc\nstr | list\n\noutput, path (in string) or list of path for the output point cloud data\n\n\nshape\ntuple\nNone\nshape of the raster data the point cloud from, must be provided if idx is hix\n\n\nchunks\nint\nNone\nchunk size in output data, same as chunks of idx by default\n\n\nprocesses\nbool\nFalse\nuse process for dask worker or thread\n\n\nn_workers\nint\n1\nnumber of dask worker\n\n\nthreads_per_worker\nint\n1\nnumber of threads per dask worker\n\n\ndask_cluster_arg\nVAR_KEYWORD\n\n\n\n\n\n\npc_in = np.random.rand(1000,4).astype(np.float32)\ngix_in = np.random.choice(np.arange(100*100,dtype=np.int32),size=1000,replace=False)\ngix_in.sort()\ngix_in = np.stack(np.unravel_index(gix_in,shape=(100,100)),axis=-1).astype(np.int32)\n\niidx_in = np.random.choice(np.arange(1000,dtype=np.int64),size=500,replace=False); iidx_in.sort()\ngix = gix_in[iidx_in]\npc = pc_in[iidx_in]\n\npc_in_zarr = zarr.open('pc/pc_in.zarr',mode='w',shape=pc_in.shape,dtype=pc_in.dtype,chunks=(100,1))\ngix_in_zarr = zarr.open('pc/gix_in.zarr',mode='w',shape=gix_in.shape,dtype=gix_in.dtype,chunks=(100,1))\ngix_zarr = zarr.open('pc/gix.zarr',mode='w',shape=gix.shape,dtype=gix.dtype,chunks=(100,1))\npc_in_zarr[:] = pc_in; gix_in_zarr[:] = gix_in; gix_zarr[:] = gix\n\n\npc_select_data('pc/gix_in.zarr','pc/gix.zarr','pc/pc_in.zarr','pc/pc.zarr')\npc_zarr = zarr.open('pc/pc.zarr',mode='r')\nnp.testing.assert_array_equal(pc_zarr[:],pc)\n\n2025-09-18 12:29:12 - log_args - INFO - running function: pc_select_data\n2025-09-18 12:29:12 - log_args - INFO - fetching args:\n2025-09-18 12:29:12 - log_args - INFO - idx_in = 'pc/gix_in.zarr'\n2025-09-18 12:29:12 - log_args - INFO - idx = 'pc/gix.zarr'\n2025-09-18 12:29:12 - log_args - INFO - pc_in = 'pc/pc_in.zarr'\n2025-09-18 12:29:12 - log_args - INFO - pc = 'pc/pc.zarr'\n2025-09-18 12:29:12 - log_args - INFO - shape = None\n2025-09-18 12:29:12 - log_args - INFO - chunks = None\n2025-09-18 12:29:12 - log_args - INFO - processes = False\n2025-09-18 12:29:12 - log_args - INFO - n_workers = 1\n2025-09-18 12:29:12 - log_args - INFO - threads_per_worker = 1\n2025-09-18 12:29:12 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 12:29:12 - log_args - INFO - fetching args done.\n2025-09-18 12:29:12 - zarr_info - INFO - pc/gix_in.zarr zarray shape, chunks, dtype: (1000, 2), (100, 1), int32\n2025-09-18 12:29:12 - zarr_info - INFO - pc/gix.zarr zarray shape, chunks, dtype: (500, 2), (100, 1), int32\n2025-09-18 12:29:12 - pc_select_data - INFO - loading idx_in and idx into memory.\n2025-09-18 12:29:12 - pc_select_data - INFO - starting dask local cluster.\n2025-09-18 12:29:12 - pc_select_data - INFO - dask local cluster started.\n2025-09-18 12:29:12 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.4:8787/status', workers=1, threads=1, memory=256.00 GiB)\n2025-09-18 12:29:12 - zarr_info - INFO - pc/pc_in.zarr zarray shape, chunks, dtype: (1000, 4), (100, 1), float32\n2025-09-18 12:29:12 - darr_info - INFO - pc_in dask array shape, chunksize, dtype: (1000, 4), (1000, 1), float32\n2025-09-18 12:29:12 - pc_select_data - INFO - set up selected pc data dask array.\n2025-09-18 12:29:12 - darr_info - INFO - pc dask array shape, chunksize, dtype: (500, 4), (500, 1), float32\n2025-09-18 12:29:12 - pc_select_data - INFO - write pc to pc/pc.zarr\n2025-09-18 12:29:12 - zarr_info - INFO - pc/pc.zarr zarray shape, chunks, dtype: (500, 4), (100, 1), float32\n2025-09-18 12:29:12 - pc_select_data - INFO - computing graph setted. doing all the computing.\n2025-09-18 12:29:12 - pc_select_data - INFO - computing finished.2s\n2025-09-18 12:29:12 - pc_select_data - INFO - dask cluster closed.\n\n\n\npc_in = np.random.rand(1000).astype(np.float32)\nhix_in = np.random.choice(np.arange(100*100,dtype=np.int64),size=1000,replace=False)\nhix_in.sort()\n\niidx_in = np.random.choice(np.arange(1000,dtype=np.int64),size=500,replace=False)\niidx_in.sort()\n\nhix = hix_in[iidx_in]\npc = pc_in[iidx_in]\n\npc_in_zarr = zarr.open('pc/pc_in.zarr',mode='w',shape=pc_in.shape,dtype=pc_in.dtype,chunks=(100,))\nhix_in_zarr = zarr.open('pc/hix_in.zarr',mode='w',shape=hix_in.shape,dtype=hix_in.dtype,chunks=(100,))\nhix_zarr = zarr.open('pc/hix.zarr',mode='w',shape=hix.shape,dtype=hix.dtype,chunks=(100,))\npc_in_zarr[:] = pc_in; hix_in_zarr[:] = hix_in; hix_zarr[:] = hix\n\npc_select_data('pc/hix_in.zarr','pc/hix.zarr','pc/pc_in.zarr','pc/pc.zarr')\npc_zarr = zarr.open('pc/pc.zarr',mode='r')\nnp.testing.assert_array_equal(pc_zarr[:],pc)\n\n2025-09-18 12:29:13 - log_args - INFO - running function: pc_select_data\n2025-09-18 12:29:13 - log_args - INFO - fetching args:\n2025-09-18 12:29:13 - log_args - INFO - idx_in = 'pc/hix_in.zarr'\n2025-09-18 12:29:13 - log_args - INFO - idx = 'pc/hix.zarr'\n2025-09-18 12:29:13 - log_args - INFO - pc_in = 'pc/pc_in.zarr'\n2025-09-18 12:29:13 - log_args - INFO - pc = 'pc/pc.zarr'\n2025-09-18 12:29:13 - log_args - INFO - shape = None\n2025-09-18 12:29:13 - log_args - INFO - chunks = None\n2025-09-18 12:29:13 - log_args - INFO - processes = False\n2025-09-18 12:29:13 - log_args - INFO - n_workers = 1\n2025-09-18 12:29:13 - log_args - INFO - threads_per_worker = 1\n2025-09-18 12:29:13 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 12:29:13 - log_args - INFO - fetching args done.\n2025-09-18 12:29:13 - zarr_info - INFO - pc/hix_in.zarr zarray shape, chunks, dtype: (1000,), (100,), int64\n2025-09-18 12:29:13 - zarr_info - INFO - pc/hix.zarr zarray shape, chunks, dtype: (500,), (100,), int64\n2025-09-18 12:29:13 - pc_select_data - INFO - loading idx_in and idx into memory.\n2025-09-18 12:29:13 - pc_select_data - INFO - starting dask local cluster.\n2025-09-18 12:29:13 - pc_select_data - INFO - dask local cluster started.\n2025-09-18 12:29:13 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.4:8787/status', workers=1, threads=1, memory=256.00 GiB)\n2025-09-18 12:29:13 - zarr_info - INFO - pc/pc_in.zarr zarray shape, chunks, dtype: (1000,), (100,), float32\n2025-09-18 12:29:13 - darr_info - INFO - pc_in dask array shape, chunksize, dtype: (1000,), (1000,), float32\n2025-09-18 12:29:13 - pc_select_data - INFO - set up selected pc data dask array.\n2025-09-18 12:29:13 - darr_info - INFO - pc dask array shape, chunksize, dtype: (500,), (500,), float32\n2025-09-18 12:29:13 - pc_select_data - INFO - write pc to pc/pc.zarr\n2025-09-18 12:29:13 - zarr_info - INFO - pc/pc.zarr zarray shape, chunks, dtype: (500,), (100,), float32\n2025-09-18 12:29:13 - pc_select_data - INFO - computing graph setted. doing all the computing.\n2025-09-18 12:29:13 - pc_select_data - INFO - computing finished.1s\n2025-09-18 12:29:13 - pc_select_data - INFO - dask cluster closed.\n\n\n\nsource\n\n\ndata_reduce\n\n data_reduce (data_in:str, out:str, map_func:Callable=None,\n              reduce_func:Callable=&lt;function mean at 0x7f9f1ad17d70&gt;,\n              axis=0, post_map_func:Callable=None, processes=False,\n              n_workers=1, threads_per_worker=1, **dask_cluster_arg)\n\nreduction operation for dataset.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ndata_in\nstr\n\npath (in string) for the input data\n\n\nout\nstr\n\noutput, path (in string) for the output data\n\n\nmap_func\nCallable\nNone\nelementwise mapping function for input, no mapping by default\n\n\nreduce_func\nCallable\nmean\nreduction function after mapping, np.mean by default\n\n\naxis\nint\n0\naxis to be reduced, 0 for point cloud data, (0,1) for raster data\n\n\npost_map_func\nCallable\nNone\npost mapping after reduction, no mapping by default\n\n\nprocesses\nbool\nFalse\nuse process for dask worker or thread\n\n\nn_workers\nint\n1\nnumber of dask worker\n\n\nthreads_per_worker\nint\n1\nnumber of threads per dask worker\n\n\ndask_cluster_arg\nVAR_KEYWORD\n\n\n\n\n\n\npc_in1 = np.random.rand(1000).astype(np.float32)+1j*np.random.rand(1000).astype(np.float32)\npc_in2 = np.random.rand(800,3).astype(np.float32)+1j*np.random.rand(800,3).astype(np.float32)\n\npc1_zarr = zarr.open('pc/pc_in1.zarr',mode='w',shape=pc_in1.shape,dtype=pc_data1.dtype,chunks=(200))\npc2_zarr = zarr.open('pc/pc_in2.zarr',mode='w',shape=pc_in2.shape,dtype=pc_data2.dtype,chunks=(200,1))\npc1_zarr[:] = pc_in1\npc2_zarr[:] = pc_in2\n\n\ndata_reduce('pc/pc_in1.zarr','pc/pc_out1.zarr',map_func=np.abs,reduce_func=np.sum,post_map_func=lambda x: x/1000)\ndata_reduce('pc/pc_in2.zarr','pc/pc_out2.zarr',map_func=np.abs,reduce_func=np.sum,post_map_func=lambda x: x/800)\nnp.testing.assert_array_almost_equal(zarr.open('pc/pc_out1.zarr',mode='r')[:][0], np.mean(np.abs(pc_in1),axis=0))\nnp.testing.assert_array_almost_equal(zarr.open('pc/pc_out2.zarr',mode='r')[:], np.mean(np.abs(pc_in2),axis=0))\n\n2025-09-18 12:29:14 - log_args - INFO - running function: data_reduce\n2025-09-18 12:29:14 - log_args - INFO - fetching args:\n2025-09-18 12:29:14 - log_args - INFO - data_in = 'pc/pc_in1.zarr'\n2025-09-18 12:29:14 - log_args - INFO - out = 'pc/pc_out1.zarr'\n2025-09-18 12:29:14 - log_args - INFO - map_func = &lt;ufunc 'absolute'&gt;\n2025-09-18 12:29:14 - log_args - INFO - reduce_func = &lt;function sum&gt;\n2025-09-18 12:29:14 - log_args - INFO - axis = 0\n2025-09-18 12:29:14 - log_args - INFO - post_map_func = &lt;function &lt;lambda&gt;&gt;\n2025-09-18 12:29:14 - log_args - INFO - processes = False\n2025-09-18 12:29:14 - log_args - INFO - n_workers = 1\n2025-09-18 12:29:14 - log_args - INFO - threads_per_worker = 1\n2025-09-18 12:29:14 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 12:29:14 - log_args - INFO - fetching args done.\n2025-09-18 12:29:14 - zarr_info - INFO - pc/pc_in1.zarr zarray shape, chunks, dtype: (1000,), (200,), complex64\n2025-09-18 12:29:14 - data_reduce - INFO - starting dask local cluster.\n2025-09-18 12:29:14 - data_reduce - INFO - dask local cluster started.\n2025-09-18 12:29:14 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.4:8787/status', workers=1, threads=1, memory=256.00 GiB)\n2025-09-18 12:29:14 - darr_info - INFO - data_in dask array shape, chunksize, dtype: (1000,), (200,), complex64\n2025-09-18 12:29:14 - darr_info - INFO - maped_data_in dask array shape, chunksize, dtype: (1000,), (200,), float32\n2025-09-18 12:29:14 - darr_info - INFO - reduced data in every chunk dask array shape, chunksize, dtype: (5,), (1,), float32\n2025-09-18 12:29:14 - data_reduce - INFO - computing graph setted. doing all the computing.\n2025-09-18 12:29:14 - data_reduce - INFO - computing finished. 0.1s\n2025-09-18 12:29:14 - data_reduce - INFO - dask cluster closed.\n2025-09-18 12:29:14 - data_reduce - INFO - continue the reduction on reduced data over every chunk\n2025-09-18 12:29:14 - data_reduce - INFO - post mapping\n2025-09-18 12:29:14 - data_reduce - INFO - writing output.\n2025-09-18 12:29:14 - data_reduce - INFO - done.\n2025-09-18 12:29:14 - log_args - INFO - running function: data_reduce\n2025-09-18 12:29:14 - log_args - INFO - fetching args:\n2025-09-18 12:29:14 - log_args - INFO - data_in = 'pc/pc_in2.zarr'\n2025-09-18 12:29:14 - log_args - INFO - out = 'pc/pc_out2.zarr'\n2025-09-18 12:29:14 - log_args - INFO - map_func = &lt;ufunc 'absolute'&gt;\n2025-09-18 12:29:14 - log_args - INFO - reduce_func = &lt;function sum&gt;\n2025-09-18 12:29:14 - log_args - INFO - axis = 0\n2025-09-18 12:29:14 - log_args - INFO - post_map_func = &lt;function &lt;lambda&gt;&gt;\n2025-09-18 12:29:14 - log_args - INFO - processes = False\n2025-09-18 12:29:14 - log_args - INFO - n_workers = 1\n2025-09-18 12:29:14 - log_args - INFO - threads_per_worker = 1\n2025-09-18 12:29:14 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 12:29:14 - log_args - INFO - fetching args done.\n2025-09-18 12:29:14 - zarr_info - INFO - pc/pc_in2.zarr zarray shape, chunks, dtype: (800, 3), (200, 1), complex64\n2025-09-18 12:29:14 - data_reduce - INFO - starting dask local cluster.\n2025-09-18 12:29:14 - data_reduce - INFO - dask local cluster started.\n2025-09-18 12:29:14 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.4:8787/status', workers=1, threads=1, memory=256.00 GiB)\n2025-09-18 12:29:14 - darr_info - INFO - data_in dask array shape, chunksize, dtype: (800, 3), (200, 1), complex64\n2025-09-18 12:29:14 - darr_info - INFO - maped_data_in dask array shape, chunksize, dtype: (800, 3), (200, 1), float32\n2025-09-18 12:29:14 - darr_info - INFO - reduced data in every chunk dask array shape, chunksize, dtype: (4, 3), (1, 1), float32\n2025-09-18 12:29:14 - data_reduce - INFO - computing graph setted. doing all the computing.\n2025-09-18 12:29:14 - data_reduce - INFO - computing finished. 0.1s\n2025-09-18 12:29:14 - data_reduce - INFO - dask cluster closed.\n2025-09-18 12:29:14 - data_reduce - INFO - continue the reduction on reduced data over every chunk\n2025-09-18 12:29:14 - data_reduce - INFO - post mapping\n2025-09-18 12:29:14 - data_reduce - INFO - writing output.\n2025-09-18 12:29:14 - data_reduce - INFO - done.",
    "crumbs": [
      "CLI",
      "pc"
    ]
  },
  {
    "objectID": "CLI/co.html",
    "href": "CLI/co.html",
    "title": "co",
    "section": "",
    "text": "from matplotlib import pyplot as plt\nimport zarr\nimport colorcet\nimport moraine.cli as mc\nfrom moraine.utils_ import is_cuda_available\n\n\nsource\n\nemperical_co_pc\n\n emperical_co_pc (rslc:str, is_shp_dir:str, gix:str, coh_dir:str,\n                  image_pairs:numpy.ndarray=None, chunks:int=None,\n                  cuda:bool=False, processes=None, n_workers=None,\n                  threads_per_worker=None, rmm_pool_size=0.9,\n                  **dask_cluster_arg)\n\nestimate emperical coherence matrix on point cloud data.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nrslc\nstr\n\ninput: rslc stack, shape (nlines, width, nimages)\n\n\nis_shp_dir\nstr\n\ninput: directory for bool array indicating the SHPs of pc\n\n\ngix\nstr\n\ninput: bool array indicating pc, shape (2, n_points)\n\n\ncoh_dir\nstr\n\noutput: directory that hold complex coherence matrix for pc\n\n\nimage_pairs\nndarray\nNone\ninput: image pairs (element in the coherence matrix) to be calculated, all image pairs by default\n\n\nchunks\nint\nNone\nparallel processing azimuth/range chunk size, optional. Default: rslc.chunks[:2]\n\n\ncuda\nbool\nFalse\nif use cuda for processing, false by default\n\n\nprocesses\nNoneType\nNone\nuse process for dask worker over thread, the default is False for cpu, only applied if cuda==False\n\n\nn_workers\nNoneType\nNone\nnumber of dask worker, the default is 1 for cpu, number of GPU for cuda\n\n\nthreads_per_worker\nNoneType\nNone\nnumber of threads per dask worker, the default is 2 for cpu, only applied if cuda==False\n\n\nrmm_pool_size\nfloat\n0.9\nset the rmm pool size, only applied when cuda==True\n\n\ndask_cluster_arg\nVAR_KEYWORD\n\n\n\n\n\n\nlogger = mc.get_logger()\n\n\nds_can_gix = './shp/ds_can_gix.zarr'\nis_shp = './shp/is_shp.zarr/'\nds_can_is_shp_dir = './co/ds_can_is_shp'\nds_can_key = './co/ds_can_key.zarr'\n\n\nmc.ras2pc_ras_chunk(ds_can_gix,is_shp,ds_can_is_shp_dir,ds_can_key,chunks=(1000,1000))\n\n2025-09-18 12:44:25 - log_args - INFO - running function: ras2pc_ras_chunk\n2025-09-18 12:44:25 - log_args - INFO - fetching args:\n2025-09-18 12:44:25 - log_args - INFO - gix = './shp/ds_can_gix.zarr'\n2025-09-18 12:44:25 - log_args - INFO - ras = './shp/is_shp.zarr/'\n2025-09-18 12:44:25 - log_args - INFO - pc = './co/ds_can_is_shp'\n2025-09-18 12:44:25 - log_args - INFO - key = './co/ds_can_key.zarr'\n2025-09-18 12:44:25 - log_args - INFO - chunks = (1000, 1000)\n2025-09-18 12:44:25 - log_args - INFO - processes = False\n2025-09-18 12:44:25 - log_args - INFO - n_workers = 1\n2025-09-18 12:44:25 - log_args - INFO - threads_per_worker = 1\n2025-09-18 12:44:25 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 12:44:25 - log_args - INFO - fetching args done.\n2025-09-18 12:44:25 - zarr_info - INFO - ./shp/ds_can_gix.zarr zarray shape, chunks, dtype: (732727, 2), (100000, 1), int32\n2025-09-18 12:44:25 - ras2pc_ras_chunk - INFO - loading gix into memory.\n2025-09-18 12:44:25 - ras2pc_ras_chunk - INFO - convert gix to the order of ras chunk\n2025-09-18 12:44:32 - ras2pc_ras_chunk - INFO - save key\n2025-09-18 12:44:32 - ras2pc_ras_chunk - INFO - starting dask local cluster.\n2025-09-18 12:44:34 - ras2pc_ras_chunk - INFO - dask local cluster started.\n2025-09-18 12:44:34 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.4:8787/status', workers=1, threads=1, memory=256.00 GiB)\n2025-09-18 12:44:34 - ras2pc_ras_chunk - INFO - start to slice on ./shp/is_shp.zarr/\n2025-09-18 12:44:34 - zarr_info - INFO - ./shp/is_shp.zarr/ zarray shape, chunks, dtype: (2500, 1834, 11, 11), (1000, 1000, 1, 1), bool\n2025-09-18 12:44:34 - darr_info - INFO - ras dask array shape, chunksize, dtype: (2500, 1834, 11, 11), (1000, 1000, 11, 11), bool\n2025-09-18 12:44:34 - darr_info - INFO - pc dask array shape, chunksize, dtype: (732727, 11, 11), (201403, 11, 11), bool\n2025-09-18 12:44:34 - ras2pc_ras_chunk - INFO - saving to co/ds_can_is_shp.\n2025-09-18 12:44:34 - ras2pc_ras_chunk - INFO - computing graph setted. doing all the computing.\n2025-09-18 12:44:37 - ras2pc_ras_chunk - INFO - computing finished.\n2025-09-18 12:44:37 - ras2pc_ras_chunk - INFO - dask cluster closed.\n\n\n\nrslc = './raw/rslc.zarr'\nds_can_coh_dir = './co/ds_can_coh'\n\n\nemperical_co_pc(rslc,ds_can_is_shp_dir,ds_can_gix,ds_can_coh_dir,chunks=(1000,1000),cuda=False)\n\n2025-09-18 12:44:37 - log_args - INFO - running function: emperical_co_pc\n2025-09-18 12:44:37 - log_args - INFO - fetching args:\n2025-09-18 12:44:37 - log_args - INFO - rslc = './raw/rslc.zarr'\n2025-09-18 12:44:37 - log_args - INFO - is_shp_dir = './co/ds_can_is_shp'\n2025-09-18 12:44:37 - log_args - INFO - gix = './shp/ds_can_gix.zarr'\n2025-09-18 12:44:37 - log_args - INFO - coh_dir = './co/ds_can_coh'\n2025-09-18 12:44:37 - log_args - INFO - image_pairs = None\n2025-09-18 12:44:37 - log_args - INFO - chunks = (1000, 1000)\n2025-09-18 12:44:37 - log_args - INFO - cuda = False\n2025-09-18 12:44:37 - log_args - INFO - processes = None\n2025-09-18 12:44:37 - log_args - INFO - n_workers = None\n2025-09-18 12:44:37 - log_args - INFO - threads_per_worker = None\n2025-09-18 12:44:37 - log_args - INFO - rmm_pool_size = 0.9\n2025-09-18 12:44:37 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 12:44:37 - log_args - INFO - fetching args done.\n2025-09-18 12:44:38 - zarr_info - INFO - ./raw/rslc.zarr zarray shape, chunks, dtype: (2500, 1834, 17), (1000, 1000, 1), complex64\n2025-09-18 12:44:38 - emperical_co_pc - INFO - azimuth window size and half azimuth window size: 11, 5\n2025-09-18 12:44:38 - emperical_co_pc - INFO - range window size and half range window size: 11, 5\n2025-09-18 12:44:38 - emperical_co_pc - INFO - parallel processing azimuth chunk size: 1000\n2025-09-18 12:44:38 - emperical_co_pc - INFO - parallel processing range chunk size: 1000\n2025-09-18 12:44:38 - zarr_info - INFO - ./shp/ds_can_gix.zarr zarray shape, chunks, dtype: (732727, 2), (100000, 1), int32\n2025-09-18 12:44:38 - emperical_co_pc - INFO - loading gix into memory.\n2025-09-18 12:44:38 - emperical_co_pc - INFO - convert gix to the order of ras chunk\n2025-09-18 12:44:38 - emperical_co_pc - INFO - starting dask cluster.\n2025-09-18 12:44:38 - emperical_co_pc - INFO - dask cluster started.\n2025-09-18 12:44:38 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.4:8787/status', workers=1, threads=2, memory=256.00 GiB)\n2025-09-18 12:44:38 - darr_info - INFO - rslc_overlap dask array shape, chunksize, dtype: (2520, 1844, 17), (1010, 1005, 17), complex64\n2025-09-18 12:44:38 - darr_info - INFO - gix in ras chunk order dask array shape, chunksize, dtype: (732727, 2), (201403, 2), int32\n2025-09-18 12:44:38 - emperical_co_pc - INFO - estimating coherence matrix chunk by chunk.\n2025-09-18 12:44:38 - darr_info - INFO - is_shp for chunk 0 dask array shape, chunksize, dtype: (201097, 11, 11), (201097, 11, 11), bool\n2025-09-18 12:44:38 - darr_info - INFO - coh for chunk 0 dask array shape, chunksize, dtype: (201097, 136), (201097, 136), complex64\n2025-09-18 12:44:38 - emperical_co_pc - INFO - saving coh for chunk 0\n2025-09-18 12:44:38 - zarr_info - INFO - co/ds_can_coh/0.zarr zarray shape, chunks, dtype: (201097, 136), (201097, 1), complex64\n2025-09-18 12:44:38 - darr_info - INFO - is_shp for chunk 1 dask array shape, chunksize, dtype: (137562, 11, 11), (137562, 11, 11), bool\n2025-09-18 12:44:38 - darr_info - INFO - coh for chunk 1 dask array shape, chunksize, dtype: (137562, 136), (137562, 136), complex64\n2025-09-18 12:44:38 - emperical_co_pc - INFO - saving coh for chunk 1\n2025-09-18 12:44:38 - zarr_info - INFO - co/ds_can_coh/1.zarr zarray shape, chunks, dtype: (137562, 136), (137562, 1), complex64\n2025-09-18 12:44:38 - darr_info - INFO - is_shp for chunk 2 dask array shape, chunksize, dtype: (201403, 11, 11), (201403, 11, 11), bool\n2025-09-18 12:44:38 - darr_info - INFO - coh for chunk 2 dask array shape, chunksize, dtype: (201403, 136), (201403, 136), complex64\n2025-09-18 12:44:38 - emperical_co_pc - INFO - saving coh for chunk 2\n2025-09-18 12:44:38 - zarr_info - INFO - co/ds_can_coh/2.zarr zarray shape, chunks, dtype: (201403, 136), (201403, 1), complex64\n2025-09-18 12:44:38 - darr_info - INFO - is_shp for chunk 3 dask array shape, chunksize, dtype: (73518, 11, 11), (73518, 11, 11), bool\n2025-09-18 12:44:38 - darr_info - INFO - coh for chunk 3 dask array shape, chunksize, dtype: (73518, 136), (73518, 136), complex64\n2025-09-18 12:44:38 - emperical_co_pc - INFO - saving coh for chunk 3\n2025-09-18 12:44:38 - zarr_info - INFO - co/ds_can_coh/3.zarr zarray shape, chunks, dtype: (73518, 136), (73518, 1), complex64\n2025-09-18 12:44:38 - darr_info - INFO - is_shp for chunk 4 dask array shape, chunksize, dtype: (78445, 11, 11), (78445, 11, 11), bool\n2025-09-18 12:44:38 - darr_info - INFO - coh for chunk 4 dask array shape, chunksize, dtype: (78445, 136), (78445, 136), complex64\n2025-09-18 12:44:38 - emperical_co_pc - INFO - saving coh for chunk 4\n2025-09-18 12:44:38 - zarr_info - INFO - co/ds_can_coh/4.zarr zarray shape, chunks, dtype: (78445, 136), (78445, 1), complex64\n2025-09-18 12:44:39 - darr_info - INFO - is_shp for chunk 5 dask array shape, chunksize, dtype: (40702, 11, 11), (40702, 11, 11), bool\n2025-09-18 12:44:39 - darr_info - INFO - coh for chunk 5 dask array shape, chunksize, dtype: (40702, 136), (40702, 136), complex64\n2025-09-18 12:44:39 - emperical_co_pc - INFO - saving coh for chunk 5\n2025-09-18 12:44:39 - zarr_info - INFO - co/ds_can_coh/5.zarr zarray shape, chunks, dtype: (40702, 136), (40702, 1), complex64\n2025-09-18 12:44:39 - emperical_co_pc - INFO - computing graph setted. doing all the computing.\n2025-09-18 12:44:44 - emperical_co_pc - INFO - computing finished.s\n2025-09-18 12:44:44 - emperical_co_pc - INFO - dask cluster closed.\nCPU times: user 37.5 s, sys: 4.48 s, total: 41.9 s\nWall time: 6.2 s\n\n\n\nif is_cuda_available():\n    emperical_co_pc(rslc,ds_can_is_shp_dir,ds_can_gix,ds_can_coh_dir,chunks=(1000,1000),cuda=True)\n\n2025-09-18 12:44:44 - log_args - INFO - running function: emperical_co_pc\n2025-09-18 12:44:44 - log_args - INFO - fetching args:\n2025-09-18 12:44:44 - log_args - INFO - rslc = './raw/rslc.zarr'\n2025-09-18 12:44:44 - log_args - INFO - is_shp_dir = './co/ds_can_is_shp'\n2025-09-18 12:44:44 - log_args - INFO - gix = './shp/ds_can_gix.zarr'\n2025-09-18 12:44:44 - log_args - INFO - coh_dir = './co/ds_can_coh'\n2025-09-18 12:44:44 - log_args - INFO - image_pairs = None\n2025-09-18 12:44:44 - log_args - INFO - chunks = (1000, 1000)\n2025-09-18 12:44:44 - log_args - INFO - cuda = True\n2025-09-18 12:44:44 - log_args - INFO - processes = None\n2025-09-18 12:44:44 - log_args - INFO - n_workers = None\n2025-09-18 12:44:44 - log_args - INFO - threads_per_worker = None\n2025-09-18 12:44:44 - log_args - INFO - rmm_pool_size = 0.9\n2025-09-18 12:44:44 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 12:44:44 - log_args - INFO - fetching args done.\n2025-09-18 12:44:44 - zarr_info - INFO - ./raw/rslc.zarr zarray shape, chunks, dtype: (2500, 1834, 17), (1000, 1000, 1), complex64\n2025-09-18 12:44:44 - emperical_co_pc - INFO - azimuth window size and half azimuth window size: 11, 5\n2025-09-18 12:44:44 - emperical_co_pc - INFO - range window size and half range window size: 11, 5\n2025-09-18 12:44:44 - emperical_co_pc - INFO - parallel processing azimuth chunk size: 1000\n2025-09-18 12:44:44 - emperical_co_pc - INFO - parallel processing range chunk size: 1000\n2025-09-18 12:44:44 - zarr_info - INFO - ./shp/ds_can_gix.zarr zarray shape, chunks, dtype: (732727, 2), (100000, 1), int32\n2025-09-18 12:44:44 - emperical_co_pc - INFO - loading gix into memory.\n2025-09-18 12:44:44 - emperical_co_pc - INFO - convert gix to the order of ras chunk\n2025-09-18 12:44:44 - emperical_co_pc - INFO - starting dask cluster.\n\n\n2025-09-18 12:44:46,495 - distributed.worker - WARNING - Setting CPU affinity for GPU failed. Please refer to the following link for troubleshooting information: https://docs.rapids.ai/api/dask-cuda/nightly/troubleshooting/#setting-cpu-affinity-failure\n2025-09-18 12:44:46,496 - distributed.worker - WARNING - Setting CPU affinity for GPU failed. Please refer to the following link for troubleshooting information: https://docs.rapids.ai/api/dask-cuda/nightly/troubleshooting/#setting-cpu-affinity-failure\n\n\n2025-09-18 12:44:47 - emperical_co_pc - INFO - dask cluster started.\n2025-09-18 12:44:47 - dask_cluster_info - INFO - dask cluster: LocalCUDACluster(dashboard_link='http://127.0.0.1:8787/status', workers=2, threads=2, memory=256.00 GiB)\n2025-09-18 12:44:47 - darr_info - INFO - rslc_overlap dask array shape, chunksize, dtype: (2520, 1844, 17), (1010, 1005, 17), complex64\n2025-09-18 12:44:47 - darr_info - INFO - gix in ras chunk order dask array shape, chunksize, dtype: (732727, 2), (201403, 2), int32\n2025-09-18 12:44:47 - emperical_co_pc - INFO - estimating coherence matrix chunk by chunk.\n2025-09-18 12:44:47 - darr_info - INFO - is_shp for chunk 0 dask array shape, chunksize, dtype: (201097, 11, 11), (201097, 11, 11), bool\n2025-09-18 12:44:47 - darr_info - INFO - coh for chunk 0 dask array shape, chunksize, dtype: (201097, 136), (201097, 136), complex64\n2025-09-18 12:44:47 - emperical_co_pc - INFO - saving coh for chunk 0\n2025-09-18 12:44:47 - zarr_info - INFO - co/ds_can_coh/0.zarr zarray shape, chunks, dtype: (201097, 136), (201097, 1), complex64\n2025-09-18 12:44:47 - darr_info - INFO - is_shp for chunk 1 dask array shape, chunksize, dtype: (137562, 11, 11), (137562, 11, 11), bool\n2025-09-18 12:44:47 - darr_info - INFO - coh for chunk 1 dask array shape, chunksize, dtype: (137562, 136), (137562, 136), complex64\n2025-09-18 12:44:47 - emperical_co_pc - INFO - saving coh for chunk 1\n2025-09-18 12:44:47 - zarr_info - INFO - co/ds_can_coh/1.zarr zarray shape, chunks, dtype: (137562, 136), (137562, 1), complex64\n2025-09-18 12:44:47 - darr_info - INFO - is_shp for chunk 2 dask array shape, chunksize, dtype: (201403, 11, 11), (201403, 11, 11), bool\n2025-09-18 12:44:47 - darr_info - INFO - coh for chunk 2 dask array shape, chunksize, dtype: (201403, 136), (201403, 136), complex64\n2025-09-18 12:44:47 - emperical_co_pc - INFO - saving coh for chunk 2\n2025-09-18 12:44:47 - zarr_info - INFO - co/ds_can_coh/2.zarr zarray shape, chunks, dtype: (201403, 136), (201403, 1), complex64\n2025-09-18 12:44:47 - darr_info - INFO - is_shp for chunk 3 dask array shape, chunksize, dtype: (73518, 11, 11), (73518, 11, 11), bool\n2025-09-18 12:44:47 - darr_info - INFO - coh for chunk 3 dask array shape, chunksize, dtype: (73518, 136), (73518, 136), complex64\n2025-09-18 12:44:47 - emperical_co_pc - INFO - saving coh for chunk 3\n2025-09-18 12:44:47 - zarr_info - INFO - co/ds_can_coh/3.zarr zarray shape, chunks, dtype: (73518, 136), (73518, 1), complex64\n2025-09-18 12:44:47 - darr_info - INFO - is_shp for chunk 4 dask array shape, chunksize, dtype: (78445, 11, 11), (78445, 11, 11), bool\n2025-09-18 12:44:47 - darr_info - INFO - coh for chunk 4 dask array shape, chunksize, dtype: (78445, 136), (78445, 136), complex64\n2025-09-18 12:44:47 - emperical_co_pc - INFO - saving coh for chunk 4\n2025-09-18 12:44:47 - zarr_info - INFO - co/ds_can_coh/4.zarr zarray shape, chunks, dtype: (78445, 136), (78445, 1), complex64\n2025-09-18 12:44:47 - darr_info - INFO - is_shp for chunk 5 dask array shape, chunksize, dtype: (40702, 11, 11), (40702, 11, 11), bool\n2025-09-18 12:44:47 - darr_info - INFO - coh for chunk 5 dask array shape, chunksize, dtype: (40702, 136), (40702, 136), complex64\n2025-09-18 12:44:47 - emperical_co_pc - INFO - saving coh for chunk 5\n2025-09-18 12:44:47 - zarr_info - INFO - co/ds_can_coh/5.zarr zarray shape, chunks, dtype: (40702, 136), (40702, 1), complex64\n2025-09-18 12:44:47 - emperical_co_pc - INFO - computing graph setted. doing all the computing.\n2025-09-18 12:44:52 - emperical_co_pc - INFO - computing finished.s\n2025-09-18 12:44:53 - emperical_co_pc - INFO - dask cluster closed.\nCPU times: user 500 ms, sys: 613 ms, total: 1.11 s\nWall time: 9.38 s\n\n\n\nds_can_coh = './co/ds_can_coh.zarr'\n\n\nchunks = zarr.open(ds_can_gix,mode='r').chunks[0]\nmc.pc_concat(ds_can_coh_dir,ds_can_coh,key=ds_can_key,chunks=chunks)\n\n2025-09-18 12:44:53 - log_args - INFO - running function: pc_concat\n2025-09-18 12:44:53 - log_args - INFO - fetching args:\n2025-09-18 12:44:53 - log_args - INFO - pcs = './co/ds_can_coh'\n2025-09-18 12:44:53 - log_args - INFO - pc = './co/ds_can_coh.zarr'\n2025-09-18 12:44:53 - log_args - INFO - key = './co/ds_can_key.zarr'\n2025-09-18 12:44:53 - log_args - INFO - chunks = 100000\n2025-09-18 12:44:53 - log_args - INFO - processes = False\n2025-09-18 12:44:53 - log_args - INFO - n_workers = 1\n2025-09-18 12:44:53 - log_args - INFO - threads_per_worker = 1\n2025-09-18 12:44:53 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 12:44:53 - log_args - INFO - fetching args done.\n2025-09-18 12:44:53 - pc_concat - INFO - input pcs: [[Path('co/ds_can_coh/0.zarr'), Path('co/ds_can_coh/1.zarr'), Path('co/ds_can_coh/2.zarr'), Path('co/ds_can_coh/3.zarr'), Path('co/ds_can_coh/4.zarr'), Path('co/ds_can_coh/5.zarr')]]\n2025-09-18 12:44:53 - pc_concat - INFO - output pc: ['./co/ds_can_coh.zarr']\n2025-09-18 12:44:53 - pc_concat - INFO - load key\n2025-09-18 12:44:53 - zarr_info - INFO - ./co/ds_can_key.zarr zarray shape, chunks, dtype: (732727,), (100000,), int64\n2025-09-18 12:44:53 - pc_concat - INFO - starting dask local cluster.\n2025-09-18 12:44:53 - pc_concat - INFO - dask local cluster started.\n2025-09-18 12:44:53 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.4:8787/status', workers=1, threads=1, memory=256.00 GiB)\n2025-09-18 12:44:53 - pc_concat - INFO - read pc from [Path('co/ds_can_coh/0.zarr'), Path('co/ds_can_coh/1.zarr'), Path('co/ds_can_coh/2.zarr'), Path('co/ds_can_coh/3.zarr'), Path('co/ds_can_coh/4.zarr'), Path('co/ds_can_coh/5.zarr')]\n2025-09-18 12:44:53 - darr_info - INFO - concatenated pc dask array shape, chunksize, dtype: (732727, 136), (732727, 1), complex64\n2025-09-18 12:44:53 - pc_concat - INFO - sort pc according to key\n2025-09-18 12:44:53 - darr_info - INFO - sorted pc dask array shape, chunksize, dtype: (732727, 136), (732727, 1), complex64\n2025-09-18 12:44:53 - pc_concat - INFO - save pc to ./co/ds_can_coh.zarr\n2025-09-18 12:44:54 - zarr_info - INFO - ./co/ds_can_coh.zarr zarray shape, chunks, dtype: (732727, 136), (100000, 1), complex64\n2025-09-18 12:44:54 - pc_concat - INFO - computing graph setted. doing all the computing.\n2025-09-18 12:44:59 - pc_concat - INFO - computing finished.|  5.2s\n2025-09-18 12:44:59 - pc_concat - INFO - dask cluster closed.\n\n\n\nds_can_coh_ave = './co/ds_can_coh_ave.zarr'\n\n\nn_point = zarr.open(ds_can_coh,mode='r').shape[0]\nmc.data_reduce(ds_can_coh,ds_can_coh_ave,map_func=np.abs,reduce_func=np.sum,post_map_func=lambda x: x/n_point)\n\n2025-09-18 12:44:59 - log_args - INFO - running function: data_reduce\n2025-09-18 12:44:59 - log_args - INFO - fetching args:\n2025-09-18 12:44:59 - log_args - INFO - data_in = './co/ds_can_coh.zarr'\n2025-09-18 12:44:59 - log_args - INFO - out = './co/ds_can_coh_ave.zarr'\n2025-09-18 12:44:59 - log_args - INFO - map_func = &lt;ufunc 'absolute'&gt;\n2025-09-18 12:44:59 - log_args - INFO - reduce_func = &lt;function sum&gt;\n2025-09-18 12:44:59 - log_args - INFO - axis = 0\n2025-09-18 12:44:59 - log_args - INFO - post_map_func = &lt;function &lt;lambda&gt;&gt;\n2025-09-18 12:44:59 - log_args - INFO - processes = False\n2025-09-18 12:44:59 - log_args - INFO - n_workers = 1\n2025-09-18 12:44:59 - log_args - INFO - threads_per_worker = 1\n2025-09-18 12:44:59 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 12:44:59 - log_args - INFO - fetching args done.\n2025-09-18 12:44:59 - zarr_info - INFO - ./co/ds_can_coh.zarr zarray shape, chunks, dtype: (732727, 136), (100000, 1), complex64\n2025-09-18 12:44:59 - data_reduce - INFO - starting dask local cluster.\n2025-09-18 12:44:59 - data_reduce - INFO - dask local cluster started.\n2025-09-18 12:44:59 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.4:8787/status', workers=1, threads=1, memory=256.00 GiB)\n2025-09-18 12:44:59 - darr_info - INFO - data_in dask array shape, chunksize, dtype: (732727, 136), (100000, 1), complex64\n2025-09-18 12:44:59 - darr_info - INFO - maped_data_in dask array shape, chunksize, dtype: (732727, 136), (100000, 1), float32\n2025-09-18 12:44:59 - darr_info - INFO - reduced data in every chunk dask array shape, chunksize, dtype: (8, 136), (1, 1), float32\n2025-09-18 12:44:59 - data_reduce - INFO - computing graph setted. doing all the computing.\n2025-09-18 12:45:04 - data_reduce - INFO - computing finished. 4.4s\n2025-09-18 12:45:04 - data_reduce - INFO - dask cluster closed.\n2025-09-18 12:45:04 - data_reduce - INFO - continue the reduction on reduced data over every chunk\n2025-09-18 12:45:04 - data_reduce - INFO - post mapping\n2025-09-18 12:45:04 - data_reduce - INFO - writing output.\n2025-09-18 12:45:04 - data_reduce - INFO - done.\n\n\n\nds_can_coh_ave_ = mr.uncompress_coh(zarr.open(ds_can_coh_ave,mode='r')[:])\nfig, ax = plt.subplots(1,1,figsize=(15,10))\npcm = ax.imshow(ds_can_coh_ave_,cmap=colorcet.cm.fire)\nax.set(title='Average coherence matrix',xlabel='Image Index',ylabel='Image Index')\nfig.colorbar(pcm)\nfig.show()",
    "crumbs": [
      "CLI",
      "co"
    ]
  },
  {
    "objectID": "CLI/utils_.html",
    "href": "CLI/utils_.html",
    "title": "utils",
    "section": "",
    "text": "source\n\nmk_clean_dir\n\n mk_clean_dir (path)"
  },
  {
    "objectID": "CLI/load.html",
    "href": "CLI/load.html",
    "title": "load",
    "section": "",
    "text": "import zarr\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport moraine.cli as mc\n\n\nsource\n\nload_gamma_flatten_rslc\n\n load_gamma_flatten_rslc (rslc_dir:str, reference:str, hgt:str,\n                          scratch_dir:str, rslc:str,\n                          chunks:tuple[int,int]=(1000, 1000),\n                          processes=False, n_workers=1,\n                          threads_per_worker=1, **dask_cluster_arg)\n\nGenerate flatten rslc data from gamma command and convert them into zarr format. The shape of hgt should be same as one rslc image, i.e. the hgt file is generated with 1 by 1 look geocoding. All data equal to 0 are replaced with nan.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nrslc_dir\nstr\n\ngamma rslc directory, the name of the rslc and their par files should be ‘????????.rslc’ and ‘????????.rslc.par’\n\n\nreference\nstr\n\nreference date, eg: ‘20200202’\n\n\nhgt\nstr\n\nthe DEM in radar coordinate\n\n\nscratch_dir\nstr\n\ndirectory for preserve gamma intermediate files\n\n\nrslc\nstr\n\noutput, the flattened rslcs stack in zarr format\n\n\nchunks\ntuple\n(1000, 1000)\nrslc chunk size\n\n\nprocesses\nbool\nFalse\nuse process for dask worker or thread\n\n\nn_workers\nint\n1\nnumber of dask worker\n\n\nthreads_per_worker\nint\n1\nnumber of threads per dask worker\n\n\ndask_cluster_arg\nVAR_KEYWORD\n\n\n\n\n\nThe method behind the flattened RSLC:\nLet the value of i-th rslc be \\(s_i\\), the simulated phase due to DEM and position difference be \\(u_{ij}\\). D-InSAR basically is: \\[d_{ij}=s_i \\times s_j^* \\times e^{-ju_{ij}}.\\] Let the distance between satellite and ground target for th i-th observation be \\(l_i\\). Then, the simulated phase for DInSAR \\[u_{ij} = l_i-l_j.\\] So, a simple conclusion is \\[u_{ij}-u_{ik}=-u_{jk}.\\] If we define \\[s_i^{\\prime} = s_i \\times e^{ju_{xi}},\\] where \\(X\\) can be any arbitrary interger less than \\(N\\)- the total number of the RSLCs. Then we can find that \\[int_{ij}^{\\prime} =  s_i^{\\prime} \\times s_j^{\\prime*} = s_i \\times s_j^* \\times e^{j(u_{xi}-u_{xj})} = s_i \\times s_j^* \\times e^{j(u_{xi}-u_{xj})} = s_i \\times s_j^* \\times e^{-ju_{ij}} = d_{ij}.\\]\nWe call \\(s_i^{\\prime}\\) as flattened RSLC. The advantage of flattened RSLC is DInSAR can be easily calculated by simple conjugate multiplication.\nAn example:\n\nrslc_dir = '../../data/gamma/rslc'\nreference = '20220620'\nhgt = '../../data/gamma/geocoding/20210802.hgt'\nrslc = './raw/rslc.zarr'\nscratch_dir = './raw/scratch'\n\n\nlogger = mc.get_logger()\n\n\nload_gamma_flatten_rslc(rslc_dir,reference,hgt,scratch_dir,rslc,chunks=(1000,1000))\n\n2025-09-18 12:15:20 - log_args - INFO - running function: load_gamma_flatten_rslc\n2025-09-18 12:15:20 - log_args - INFO - fetching args:\n2025-09-18 12:15:20 - log_args - INFO - rslc_dir = '../../data/gamma/rslc'\n2025-09-18 12:15:20 - log_args - INFO - reference = '20220620'\n2025-09-18 12:15:20 - log_args - INFO - hgt = '../../data/gamma/geocoding/20210802.hgt'\n2025-09-18 12:15:20 - log_args - INFO - scratch_dir = './raw/scratch'\n2025-09-18 12:15:20 - log_args - INFO - rslc = './raw/rslc.zarr'\n2025-09-18 12:15:20 - log_args - INFO - chunks = (1000, 1000)\n2025-09-18 12:15:20 - log_args - INFO - processes = False\n2025-09-18 12:15:20 - log_args - INFO - n_workers = 1\n2025-09-18 12:15:20 - log_args - INFO - threads_per_worker = 1\n2025-09-18 12:15:20 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 12:15:20 - log_args - INFO - fetching args done.\n2025-09-18 12:15:20 - load_gamma_flatten_rslc - INFO - rslc found: \n        date                                 rslc  \\\n0   20210802  ../../data/gamma/rslc/20210802.rslc   \n1   20210816  ../../data/gamma/rslc/20210816.rslc   \n2   20210830  ../../data/gamma/rslc/20210830.rslc   \n3   20210913  ../../data/gamma/rslc/20210913.rslc   \n4   20211011  ../../data/gamma/rslc/20211011.rslc   \n5   20211025  ../../data/gamma/rslc/20211025.rslc   \n6   20220606  ../../data/gamma/rslc/20220606.rslc   \n7   20220620  ../../data/gamma/rslc/20220620.rslc   \n8   20220704  ../../data/gamma/rslc/20220704.rslc   \n9   20220718  ../../data/gamma/rslc/20220718.rslc   \n10  20220801  ../../data/gamma/rslc/20220801.rslc   \n11  20220815  ../../data/gamma/rslc/20220815.rslc   \n12  20220829  ../../data/gamma/rslc/20220829.rslc   \n13  20220912  ../../data/gamma/rslc/20220912.rslc   \n14  20220926  ../../data/gamma/rslc/20220926.rslc   \n15  20221010  ../../data/gamma/rslc/20221010.rslc   \n16  20221024  ../../data/gamma/rslc/20221024.rslc   \n\n                                        par  \n0   ../../data/gamma/rslc/20210802.rslc.par  \n1   ../../data/gamma/rslc/20210816.rslc.par  \n2   ../../data/gamma/rslc/20210830.rslc.par  \n3   ../../data/gamma/rslc/20210913.rslc.par  \n4   ../../data/gamma/rslc/20211011.rslc.par  \n5   ../../data/gamma/rslc/20211025.rslc.par  \n6   ../../data/gamma/rslc/20220606.rslc.par  \n7   ../../data/gamma/rslc/20220620.rslc.par  \n8   ../../data/gamma/rslc/20220704.rslc.par  \n9   ../../data/gamma/rslc/20220718.rslc.par  \n10  ../../data/gamma/rslc/20220801.rslc.par  \n11  ../../data/gamma/rslc/20220815.rslc.par  \n12  ../../data/gamma/rslc/20220829.rslc.par  \n13  ../../data/gamma/rslc/20220912.rslc.par  \n14  ../../data/gamma/rslc/20220926.rslc.par  \n15  ../../data/gamma/rslc/20221010.rslc.par  \n16  ../../data/gamma/rslc/20221024.rslc.par  \n2025-09-18 12:15:20 - load_gamma_flatten_rslc - INFO - number of images: 17.\n2025-09-18 12:15:20 - load_gamma_flatten_rslc - INFO - image number of lines: 2500.\n2025-09-18 12:15:20 - load_gamma_flatten_rslc - INFO - image width: 1834.\n2025-09-18 12:15:20 - load_gamma_flatten_rslc - INFO - run gamma command to generate required data for flattened rslcs:\n2025-09-18 12:15:20 - load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20210802.rslc.par raw/scratch/20220620_20210802.off 1 1 1 0 &gt;&gt; raw/scratch/gamma.log\n2025-09-18 12:15:21 - load_gamma_flatten_rslc - INFO - raw/scratch/20220620_20210802.sim_orb exists. skip runing phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20210802.rslc.par raw/scratch/20220620_20210802.off ../../data/gamma/geocoding/20210802.hgt raw/scratch/20220620_20210802.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; raw/scratch/gamma.log\n2025-09-18 12:15:21 - load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20210816.rslc.par raw/scratch/20220620_20210816.off 1 1 1 0 &gt;&gt; raw/scratch/gamma.log\n2025-09-18 12:15:21 - load_gamma_flatten_rslc - INFO - raw/scratch/20220620_20210816.sim_orb exists. skip runing phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20210816.rslc.par raw/scratch/20220620_20210816.off ../../data/gamma/geocoding/20210802.hgt raw/scratch/20220620_20210816.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; raw/scratch/gamma.log\n2025-09-18 12:15:21 - load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20210830.rslc.par raw/scratch/20220620_20210830.off 1 1 1 0 &gt;&gt; raw/scratch/gamma.log\n2025-09-18 12:15:21 - load_gamma_flatten_rslc - INFO - raw/scratch/20220620_20210830.sim_orb exists. skip runing phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20210830.rslc.par raw/scratch/20220620_20210830.off ../../data/gamma/geocoding/20210802.hgt raw/scratch/20220620_20210830.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; raw/scratch/gamma.log\n2025-09-18 12:15:21 - load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20210913.rslc.par raw/scratch/20220620_20210913.off 1 1 1 0 &gt;&gt; raw/scratch/gamma.log\n2025-09-18 12:15:21 - load_gamma_flatten_rslc - INFO - raw/scratch/20220620_20210913.sim_orb exists. skip runing phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20210913.rslc.par raw/scratch/20220620_20210913.off ../../data/gamma/geocoding/20210802.hgt raw/scratch/20220620_20210913.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; raw/scratch/gamma.log\n2025-09-18 12:15:21 - load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20211011.rslc.par raw/scratch/20220620_20211011.off 1 1 1 0 &gt;&gt; raw/scratch/gamma.log\n2025-09-18 12:15:21 - load_gamma_flatten_rslc - INFO - raw/scratch/20220620_20211011.sim_orb exists. skip runing phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20211011.rslc.par raw/scratch/20220620_20211011.off ../../data/gamma/geocoding/20210802.hgt raw/scratch/20220620_20211011.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; raw/scratch/gamma.log\n2025-09-18 12:15:21 - load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20211025.rslc.par raw/scratch/20220620_20211025.off 1 1 1 0 &gt;&gt; raw/scratch/gamma.log\n2025-09-18 12:15:21 - load_gamma_flatten_rslc - INFO - raw/scratch/20220620_20211025.sim_orb exists. skip runing phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20211025.rslc.par raw/scratch/20220620_20211025.off ../../data/gamma/geocoding/20210802.hgt raw/scratch/20220620_20211025.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; raw/scratch/gamma.log\n2025-09-18 12:15:21 - load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220606.rslc.par raw/scratch/20220620_20220606.off 1 1 1 0 &gt;&gt; raw/scratch/gamma.log\n2025-09-18 12:15:21 - load_gamma_flatten_rslc - INFO - raw/scratch/20220620_20220606.sim_orb exists. skip runing phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220606.rslc.par raw/scratch/20220620_20220606.off ../../data/gamma/geocoding/20210802.hgt raw/scratch/20220620_20220606.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; raw/scratch/gamma.log\n2025-09-18 12:15:21 - load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220620.rslc.par raw/scratch/20220620_20220620.off 1 1 1 0 &gt;&gt; raw/scratch/gamma.log\n2025-09-18 12:15:21 - load_gamma_flatten_rslc - INFO - raw/scratch/20220620_20220620.sim_orb exists. skip runing phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220620.rslc.par raw/scratch/20220620_20220620.off ../../data/gamma/geocoding/20210802.hgt raw/scratch/20220620_20220620.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; raw/scratch/gamma.log\n2025-09-18 12:15:21 - load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220704.rslc.par raw/scratch/20220620_20220704.off 1 1 1 0 &gt;&gt; raw/scratch/gamma.log\n2025-09-18 12:15:21 - load_gamma_flatten_rslc - INFO - raw/scratch/20220620_20220704.sim_orb exists. skip runing phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220704.rslc.par raw/scratch/20220620_20220704.off ../../data/gamma/geocoding/20210802.hgt raw/scratch/20220620_20220704.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; raw/scratch/gamma.log\n2025-09-18 12:15:21 - load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220718.rslc.par raw/scratch/20220620_20220718.off 1 1 1 0 &gt;&gt; raw/scratch/gamma.log\n2025-09-18 12:15:21 - load_gamma_flatten_rslc - INFO - raw/scratch/20220620_20220718.sim_orb exists. skip runing phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220718.rslc.par raw/scratch/20220620_20220718.off ../../data/gamma/geocoding/20210802.hgt raw/scratch/20220620_20220718.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; raw/scratch/gamma.log\n2025-09-18 12:15:21 - load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220801.rslc.par raw/scratch/20220620_20220801.off 1 1 1 0 &gt;&gt; raw/scratch/gamma.log\n2025-09-18 12:15:21 - load_gamma_flatten_rslc - INFO - raw/scratch/20220620_20220801.sim_orb exists. skip runing phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220801.rslc.par raw/scratch/20220620_20220801.off ../../data/gamma/geocoding/20210802.hgt raw/scratch/20220620_20220801.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; raw/scratch/gamma.log\n2025-09-18 12:15:21 - load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220815.rslc.par raw/scratch/20220620_20220815.off 1 1 1 0 &gt;&gt; raw/scratch/gamma.log\n2025-09-18 12:15:21 - load_gamma_flatten_rslc - INFO - raw/scratch/20220620_20220815.sim_orb exists. skip runing phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220815.rslc.par raw/scratch/20220620_20220815.off ../../data/gamma/geocoding/20210802.hgt raw/scratch/20220620_20220815.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; raw/scratch/gamma.log\n2025-09-18 12:15:21 - load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220829.rslc.par raw/scratch/20220620_20220829.off 1 1 1 0 &gt;&gt; raw/scratch/gamma.log\n2025-09-18 12:15:21 - load_gamma_flatten_rslc - INFO - raw/scratch/20220620_20220829.sim_orb exists. skip runing phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220829.rslc.par raw/scratch/20220620_20220829.off ../../data/gamma/geocoding/20210802.hgt raw/scratch/20220620_20220829.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; raw/scratch/gamma.log\n2025-09-18 12:15:21 - load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220912.rslc.par raw/scratch/20220620_20220912.off 1 1 1 0 &gt;&gt; raw/scratch/gamma.log\n2025-09-18 12:15:22 - load_gamma_flatten_rslc - INFO - raw/scratch/20220620_20220912.sim_orb exists. skip runing phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220912.rslc.par raw/scratch/20220620_20220912.off ../../data/gamma/geocoding/20210802.hgt raw/scratch/20220620_20220912.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; raw/scratch/gamma.log\n2025-09-18 12:15:22 - load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220926.rslc.par raw/scratch/20220620_20220926.off 1 1 1 0 &gt;&gt; raw/scratch/gamma.log\n2025-09-18 12:15:22 - load_gamma_flatten_rslc - INFO - raw/scratch/20220620_20220926.sim_orb exists. skip runing phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220926.rslc.par raw/scratch/20220620_20220926.off ../../data/gamma/geocoding/20210802.hgt raw/scratch/20220620_20220926.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; raw/scratch/gamma.log\n2025-09-18 12:15:22 - load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20221010.rslc.par raw/scratch/20220620_20221010.off 1 1 1 0 &gt;&gt; raw/scratch/gamma.log\n2025-09-18 12:15:22 - load_gamma_flatten_rslc - INFO - raw/scratch/20220620_20221010.sim_orb exists. skip runing phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20221010.rslc.par raw/scratch/20220620_20221010.off ../../data/gamma/geocoding/20210802.hgt raw/scratch/20220620_20221010.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; raw/scratch/gamma.log\n2025-09-18 12:15:22 - load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20221024.rslc.par raw/scratch/20220620_20221024.off 1 1 1 0 &gt;&gt; raw/scratch/gamma.log\n2025-09-18 12:15:22 - load_gamma_flatten_rslc - INFO - raw/scratch/20220620_20221024.sim_orb exists. skip runing phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20221024.rslc.par raw/scratch/20220620_20221024.off ../../data/gamma/geocoding/20210802.hgt raw/scratch/20220620_20221024.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; raw/scratch/gamma.log\n2025-09-18 12:15:22 - load_gamma_flatten_rslc - INFO - gamma command finished.\n2025-09-18 12:15:22 - load_gamma_flatten_rslc - INFO - using dask to load data in gamma binary format to calculate flatten rslcs and save it to zarr.\n2025-09-18 12:15:22 - load_gamma_flatten_rslc - INFO - starting dask local cluster.\n2025-09-18 12:15:25 - load_gamma_flatten_rslc - INFO - dask local cluster started.\n2025-09-18 12:15:25 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.4:8787/status', workers=1, threads=1, memory=256.00 GiB)\n2025-09-18 12:15:25 - darr_info - INFO - flattened rslc dask array shape, chunksize, dtype: (2500, 1834, 17), (2500, 1834, 1), complex64\n2025-09-18 12:15:25 - zarr_info - INFO - ./raw/rslc.zarr zarray shape, chunks, dtype: (2500, 1834, 17), (1000, 1000, 1), complex64\n2025-09-18 12:15:25 - load_gamma_flatten_rslc - INFO - computing graph setted. doing all the computing.\n2025-09-18 12:15:33 - load_gamma_flatten_rslc - INFO - computing finished.\n2025-09-18 12:15:33 - load_gamma_flatten_rslc - INFO - dask cluster closed.\n\n\n\nsource\n\n\nload_gamma_lat_lon_hgt\n\n load_gamma_lat_lon_hgt (diff_par:str, rslc_par:str, dem_par:str, hgt:str,\n                         scratch_dir:str, lat_zarr:str, lon_zarr:str,\n                         hgt_zarr:str, chunks:tuple[int,int]=(1000, 1000))\n\nFunction to load longitude and latitude from gamma binary format to zarr. All data equal to 0 are replaced with nan.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ndiff_par\nstr\n\ngeocoding diff_par,using the simulated image as reference\n\n\nrslc_par\nstr\n\npar file of the reference rslc\n\n\ndem_par\nstr\n\ndem par\n\n\nhgt\nstr\n\nDEM in radar coordinate\n\n\nscratch_dir\nstr\n\ndirectory for preserve gamma intermediate files\n\n\nlat_zarr\nstr\n\noutput, latitude zarr\n\n\nlon_zarr\nstr\n\noutput, longitude zarr\n\n\nhgt_zarr\nstr\n\noutput, height zarr\n\n\nchunks\ntuple\n(1000, 1000)\nrslc chunk size\n\n\n\n\ndiff_par = '../../data/gamma/geocoding/20210802.diff_par'\nrslc_par = '../../data/gamma/rslc/20220620.rslc.par'\ndem_par = '../../data/gamma/DEM/dem_seg_par'\nhgt = '../../data/gamma/geocoding/20210802.hgt'\nscratch_dir = './raw/scratch'\nlat_zarr = './raw/lat.zarr'\nlon_zarr = './raw/lon.zarr'\nhgt_zarr = './raw/hgt.zarr'\n\nAn example:\n\nload_gamma_lat_lon_hgt(diff_par,rslc_par,dem_par,hgt,scratch_dir,lat_zarr,lon_zarr,hgt_zarr,chunks=(1000,1000))\n\n2025-09-18 12:15:59 - log_args - INFO - running function: load_gamma_lat_lon_hgt\n2025-09-18 12:15:59 - log_args - INFO - fetching args:\n2025-09-18 12:15:59 - log_args - INFO - diff_par = '../../data/gamma/geocoding/20210802.diff_par'\n2025-09-18 12:15:59 - log_args - INFO - rslc_par = '../../data/gamma/rslc/20220620.rslc.par'\n2025-09-18 12:15:59 - log_args - INFO - dem_par = '../../data/gamma/DEM/dem_seg_par'\n2025-09-18 12:15:59 - log_args - INFO - hgt = '../../data/gamma/geocoding/20210802.hgt'\n2025-09-18 12:15:59 - log_args - INFO - scratch_dir = './raw/scratch'\n2025-09-18 12:15:59 - log_args - INFO - lat_zarr = './raw/lat.zarr'\n2025-09-18 12:15:59 - log_args - INFO - lon_zarr = './raw/lon.zarr'\n2025-09-18 12:15:59 - log_args - INFO - hgt_zarr = './raw/hgt.zarr'\n2025-09-18 12:15:59 - log_args - INFO - chunks = (1000, 1000)\n2025-09-18 12:15:59 - log_args - INFO - fetching args done.\n2025-09-18 12:15:59 - load_gamma_lat_lon_hgt - INFO - image shape: (2500,1834)\n2025-09-18 12:15:59 - load_gamma_lat_lon_hgt - INFO - run gamma command to generate longitude, latitude and height:\n2025-09-18 12:15:59 - load_gamma_lat_lon_hgt - INFO - raw/scratch/plist exists. skip runing mkgrid raw/scratch/plist 1834 2500 1 1 &gt;&gt; raw/scratch/gamma.log\n2025-09-18 12:15:59 - load_gamma_lat_lon_hgt - INFO - raw/scratch/phgt_wgs84 exists. skip runing pt2geo raw/scratch/plist - ../../data/gamma/rslc/20220620.rslc.par - ../../data/gamma/geocoding/20210802.hgt ../../data/gamma/DEM/dem_seg_par ../../data/gamma/geocoding/20210802.diff_par 1 1 - - raw/scratch/plat_lon raw/scratch/phgt_wgs84 &gt;&gt; raw/scratch/gamma.log\n2025-09-18 12:15:59 - load_gamma_lat_lon_hgt - INFO - writing zarr file.\n2025-09-18 12:16:00 - load_gamma_lat_lon_hgt - INFO - write done.\n\n\n\nlon_data = zarr.open(lon_zarr,mode='r')[:]\nlat_data = zarr.open(lat_zarr,mode='r')[:]\nhgt_data = zarr.open(hgt_zarr,mode='r')[:]\n\n\nfig,axes = plt.subplots(1,3,figsize=(16,5))\nim0 = axes[0].imshow(lon_data)\naxes[0].set_title('Longitude')\nfig.colorbar(im0, ax=axes[0])\nim1 = axes[1].imshow(lat_data)\naxes[1].set_title('Latitude')\nfig.colorbar(im1, ax=axes[1])\nim2 = axes[2].imshow(hgt_data)\naxes[2].set_title('Height')\nfig.colorbar(im2, ax=axes[2])\nfig.show()\n\n\n\n\n\n\n\n\n\nsource\n\n\nload_gamma_look_vector\n\n load_gamma_look_vector (theta:str, phi:str, lt:str, rslc_par:str,\n                         dem_par:str, scratch_dir:str, theta_zarr:str,\n                         phi_zarr:str, chunks:tuple[int,int]=(1000, 1000))\n\nLoad look vector (elevation angle and orientation angle) in map geometry from gamma binary format to look vector in radar geometry zarr file. The two input data should be generated with the look_vector gamma command. All data equal to 0 are replaced with nan.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ntheta\nstr\n\nelevation angle\n\n\nphi\nstr\n\norientation angle\n\n\nlt\nstr\n\nlookup table\n\n\nrslc_par\nstr\n\npar file of the reference rslc\n\n\ndem_par\nstr\n\ndem par\n\n\nscratch_dir\nstr\n\ndirectory for preserve gamma intermediate files\n\n\ntheta_zarr\nstr\n\noutput, elevation angle zarr\n\n\nphi_zarr\nstr\n\noutput, orientation angle zarr\n\n\nchunks\ntuple\n(1000, 1000)\nrslc chunk size\n\n\n\nAn example:\n\nlt = '../../data/gamma/geocoding/20210802.lt_fine'\nrslc_par = '../../data/gamma/rslc/20220620.rslc.par'\ndem_par = '../../data/gamma/DEM/dem_seg_par'\ntheta = '../../data/gamma/geocoding/20210802.lv_theta'\nphi = '../../data/gamma/geocoding/20210802.lv_phi'\nscratch_dir = './raw/scratch'\ntheta_zarr = './raw/theta.zarr'\nphi_zarr = './raw/phi.zarr'\n\n\nload_gamma_look_vector(theta,phi,lt,rslc_par,dem_par,scratch_dir,theta_zarr,phi_zarr,chunks=(1000,1000))\n\n2025-09-18 12:16:18 - log_args - INFO - running function: load_gamma_look_vector\n2025-09-18 12:16:18 - log_args - INFO - fetching args:\n2025-09-18 12:16:18 - log_args - INFO - theta = '../../data/gamma/geocoding/20210802.lv_theta'\n2025-09-18 12:16:18 - log_args - INFO - phi = '../../data/gamma/geocoding/20210802.lv_phi'\n2025-09-18 12:16:18 - log_args - INFO - lt = '../../data/gamma/geocoding/20210802.lt_fine'\n2025-09-18 12:16:18 - log_args - INFO - rslc_par = '../../data/gamma/rslc/20220620.rslc.par'\n2025-09-18 12:16:18 - log_args - INFO - dem_par = '../../data/gamma/DEM/dem_seg_par'\n2025-09-18 12:16:18 - log_args - INFO - scratch_dir = './raw/scratch'\n2025-09-18 12:16:18 - log_args - INFO - theta_zarr = './raw/theta.zarr'\n2025-09-18 12:16:18 - log_args - INFO - phi_zarr = './raw/phi.zarr'\n2025-09-18 12:16:18 - log_args - INFO - chunks = (1000, 1000)\n2025-09-18 12:16:18 - log_args - INFO - fetching args done.\n2025-09-18 12:16:18 - load_gamma_look_vector - INFO - image shape: (2500,1834)\n2025-09-18 12:16:18 - load_gamma_look_vector - INFO - raw/scratch/theta_rdc exists. skip runing geocode ../../data/gamma/geocoding/20210802.lt_fine ../../data/gamma/geocoding/20210802.lv_theta 5741 raw/scratch/theta_rdc 1834 2500 &gt;&gt; raw/scratch/gamma.log\n2025-09-18 12:16:18 - load_gamma_look_vector - INFO - writing data.\n2025-09-18 12:16:19 - load_gamma_look_vector - INFO - raw/scratch/phi_rdc exists. skip runing geocode ../../data/gamma/geocoding/20210802.lt_fine ../../data/gamma/geocoding/20210802.lv_phi 5741 raw/scratch/phi_rdc 1834 2500 &gt;&gt; raw/scratch/gamma.log\n2025-09-18 12:16:19 - load_gamma_look_vector - INFO - writing data.\n2025-09-18 12:16:19 - load_gamma_look_vector - INFO - Done.\n\n\n\ntheta_data = zarr.open(theta_zarr,mode='r')[:]\nphi_data = zarr.open(phi_zarr,mode='r')[:]\n# theta_data[theta_data==0] = np.nan\n# phi_data[phi_data==0] = np.nan\n\n\nfig,axes = plt.subplots(1,2,figsize=(11,5))\nim0 = axes[0].imshow(np.rad2deg(theta_data))\naxes[0].set_title('Elevation angle')\nfig.colorbar(im0, ax=axes[0])\nim1 = axes[1].imshow(np.rad2deg(phi_data))\naxes[1].set_title('Orientation anlge')\nfig.colorbar(im1, ax=axes[1])\nfig.show()\n\n\n\n\n\n\n\n\n\nsource\n\n\nload_gamma_range\n\n load_gamma_range (rslc_par:str, range_zarr:str,\n                   chunks:tuple[int,int]=(1000, 1000))\n\nGenerate slant range distance and save to zarr.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nrslc_par\nstr\n\npar file of one rslc\n\n\nrange_zarr\nstr\n\noutput, range distance zarr\n\n\nchunks\ntuple\n(1000, 1000)\nrslc chunk size\n\n\n\nAn example:\n\nrslc_par = '../../data/gamma/rslc/20220620.rslc.par'\nrange_zarr = './raw/range.zarr'\n\n\nload_gamma_range(rslc_par,range_zarr)\n\n2025-09-18 12:16:28 - log_args - INFO - running function: load_gamma_range\n2025-09-18 12:16:28 - log_args - INFO - fetching args:\n2025-09-18 12:16:28 - log_args - INFO - rslc_par = '../../data/gamma/rslc/20220620.rslc.par'\n2025-09-18 12:16:28 - log_args - INFO - range_zarr = './raw/range.zarr'\n2025-09-18 12:16:28 - log_args - INFO - chunks = (1000, 1000)\n2025-09-18 12:16:28 - log_args - INFO - fetching args done.\n2025-09-18 12:16:28 - load_gamma_range - INFO - image shape: (2500,1834)\n2025-09-18 12:16:28 - load_gamma_range - INFO - Calculating slant range distance.\n2025-09-18 12:16:28 - load_gamma_range - INFO - writing data.\n2025-09-18 12:16:28 - load_gamma_range - INFO - Done.\n\n\n\nrange_data = zarr.open(range_zarr,mode='r')[:]\nplt.imshow(range_data)\nplt.colorbar()\nplt.title(\"Slant range distance\")\nplt.show()\n\n\n\n\n\n\n\n\n\nsource\n\n\nload_gamma_metadata\n\n load_gamma_metadata (rslc_dir:str, dem_par:str, reference:str,\n                      meta_file:str)\n\nLoad necessary metadata into a toml file.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nrslc_dir\nstr\ngamma rslc directory, the name of the rslc and their par files should be ‘????????.rslc’ and ‘????????.rslc.par’\n\n\ndem_par\nstr\ndem par\n\n\nreference\nstr\nreference date, eg: ‘20200202’\n\n\nmeta_file\nstr\noutput, text toml file for meta data\n\n\n\nAn example:\n\nrslc_dir = '../../data/gamma/rslc'\ndem_par = '../../data/gamma/DEM/dem_seg_par'\nreference = '20220620'\nmeta_file = './raw/meta.toml'\n\n\nload_gamma_metadata(rslc_dir,dem_par,reference,meta_file)\n\n2025-09-18 12:16:32 - log_args - INFO - running function: load_gamma_metadata\n2025-09-18 12:16:32 - log_args - INFO - fetching args:\n2025-09-18 12:16:32 - log_args - INFO - rslc_dir = '../../data/gamma/rslc'\n2025-09-18 12:16:32 - log_args - INFO - dem_par = '../../data/gamma/DEM/dem_seg_par'\n2025-09-18 12:16:32 - log_args - INFO - reference = '20220620'\n2025-09-18 12:16:32 - log_args - INFO - meta_file = './raw/meta.toml'\n2025-09-18 12:16:32 - log_args - INFO - fetching args done.\n2025-09-18 12:16:32 - load_gamma_metadata - INFO - fetching slc related metadata.\n2025-09-18 12:16:32 - load_gamma_metadata - INFO - Fetching heading angle\n2025-09-18 12:16:32 - load_gamma_metadata - INFO - Fetching range pixel spacing\n2025-09-18 12:16:32 - load_gamma_metadata - INFO - fetching azimuth pixel spacing\n2025-09-18 12:16:32 - load_gamma_metadata - INFO - Fetching randar wavelength\n2025-09-18 12:16:32 - load_gamma_metadata - INFO - fetching dem related metadata\n2025-09-18 12:16:32 - load_gamma_metadata - INFO - Run gamma command to calculate baseline:\n2025-09-18 12:16:32 - load_gamma_metadata - INFO - run command: base_calc /tmp/tmp3_y94kea/slc_tab ../../data/gamma/rslc/20220620.rslc.par /tmp/tmp3_y94kea/bperp /tmp/tmp3_y94kea/itab - &gt; /tmp/tmp3_y94kea/log\n2025-09-18 12:16:32 - load_gamma_metadata - INFO - gamma command finished.\n2025-09-18 12:16:32 - load_gamma_metadata - INFO - All meta data: \ndates = [ \"20210802\", \"20210816\", \"20210830\", \"20210913\", \"20211011\", \"20211025\", \"20220606\", \"20220620\", \"20220704\", \"20220718\", \"20220801\", \"20220815\", \"20220829\", \"20220912\", \"20220926\", \"20221010\", \"20221024\",]\nradar_wavelength = 0.24245249210715603\nrange_pixel_spacing = 4.29054\nazimuth_pixel_spacing = 3.740105\nlonlat_bbox = [ -148.2606018, 61.099475398661994, -147.89598577255998, 61.2183333,]\nmerca_bbox = [ -16504294.694782883, 8648700.085300261, -16463705.824278845, 8676129.004166307,]\nperpendicular_baseline = [ -97.61360168457031, -45.58580017089844, 17.86680030822754, -26.258899688720703, -63.72420120239258, -56.363399505615234, 64.75759887695312, 0.0, -9.043999671936035, -13.02869987487793, -112.94960021972656, -86.09490203857422, -129.9635009765625, -127.6594009399414, -182.29519653320312, -129.735107421875, -184.31100463867188,]\n\n2025-09-18 12:16:32 - load_gamma_metadata - INFO - writing data in toml file.\n2025-09-18 12:16:32 - load_gamma_metadata - INFO - Done.\n\n\n\nwith open(meta_file,'r') as f:\n    meta_read = toml.load(f)\n\n\nmeta_read\n\n{'dates': ['20210802',\n  '20210816',\n  '20210830',\n  '20210913',\n  '20211011',\n  '20211025',\n  '20220606',\n  '20220620',\n  '20220704',\n  '20220718',\n  '20220801',\n  '20220815',\n  '20220829',\n  '20220912',\n  '20220926',\n  '20221010',\n  '20221024'],\n 'radar_wavelength': 0.24245249210715603,\n 'range_pixel_spacing': 4.29054,\n 'azimuth_pixel_spacing': 3.740105,\n 'lonlat_bbox': [-148.2606018,\n  61.099475398661994,\n  -147.89598577255998,\n  61.2183333],\n 'merca_bbox': [-16504294.694782883,\n  8648700.085300261,\n  -16463705.824278845,\n  8676129.004166307],\n 'perpendicular_baseline': [-97.61360168457031,\n  -45.58580017089844,\n  17.86680030822754,\n  -26.258899688720703,\n  -63.72420120239258,\n  -56.363399505615234,\n  64.75759887695312,\n  0.0,\n  -9.043999671936035,\n  -13.02869987487793,\n  -112.94960021972656,\n  -86.09490203857422,\n  -129.9635009765625,\n  -127.6594009399414,\n  -182.29519653320312,\n  -129.735107421875,\n  -184.31100463867188]}",
    "crumbs": [
      "CLI",
      "load"
    ]
  },
  {
    "objectID": "CLI/dl.html",
    "href": "CLI/dl.html",
    "title": "dl",
    "section": "",
    "text": "from matplotlib import pyplot as plt\nimport zarr\nimport colorcet\nimport moraine.cli as mc\nfrom moraine.utils_ import is_cuda_available\nimport numpy as np\nimport holoviews as hv\nfrom bokeh.models import WheelZoomTool\nfrom holoviews import opts\n\n\nhv.extension('bokeh')\nhv.output(widget_location='bottom')\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n  \n  \n\n\n\n\n\n\n\n\nⓘ\n\n\n\n\n\nrslc_zarr = zarr.open('../CLI/raw/rslc.zarr/',mode='r')\nref_ = rslc_zarr[:,:,7]\nsec_ = rslc_zarr[:,:,13]\n\n\n#filtered_intf = _cli_n2f_cpu(ref,sec,depths=(10,10))\nfiltered_intf = _cli_n2f_np_in_gpu(ref_,sec_,depths=(0,0))\n#filtered_intf = _cli_n2f_np_in_gpu(ref,sec,chunks=(2000,2000),depths=(0,0))\n\nCPU times: user 3.44 s, sys: 565 ms, total: 4 s\nWall time: 998 ms\n\n\n\nsource\n\nn2f\n\n n2f (rslc:str, intf:str, image_pairs:numpy.ndarray, chunks:tuple=None,\n      out_chunks:tuple=None, depths:tuple=(0, 0), model:str=None,\n      cuda:bool=False, processes=None, n_workers=None,\n      threads_per_worker=None, rmm_pool_size=0.9, **dask_cluster_arg)\n\nNoise2Fringe interferogram filtering.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nrslc\nstr\n\ninput: rslc stack, shape (nlines, width, nimages)\n\n\nintf\nstr\n\noutput: filtered intfergrams stack, shape (nlines, width, nimage_pairs )\n\n\nimage_pairs\nndarray\n\ninput: image pairs\n\n\nchunks\ntuple\nNone\nparallel processing azimuth/range chunk size, optional. Default: rslc.chunks[:2]\n\n\nout_chunks\ntuple\nNone\noutput chunks\n\n\ndepths\ntuple\n(0, 0)\nwidth of the boundary\n\n\nmodel\nstr\nNone\npath to the model in onnx format, use the model comes with this package by default\n\n\ncuda\nbool\nFalse\nif use cuda for processing, false by default\n\n\nprocesses\nNoneType\nNone\nuse process for dask worker over thread, the default is True for cpu, only applied if cuda==False\n\n\nn_workers\nNoneType\nNone\nnumber of dask worker, the default is 1 for cpu, number of GPUs for cuda\n\n\nthreads_per_worker\nNoneType\nNone\nnumber of threads per dask worker, the default is 1 for cpu, only applied if cuda==False\n\n\nrmm_pool_size\nfloat\n0.9\nset the rmm pool size, only applied when cuda==True\n\n\ndask_cluster_arg\nVAR_KEYWORD\n\n\n\n\n\n\nlogger = mc.get_logger()\n\n\nrslc = './raw/rslc.zarr/'\nintf = './dl/n2f_intf.zarr'\n\n\nrslc_zarr = zarr.open(rslc,mode='r')\ntnet = mr.TempNet.from_bandwidth(rslc_zarr.shape[-1], 1)\n\n\nn2f(rslc,intf,tnet.image_pairs,chunks=(2500,1834))\n\n2025-09-20 00:03:10 - log_args - INFO - running function: n2f\n2025-09-20 00:03:10 - log_args - INFO - fetching args:\n2025-09-20 00:03:10 - log_args - INFO - rslc = './raw/rslc.zarr/'\n2025-09-20 00:03:10 - log_args - INFO - intf = './dl/n2f_intf.zarr'\n2025-09-20 00:03:10 - log_args - INFO - image_pairs = array([[ 0,  1],\n       [ 1,  2],\n       [ 2,  3],\n       [ 3,  4],\n       [ 4,  5],\n       [ 5,  6],\n       [ 6,  7],\n       [ 7,  8],\n       [ 8,  9],\n       [ 9, 10],\n       [10, 11],\n       [11, 12],\n       [12, 13],\n       [13, 14],\n       [14, 15],\n       [15, 16]], dtype=int32)\n2025-09-20 00:03:10 - log_args - INFO - chunks = (2500, 1834)\n2025-09-20 00:03:10 - log_args - INFO - out_chunks = None\n2025-09-20 00:03:10 - log_args - INFO - depths = (0, 0)\n2025-09-20 00:03:10 - log_args - INFO - model = None\n2025-09-20 00:03:10 - log_args - INFO - cuda = False\n2025-09-20 00:03:10 - log_args - INFO - processes = None\n2025-09-20 00:03:10 - log_args - INFO - n_workers = None\n2025-09-20 00:03:10 - log_args - INFO - threads_per_worker = None\n2025-09-20 00:03:10 - log_args - INFO - rmm_pool_size = 0.5\n2025-09-20 00:03:10 - log_args - INFO - dask_cluster_arg = {}\n2025-09-20 00:03:10 - log_args - INFO - fetching args done.\n2025-09-20 00:03:10 - zarr_info - INFO - ./raw/rslc.zarr/ zarray shape, chunks, dtype: (2500, 1834, 17), (1000, 1000, 1), complex64\n2025-09-20 00:03:10 - n2f - INFO - processing azimuth chunk size: 2500\n2025-09-20 00:03:10 - n2f - INFO - processing range chunk size: 1834\n2025-09-20 00:03:10 - n2f - INFO - starting dask cluster.\n2025-09-20 00:03:12 - n2f - INFO - dask cluster started.\n2025-09-20 00:03:12 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://127.0.0.1:8787/status', workers=1, threads=1, memory=1.95 TiB)\n2025-09-20 00:03:12 - darr_info - INFO - rslc dask array shape, chunksize, dtype: (2500, 1834, 17), (2500, 1834, 1), complex64\n2025-09-20 00:03:12 - n2f - INFO - got filtered interferograms.\n2025-09-20 00:03:12 - darr_info - INFO - intf dask array shape, chunksize, dtype: (2500, 1834, 16), (2500, 1834, 1), complex64\n2025-09-20 00:03:12 - n2f - INFO - saving filtered interferograms.\n2025-09-20 00:03:12 - zarr_info - INFO - ./dl/n2f_intf.zarr zarray shape, chunks, dtype: (2500, 1834, 16), (1000, 1000, 1), complex64\n2025-09-20 00:03:12 - n2f - INFO - computing graph setted. doing all the computing.\n2025-09-20 00:04:28 - n2f - INFO - computing finished.leted |  1min 16.7s\n2025-09-20 00:04:30 - n2f - INFO - dask cluster closed.\nCPU times: user 3.34 s, sys: 2.36 s, total: 5.7 s\nWall time: 1min 19s\n\n\n\nsource\n\n\nn2ft\n\n n2ft (x:str, y:str, rslc:str, intf:str, image_pairs:numpy.ndarray,\n       chunks:int=None, out_chunks:int=None, k:int=128, model:str=None,\n       cuda:bool=False, processes=None, n_workers=None,\n       threads_per_worker=None, rmm_pool_size=0.9, **dask_cluster_arg)\n\nNoise2Fringe interferogram filtering.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nx\nstr\n\ninput: x coordinate, e.g., longitude, shape (n,)\n\n\ny\nstr\n\ninput: y coordinate, e.g., latitude, shape (n,)\n\n\nrslc\nstr\n\ninput: rslc stack, shape (n, nimages)\n\n\nintf\nstr\n\noutput: filtered intfergrams stack, shape (n, nimage_pairs )\n\n\nimage_pairs\nndarray\n\ninput: image pairs\n\n\nchunks\nint\nNone\nparallel processing point chunk size, optional. Default: rslc.chunks[0]\n\n\nout_chunks\nint\nNone\noutput point chunk size, Default: rslc.chunks[0]\n\n\nk\nint\n128\nhalo size for chunkwise processing\n\n\nmodel\nstr\nNone\npath to the model in onnx format, use the model comes with this package by default\n\n\ncuda\nbool\nFalse\nif use cuda for processing, false by default\n\n\nprocesses\nNoneType\nNone\nuse process for dask worker over thread, the default is True for cpu, only applied if cuda==False\n\n\nn_workers\nNoneType\nNone\nnumber of dask worker, the default is 1 for cpu, number of GPUs for cuda\n\n\nthreads_per_worker\nNoneType\nNone\nnumber of threads per dask worker, the default is 1 for cpu, only applied if cuda==False\n\n\nrmm_pool_size\nfloat\n0.9\nset the rmm pool size, only applied when cuda==True\n\n\ndask_cluster_arg\nVAR_KEYWORD\n\n\n\n\n\nUsage:\n\nbase = '../Tutorials/CLI/ps_processing/'\nps_can_rslc = base+'hix/ps_can_rslc.zarr/'\nps_can_lon = base+'hix/ps_can_lon.zarr'\nps_can_lat = base+'hix/ps_can_lat.zarr'\nps_can_filtered_intf = './dl/ps_can_n2ft_intf.zarr'\n\n\nps_can_rslc_zarr = zarr.open(ps_can_rslc,mode='r')\ntnet = mr.TempNet.from_bandwidth(ps_can_rslc_zarr.shape[-1], 1)\n\n\nn2ft(ps_can_lon, ps_can_lat, ps_can_rslc, ps_can_filtered_intf, tnet.image_pairs, chunks=50000)\n\n2025-09-20 00:04:31 - log_args - INFO - running function: n2ft\n2025-09-20 00:04:31 - log_args - INFO - fetching args:\n2025-09-20 00:04:31 - log_args - INFO - x = '../Tutorials/CLI/ps_processing/hix/ps_can_lon.zarr'\n2025-09-20 00:04:31 - log_args - INFO - y = '../Tutorials/CLI/ps_processing/hix/ps_can_lat.zarr'\n2025-09-20 00:04:31 - log_args - INFO - rslc = '../Tutorials/CLI/ps_processing/hix/ps_can_rslc.zarr/'\n2025-09-20 00:04:31 - log_args - INFO - intf = './dl/ps_can_n2ft_intf.zarr'\n2025-09-20 00:04:31 - log_args - INFO - image_pairs = array([[ 0,  1],\n       [ 1,  2],\n       [ 2,  3],\n       [ 3,  4],\n       [ 4,  5],\n       [ 5,  6],\n       [ 6,  7],\n       [ 7,  8],\n       [ 8,  9],\n       [ 9, 10],\n       [10, 11],\n       [11, 12],\n       [12, 13],\n       [13, 14],\n       [14, 15],\n       [15, 16]], dtype=int32)\n2025-09-20 00:04:31 - log_args - INFO - chunks = 50000\n2025-09-20 00:04:31 - log_args - INFO - out_chunks = None\n2025-09-20 00:04:31 - log_args - INFO - k = 128\n2025-09-20 00:04:31 - log_args - INFO - model = None\n2025-09-20 00:04:31 - log_args - INFO - cuda = False\n2025-09-20 00:04:31 - log_args - INFO - processes = None\n2025-09-20 00:04:31 - log_args - INFO - n_workers = None\n2025-09-20 00:04:31 - log_args - INFO - threads_per_worker = None\n2025-09-20 00:04:31 - log_args - INFO - rmm_pool_size = 0.5\n2025-09-20 00:04:31 - log_args - INFO - dask_cluster_arg = {}\n2025-09-20 00:04:31 - log_args - INFO - fetching args done.\n2025-09-20 00:04:31 - n2ft - INFO - load coordinates\n2025-09-20 00:04:31 - n2ft - INFO - Done\n2025-09-20 00:04:31 - zarr_info - INFO - ../Tutorials/CLI/ps_processing/hix/ps_can_rslc.zarr/ zarray shape, chunks, dtype: (43201, 17), (20000, 1), complex64\n2025-09-20 00:04:31 - n2ft - INFO - processing point chunk size: 50000\n2025-09-20 00:04:31 - n2ft - INFO - distributing every processing chunk with halo data\n2025-09-20 00:04:35 - n2ft - INFO - processing chunk size with halo data: [43201]\n2025-09-20 00:04:35 - n2ft - INFO - starting dask cluster.\n2025-09-20 00:04:36 - n2ft - INFO - dask cluster started.\n2025-09-20 00:04:36 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://127.0.0.1:8787/status', workers=1, threads=1, memory=1.95 TiB)\n2025-09-20 00:04:36 - darr_info - INFO - rslc dask array shape, chunksize, dtype: (43201, 17), (43201, 1), complex64\n2025-09-20 00:04:36 - n2ft - INFO - got filtered interferograms.\n2025-09-20 00:04:36 - darr_info - INFO - intf dask array shape, chunksize, dtype: (43201, 16), (43201, 1), complex64\n2025-09-20 00:04:36 - n2ft - INFO - saving filtered interferograms.\n2025-09-20 00:04:36 - zarr_info - INFO - ./dl/ps_can_n2ft_intf.zarr zarray shape, chunks, dtype: (43201, 16), (20000, 1), complex64\n2025-09-20 00:04:36 - n2ft - INFO - computing graph setted. doing all the computing.\n2025-09-20 00:05:03 - n2ft - INFO - computing finished.eted | 26.5s\n2025-09-20 00:05:04 - n2ft - INFO - dask cluster closed.\nCPU times: user 6.12 s, sys: 583 ms, total: 6.7 s\nWall time: 33 s\n\n\n\nif is_cuda_available():\n    n2ft(ps_can_lon, ps_can_lat, ps_can_rslc, ps_can_filtered_intf, tnet.image_pairs, chunks=50000, cuda=True)\n\n2025-09-20 00:05:04 - log_args - INFO - running function: n2ft\n2025-09-20 00:05:04 - log_args - INFO - fetching args:\n2025-09-20 00:05:04 - log_args - INFO - x = '../Tutorials/CLI/ps_processing/hix/ps_can_lon.zarr'\n2025-09-20 00:05:04 - log_args - INFO - y = '../Tutorials/CLI/ps_processing/hix/ps_can_lat.zarr'\n2025-09-20 00:05:04 - log_args - INFO - rslc = '../Tutorials/CLI/ps_processing/hix/ps_can_rslc.zarr/'\n2025-09-20 00:05:04 - log_args - INFO - intf = './dl/ps_can_n2ft_intf.zarr'\n2025-09-20 00:05:04 - log_args - INFO - image_pairs = array([[ 0,  1],\n       [ 1,  2],\n       [ 2,  3],\n       [ 3,  4],\n       [ 4,  5],\n       [ 5,  6],\n       [ 6,  7],\n       [ 7,  8],\n       [ 8,  9],\n       [ 9, 10],\n       [10, 11],\n       [11, 12],\n       [12, 13],\n       [13, 14],\n       [14, 15],\n       [15, 16]], dtype=int32)\n2025-09-20 00:05:04 - log_args - INFO - chunks = 50000\n2025-09-20 00:05:04 - log_args - INFO - out_chunks = None\n2025-09-20 00:05:04 - log_args - INFO - k = 128\n2025-09-20 00:05:04 - log_args - INFO - model = None\n2025-09-20 00:05:04 - log_args - INFO - cuda = True\n2025-09-20 00:05:04 - log_args - INFO - processes = None\n2025-09-20 00:05:04 - log_args - INFO - n_workers = None\n2025-09-20 00:05:04 - log_args - INFO - threads_per_worker = None\n2025-09-20 00:05:04 - log_args - INFO - rmm_pool_size = 0.5\n2025-09-20 00:05:04 - log_args - INFO - dask_cluster_arg = {}\n2025-09-20 00:05:04 - log_args - INFO - fetching args done.\n2025-09-20 00:05:04 - n2ft - INFO - load coordinates\n2025-09-20 00:05:04 - n2ft - INFO - Done\n2025-09-20 00:05:04 - zarr_info - INFO - ../Tutorials/CLI/ps_processing/hix/ps_can_rslc.zarr/ zarray shape, chunks, dtype: (43201, 17), (20000, 1), complex64\n2025-09-20 00:05:04 - n2ft - INFO - processing point chunk size: 50000\n2025-09-20 00:05:04 - n2ft - INFO - distributing every processing chunk with halo data\n2025-09-20 00:05:04 - n2ft - INFO - processing chunk size with halo data: [43201]\n2025-09-20 00:05:04 - n2ft - INFO - starting dask cluster.\n2025-09-20 00:05:09 - n2ft - INFO - dask cluster started.\n2025-09-20 00:05:09 - dask_cluster_info - INFO - dask cluster: LocalCUDACluster(dashboard_link='http://127.0.0.1:8787/status', workers=8, threads=8, memory=1.95 TiB)\n2025-09-20 00:05:09 - darr_info - INFO - rslc dask array shape, chunksize, dtype: (43201, 17), (43201, 1), complex64\n2025-09-20 00:05:09 - n2ft - INFO - got filtered interferograms.\n2025-09-20 00:05:09 - darr_info - INFO - intf dask array shape, chunksize, dtype: (43201, 16), (43201, 1), complex64\n2025-09-20 00:05:09 - n2ft - INFO - saving filtered interferograms.\n2025-09-20 00:05:10 - zarr_info - INFO - ./dl/ps_can_n2ft_intf.zarr zarray shape, chunks, dtype: (43201, 16), (20000, 1), complex64\n2025-09-20 00:05:10 - n2ft - INFO - computing graph setted. doing all the computing.\n2025-09-20 00:05:15 - n2ft - INFO - computing finished.eted |  5.3s\n2025-09-20 00:05:17 - n2ft - INFO - dask cluster closed.\nCPU times: user 1.54 s, sys: 410 ms, total: 1.95 s\nWall time: 13 s\n\n\n\nps_can_x = base+'hix/ps_can_e.zarr'\nps_can_y = base+'hix/ps_can_n.zarr'\nps_can_filtered_intf_pyramid_dir = './dl/ps_can_n2ft_intf_pyramid'\ndates = [\"20210802\", \"20210816\", \"20210830\", \"20210913\", \"20211011\", \"20211025\", \"20220606\", \"20220620\",\n         \"20220704\", \"20220718\", \"20220801\", \"20220815\", \"20220829\", \"20220912\", \"20220926\", \"20221010\",\n         \"20221024\",]\n\n\nmc.pc_pyramid(ps_can_filtered_intf, ps_can_filtered_intf_pyramid_dir, x=ps_can_x, y=ps_can_y, ras_resolution=20)\n\n2025-09-20 00:05:17 - log_args - INFO - running function: pc_pyramid\n2025-09-20 00:05:17 - log_args - INFO - fetching args:\n2025-09-20 00:05:17 - log_args - INFO - pc = './dl/ps_can_n2ft_intf.zarr'\n2025-09-20 00:05:17 - log_args - INFO - out_dir = './dl/ps_can_n2ft_intf_pyramid'\n2025-09-20 00:05:17 - log_args - INFO - x = '../Tutorials/CLI/ps_processing/hix/ps_can_e.zarr'\n2025-09-20 00:05:17 - log_args - INFO - y = '../Tutorials/CLI/ps_processing/hix/ps_can_n.zarr'\n2025-09-20 00:05:17 - log_args - INFO - yx = None\n2025-09-20 00:05:17 - log_args - INFO - ras_resolution = 20\n2025-09-20 00:05:17 - log_args - INFO - ras_chunks = (256, 256)\n2025-09-20 00:05:17 - log_args - INFO - pc_chunks = 65536\n2025-09-20 00:05:17 - log_args - INFO - processes = False\n2025-09-20 00:05:17 - log_args - INFO - n_workers = 1\n2025-09-20 00:05:17 - log_args - INFO - threads_per_worker = 2\n2025-09-20 00:05:17 - log_args - INFO - dask_cluster_arg = {}\n2025-09-20 00:05:17 - log_args - INFO - fetching args done.\n2025-09-20 00:05:17 - pc_pyramid - INFO - clean out dir\n2025-09-20 00:05:17 - zarr_info - INFO - ./dl/ps_can_n2ft_intf.zarr zarray shape, chunks, dtype: (43201, 16), (20000, 1), complex64\n2025-09-20 00:05:17 - pc_pyramid - INFO - rendering point cloud data coordinates:\n2025-09-20 00:05:17 - pc_pyramid - INFO - rasterizing point cloud data to grid with bounds: [np.float64(-16498455.50940282), np.float64(8649634.094942318), np.float64(-16470215.50940282), np.float64(8674894.094942318)].\n2025-09-20 00:05:17 - zarr_info - INFO - dl/ps_can_n2ft_intf_pyramid/x.zarr zarray shape, chunks, dtype: (43201,), (65536,), float64\n2025-09-20 00:05:17 - zarr_info - INFO - dl/ps_can_n2ft_intf_pyramid/y.zarr zarray shape, chunks, dtype: (43201,), (65536,), float64\n2025-09-20 00:05:17 - pc_pyramid - INFO - pc data coordinates rendering ends.\n2025-09-20 00:05:17 - zarr_info - INFO - dl/ps_can_n2ft_intf_pyramid/idx_0.zarr zarray shape, chunks, dtype: (1264, 1413), (256, 256), int64\n2025-09-20 00:05:19 - zarr_info - INFO - dl/ps_can_n2ft_intf_pyramid/idx_1.zarr zarray shape, chunks, dtype: (632, 707), (256, 256), int64\n2025-09-20 00:05:19 - zarr_info - INFO - dl/ps_can_n2ft_intf_pyramid/idx_2.zarr zarray shape, chunks, dtype: (316, 354), (256, 256), int64\n2025-09-20 00:05:19 - zarr_info - INFO - dl/ps_can_n2ft_intf_pyramid/idx_3.zarr zarray shape, chunks, dtype: (158, 177), (256, 256), int64\n2025-09-20 00:05:19 - zarr_info - INFO - dl/ps_can_n2ft_intf_pyramid/idx_4.zarr zarray shape, chunks, dtype: (79, 89), (256, 256), int64\n2025-09-20 00:05:19 - zarr_info - INFO - dl/ps_can_n2ft_intf_pyramid/idx_5.zarr zarray shape, chunks, dtype: (40, 45), (256, 256), int64\n2025-09-20 00:05:19 - zarr_info - INFO - dl/ps_can_n2ft_intf_pyramid/idx_6.zarr zarray shape, chunks, dtype: (20, 23), (256, 256), int64\n2025-09-20 00:05:19 - zarr_info - INFO - dl/ps_can_n2ft_intf_pyramid/idx_7.zarr zarray shape, chunks, dtype: (10, 12), (256, 256), int64\n2025-09-20 00:05:19 - zarr_info - INFO - dl/ps_can_n2ft_intf_pyramid/idx_8.zarr zarray shape, chunks, dtype: (5, 6), (256, 256), int64\n2025-09-20 00:05:19 - zarr_info - INFO - dl/ps_can_n2ft_intf_pyramid/idx_9.zarr zarray shape, chunks, dtype: (3, 3), (256, 256), int64\n2025-09-20 00:05:19 - zarr_info - INFO - dl/ps_can_n2ft_intf_pyramid/idx_10.zarr zarray shape, chunks, dtype: (2, 2), (256, 256), int64\n2025-09-20 00:05:19 - pc_pyramid - INFO - rasterized idx rendering ends\n2025-09-20 00:05:19 - pc_pyramid - INFO - dask local cluster started to render pc data.\n2025-09-20 00:05:19 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.19:8787/status', workers=1, threads=2, memory=1.95 TiB)\n2025-09-20 00:05:19 - zarr_info - INFO - dl/ps_can_n2ft_intf_pyramid/pc.zarr zarray shape, chunks, dtype: (43201, 16), (65536, 1), complex64\n2025-09-20 00:05:19 - zarr_info - INFO - dl/ps_can_n2ft_intf_pyramid/0.zarr zarray shape, chunks, dtype: (1264, 1413, 16), (256, 256, 1), complex64\n2025-09-20 00:05:19 - zarr_info - INFO - dl/ps_can_n2ft_intf_pyramid/1.zarr zarray shape, chunks, dtype: (632, 707, 16), (256, 256, 1), complex64\n2025-09-20 00:05:19 - zarr_info - INFO - dl/ps_can_n2ft_intf_pyramid/2.zarr zarray shape, chunks, dtype: (316, 354, 16), (256, 256, 1), complex64\n2025-09-20 00:05:19 - zarr_info - INFO - dl/ps_can_n2ft_intf_pyramid/3.zarr zarray shape, chunks, dtype: (158, 177, 16), (256, 256, 1), complex64\n2025-09-20 00:05:19 - zarr_info - INFO - dl/ps_can_n2ft_intf_pyramid/4.zarr zarray shape, chunks, dtype: (79, 89, 16), (256, 256, 1), complex64\n2025-09-20 00:05:19 - zarr_info - INFO - dl/ps_can_n2ft_intf_pyramid/5.zarr zarray shape, chunks, dtype: (40, 45, 16), (256, 256, 1), complex64\n2025-09-20 00:05:19 - zarr_info - INFO - dl/ps_can_n2ft_intf_pyramid/6.zarr zarray shape, chunks, dtype: (20, 23, 16), (256, 256, 1), complex64\n2025-09-20 00:05:19 - zarr_info - INFO - dl/ps_can_n2ft_intf_pyramid/7.zarr zarray shape, chunks, dtype: (10, 12, 16), (256, 256, 1), complex64\n2025-09-20 00:05:19 - zarr_info - INFO - dl/ps_can_n2ft_intf_pyramid/8.zarr zarray shape, chunks, dtype: (5, 6, 16), (256, 256, 1), complex64\n2025-09-20 00:05:19 - zarr_info - INFO - dl/ps_can_n2ft_intf_pyramid/9.zarr zarray shape, chunks, dtype: (3, 3, 16), (256, 256, 1), complex64\n2025-09-20 00:05:19 - zarr_info - INFO - dl/ps_can_n2ft_intf_pyramid/10.zarr zarray shape, chunks, dtype: (2, 2, 16), (256, 256, 1), complex64\n2025-09-20 00:05:20 - pc_pyramid - INFO - computing graph setted. doing all the computing.\n2025-09-20 00:05:22 - pc_pyramid - INFO - computing finished.  1.8s\n2025-09-20 00:05:22 - pc_pyramid - INFO - dask cluster closed.\n\n\n\nrslc_pyramid_dir = base+'hix/ps_can_rslc_pyramid'\n\nps_can_intf_plot = mc.pc_plot(rslc_pyramid_dir,post_proc_ras='intf_seq', post_proc_pc='intf_seq',n_kdim=1,level_increase=0)\nps_can_filtered_intf_plot = mc.pc_plot(ps_can_filtered_intf_pyramid_dir,post_proc_ras='phase', post_proc_pc='phase',level_increase=0)\n\n\nps_can_intf_plot = ps_can_intf_plot.redim(\n    i=hv.Dimension('i', label='Interferogram', range=(0,15), value_format=(lambda i: dates[i]+'_'+dates[i+1])),\n    x=hv.Dimension('r', label='Range'),\n    y=hv.Dimension('az',label='Azimuth'),\n    z=hv.Dimension('Phase',range=(-np.pi,np.pi))\n)\nps_can_filtered_intf_plot = ps_can_filtered_intf_plot.redim(\n    i=hv.Dimension('i', label='Interferogram', range=(0,15), value_format=(lambda i: dates[i]+'_'+dates[i+1])),\n    x=hv.Dimension('r', label='Range'),\n    y=hv.Dimension('az',label='Azimuth'),\n    z=hv.Dimension('Phase',range=(-np.pi,np.pi))\n)\n\nSpecify plotting options and plot:\n\nhv.output(widget_location='bottom')\nps_can_intf_plot.opts(\n    opts.Image(\n        cmap='colorwheel',width=600, height=400, colorbar=True,\n        default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],\n        active_tools=['wheel_zoom']\n    ),\n    opts.Points(\n        color='Phase', cmap='colorwheel',width=600, height=400, colorbar=True,\n        default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],\n        active_tools=['wheel_zoom']\n    )\n)\n\nps_can_filtered_intf_plot.opts(\n    opts.Image(\n        cmap='colorwheel',width=600, height=400, colorbar=True,\n        default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],\n        active_tools=['wheel_zoom']\n    ),\n    opts.Points(\n        color='Phase', cmap='colorwheel',width=600, height=400, colorbar=True,\n        default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],\n        active_tools=['wheel_zoom']\n    )\n)\nps_can_intf_plot+ps_can_filtered_intf_plot",
    "crumbs": [
      "CLI",
      "dl"
    ]
  },
  {
    "objectID": "CLI/pl.html",
    "href": "CLI/pl.html",
    "title": "pl",
    "section": "",
    "text": "from matplotlib import pyplot as plt\nimport zarr\nimport colorcet\nimport moraine.cli as mc\nfrom moraine.utils_ import is_cuda_available\n\n\nsource\n\nemi\n\n emi (coh:str, ph:str, emi_quality:str, ref:int=0, chunks:int=None,\n      cuda:bool=False, processes=None, n_workers=None,\n      threads_per_worker=None, rmm_pool_size=0.9, **dask_cluster_arg)\n\nPhase linking with EMI estimator.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ncoh\nstr\n\ncoherence matrix\n\n\nph\nstr\n\noutput, wrapped phase\n\n\nemi_quality\nstr\n\noutput, pixel quality\n\n\nref\nint\n0\nreference image for phase\n\n\nchunks\nint\nNone\n# chunk size of output zarr dataset, optional. Default: same as coh.\n\n\ncuda\nbool\nFalse\nif use cuda for processing, false by default\n\n\nprocesses\nNoneType\nNone\nuse process for dask worker over thread, the default is False for cpu, only applied if cuda==False\n\n\nn_workers\nNoneType\nNone\nnumber of dask worker, the default is 1 for cpu, number of GPU for cuda\n\n\nthreads_per_worker\nNoneType\nNone\nnumber of threads per dask worker, the default is 2 for cpu, only applied if cuda==False\n\n\nrmm_pool_size\nfloat\n0.9\nset the rmm pool size, only applied when cuda==True\n\n\ndask_cluster_arg\nVAR_KEYWORD\n\n\n\n\n\n\nds_can_coh = './co/ds_can_coh.zarr'\nds_can_ph = './pl/ds_can_ph.zarr'\nds_can_emi_quality = './pl/ds_can_emi_quality.zarr'\nref = 0\n\n\nlogger = mc.get_logger()\n\n\nemi(ds_can_coh,ds_can_ph,ds_can_emi_quality,ref=ref)\n\n2025-09-18 12:47:02 - log_args - INFO - running function: emi\n2025-09-18 12:47:02 - log_args - INFO - fetching args:\n2025-09-18 12:47:02 - log_args - INFO - coh = './co/ds_can_coh.zarr'\n2025-09-18 12:47:02 - log_args - INFO - ph = './pl/ds_can_ph.zarr'\n2025-09-18 12:47:02 - log_args - INFO - emi_quality = './pl/ds_can_emi_quality.zarr'\n2025-09-18 12:47:02 - log_args - INFO - ref = 0\n2025-09-18 12:47:02 - log_args - INFO - chunks = None\n2025-09-18 12:47:02 - log_args - INFO - cuda = False\n2025-09-18 12:47:02 - log_args - INFO - processes = None\n2025-09-18 12:47:02 - log_args - INFO - n_workers = None\n2025-09-18 12:47:02 - log_args - INFO - threads_per_worker = None\n2025-09-18 12:47:02 - log_args - INFO - rmm_pool_size = 0.9\n2025-09-18 12:47:02 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 12:47:02 - log_args - INFO - fetching args done.\n2025-09-18 12:47:02 - zarr_info - INFO - ./co/ds_can_coh.zarr zarray shape, chunks, dtype: (732727, 136), (100000, 1), complex64\n2025-09-18 12:47:02 - emi - INFO - starting dask cluster.\n2025-09-18 12:47:04 - emi - INFO - dask cluster started.\n2025-09-18 12:47:04 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.4:8787/status', workers=1, threads=2, memory=256.00 GiB)\n2025-09-18 12:47:04 - darr_info - INFO - coh dask array shape, chunksize, dtype: (732727, 136), (100000, 136), complex64\n2025-09-18 12:47:04 - emi - INFO - phase linking with EMI.\n2025-09-18 12:47:04 - emi - INFO - got ph and emi_quality.\n2025-09-18 12:47:04 - darr_info - INFO - ph dask array shape, chunksize, dtype: (732727, 17), (100000, 17), complex64\n2025-09-18 12:47:04 - darr_info - INFO - emi_quality dask array shape, chunksize, dtype: (732727,), (100000,), float32\n2025-09-18 12:47:04 - emi - INFO - saving ph and emi_quality.\n2025-09-18 12:47:04 - zarr_info - INFO - ./pl/ds_can_ph.zarr zarray shape, chunks, dtype: (732727, 17), (100000, 1), complex64\n2025-09-18 12:47:04 - zarr_info - INFO - ./pl/ds_can_emi_quality.zarr zarray shape, chunks, dtype: (732727,), (100000,), float32\n2025-09-18 12:47:04 - emi - INFO - computing graph setted. doing all the computing.\n2025-09-18 12:47:12 - emi - INFO - computing finished.leted |  7.6s\n2025-09-18 12:47:12 - emi - INFO - dask cluster closed.\nCPU times: user 1min 16s, sys: 4.18 s, total: 1min 20s\nWall time: 9.82 s\n\n\n\nif is_cuda_available():\n    emi(ds_can_coh,ds_can_ph,ds_can_emi_quality,ref=ref,cuda=True)\n\n2025-09-18 12:47:12 - log_args - INFO - running function: emi\n2025-09-18 12:47:12 - log_args - INFO - fetching args:\n2025-09-18 12:47:12 - log_args - INFO - coh = './co/ds_can_coh.zarr'\n2025-09-18 12:47:12 - log_args - INFO - ph = './pl/ds_can_ph.zarr'\n2025-09-18 12:47:12 - log_args - INFO - emi_quality = './pl/ds_can_emi_quality.zarr'\n2025-09-18 12:47:12 - log_args - INFO - ref = 0\n2025-09-18 12:47:12 - log_args - INFO - chunks = None\n2025-09-18 12:47:12 - log_args - INFO - cuda = True\n2025-09-18 12:47:12 - log_args - INFO - processes = None\n2025-09-18 12:47:12 - log_args - INFO - n_workers = None\n2025-09-18 12:47:12 - log_args - INFO - threads_per_worker = None\n2025-09-18 12:47:12 - log_args - INFO - rmm_pool_size = 0.9\n2025-09-18 12:47:12 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 12:47:12 - log_args - INFO - fetching args done.\n2025-09-18 12:47:12 - zarr_info - INFO - ./co/ds_can_coh.zarr zarray shape, chunks, dtype: (732727, 136), (100000, 1), complex64\n2025-09-18 12:47:12 - emi - INFO - starting dask cluster.\n\n\n2025-09-18 12:47:14,455 - distributed.worker - WARNING - Setting CPU affinity for GPU failed. Please refer to the following link for troubleshooting information: https://docs.rapids.ai/api/dask-cuda/nightly/troubleshooting/#setting-cpu-affinity-failure\n\n\n2025-09-18 12:47:14 - emi - INFO - dask cluster started.\n2025-09-18 12:47:14 - dask_cluster_info - INFO - dask cluster: LocalCUDACluster(dashboard_link='http://127.0.0.1:8787/status', workers=2, threads=2, memory=256.00 GiB)\n2025-09-18 12:47:15 - darr_info - INFO - coh dask array shape, chunksize, dtype: (732727, 136), (100000, 136), complex64\n2025-09-18 12:47:15 - emi - INFO - phase linking with EMI.\n\n\n2025-09-18 12:47:14,939 - distributed.worker - WARNING - Setting CPU affinity for GPU failed. Please refer to the following link for troubleshooting information: https://docs.rapids.ai/api/dask-cuda/nightly/troubleshooting/#setting-cpu-affinity-failure\n\n\n2025-09-18 12:47:15 - emi - INFO - got ph and emi_quality.\n2025-09-18 12:47:15 - darr_info - INFO - ph dask array shape, chunksize, dtype: (732727, 17), (100000, 17), complex64\n2025-09-18 12:47:15 - darr_info - INFO - emi_quality dask array shape, chunksize, dtype: (732727,), (100000,), float32\n2025-09-18 12:47:15 - emi - INFO - saving ph and emi_quality.\n2025-09-18 12:47:15 - zarr_info - INFO - ./pl/ds_can_ph.zarr zarray shape, chunks, dtype: (732727, 17), (100000, 1), complex64\n2025-09-18 12:47:15 - zarr_info - INFO - ./pl/ds_can_emi_quality.zarr zarray shape, chunks, dtype: (732727,), (100000,), float32\n2025-09-18 12:47:15 - emi - INFO - computing graph setted. doing all the computing.\n2025-09-18 12:47:18 - emi - INFO - computing finished.leted |  3.2s\n2025-09-18 12:47:19 - emi - INFO - dask cluster closed.\nCPU times: user 276 ms, sys: 403 ms, total: 680 ms\nWall time: 6.91 s\n\n\n\nds_can_gix = './shp/ds_can_gix.zarr'\nemi_quality = './pl/emi_quality.zarr'\nrslc_zarr = zarr.open('./raw/rslc.zarr/',mode='r')\nmc.pc2ras(ds_can_gix, ds_can_emi_quality,emi_quality,rslc_zarr.shape[:2])\n\n2025-09-18 12:47:19 - log_args - INFO - running function: pc2ras\n2025-09-18 12:47:19 - log_args - INFO - fetching args:\n2025-09-18 12:47:19 - log_args - INFO - idx = './shp/ds_can_gix.zarr'\n2025-09-18 12:47:19 - log_args - INFO - pc = './pl/ds_can_emi_quality.zarr'\n2025-09-18 12:47:19 - log_args - INFO - ras = './pl/emi_quality.zarr'\n2025-09-18 12:47:19 - log_args - INFO - shape = (2500, 1834)\n2025-09-18 12:47:19 - log_args - INFO - chunks = (1000, 1000)\n2025-09-18 12:47:19 - log_args - INFO - processes = False\n2025-09-18 12:47:19 - log_args - INFO - n_workers = 1\n2025-09-18 12:47:19 - log_args - INFO - threads_per_worker = 1\n2025-09-18 12:47:19 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 12:47:19 - log_args - INFO - fetching args done.\n2025-09-18 12:47:19 - zarr_info - INFO - ./shp/ds_can_gix.zarr zarray shape, chunks, dtype: (732727, 2), (100000, 1), int32\n2025-09-18 12:47:19 - pc2ras - INFO - loading gix into memory.\n2025-09-18 12:47:19 - pc2ras - INFO - starting dask local cluster.\n2025-09-18 12:47:19 - pc2ras - INFO - dask local cluster started.\n2025-09-18 12:47:19 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.4:8787/status', workers=1, threads=1, memory=256.00 GiB)\n2025-09-18 12:47:19 - pc2ras - INFO - start to work on ./pl/ds_can_emi_quality.zarr\n2025-09-18 12:47:19 - zarr_info - INFO - ./pl/ds_can_emi_quality.zarr zarray shape, chunks, dtype: (732727,), (100000,), float32\n2025-09-18 12:47:19 - darr_info - INFO - pc dask array shape, chunksize, dtype: (732727,), (732727,), float32\n2025-09-18 12:47:19 - pc2ras - INFO - create ras dask array\n2025-09-18 12:47:19 - darr_info - INFO - ras dask array shape, chunksize, dtype: (2500, 1834), (2500, 1834), float32\n2025-09-18 12:47:19 - pc2ras - INFO - save ras to ./pl/emi_quality.zarr\n2025-09-18 12:47:19 - zarr_info - INFO - ./pl/emi_quality.zarr zarray shape, chunks, dtype: (2500, 1834), (1000, 1000), float32\n2025-09-18 12:47:19 - pc2ras - INFO - computing graph setted. doing all the computing.\n2025-09-18 12:47:19 - pc2ras - INFO - computing finished.ed |  0.1s\n2025-09-18 12:47:19 - pc2ras - INFO - dask cluster closed.\n\n\n\nemi_zarr = zarr.open('./pl/emi_quality.zarr',mode='r')\nfig, ax = plt.subplots(1,1,figsize=(10,10))\npcm = ax.imshow(emi_zarr[:],interpolation='nearest',vmin=1.0,vmax=1.3,cmap=colorcet.cm.fire)\nax.set(title='EMI quality factor',xlabel='Range Index',ylabel='Azimuth Index')\nfig.colorbar(pcm)\nplt.show()\n\n\n\n\n\n\n\n\n\nsource\n\n\nds_temp_coh\n\n ds_temp_coh (coh:str, ph:str, t_coh:str=None, tnet:str=None,\n              chunks:int=None, cuda:bool=False, processes=None,\n              n_workers=None, threads_per_worker=None, rmm_pool_size=0.9,\n              **dask_cluster_arg)\n\nDS temporal coherence.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ncoh\nstr\n\ncoherence matrix\n\n\nph\nstr\n\nwrapped phase\n\n\nt_coh\nstr\nNone\noutput, temporal coherence\n\n\ntnet\nstr\nNone\ntemporal network\n\n\nchunks\nint\nNone\npoint cloud chunk size, same as coh by default\n\n\ncuda\nbool\nFalse\nif use cuda for processing, false by default\n\n\nprocesses\nNoneType\nNone\nuse process for dask worker over thread, the default is False for cpu, only applied if cuda==False\n\n\nn_workers\nNoneType\nNone\nnumber of dask worker, the default is 1 for cpu, number of GPU for cuda\n\n\nthreads_per_worker\nNoneType\nNone\nnumber of threads per dask worker, the default is 2 for cpu, only applied if cuda==False\n\n\nrmm_pool_size\nfloat\n0.9\nset the rmm pool size, only applied when cuda==True\n\n\ndask_cluster_arg\nVAR_KEYWORD\n\n\n\n\n\nThis function estimate the temporal coherence of DSs which is defined as (Ferretti et al. 2011):\n\nFerretti, Alessandro, Alfio Fumagalli, Fabrizio Novali, Claudio Prati, Fabio Rocca, and Alessio Rucci. 2011. “A New Algorithm for Processing Interferometric Data-Stacks: SqueeSAR.” IEEE Transactions on Geoscience and Remote Sensing 49 (9): 3460–70. https://doi.org/10.1109/TGRS.2011.2124465.\n\\[\\gamma = \\frac{1}{N^2-N} \\sum_{n=1}^{N} \\sum_{k \\neq n}^{N} e^{i\\phi_{nk}} e^{-i(\\theta_n-\\theta_k)}\\]\nWhere \\(\\phi_{nk}\\) is the phase of complex coherence matrix and \\(\\theta_{n}\\) is the phase after phase linking.\n\nds_can_coh = './co/ds_can_coh.zarr'\nds_can_ph = './pl/ds_can_ph.zarr'\nds_can_t_coh = './pl/ds_can_t_coh.zarr'\n\n\nds_temp_coh(ds_can_coh,ds_can_ph, ds_can_t_coh)\nif is_cuda_available():\n    ds_temp_coh(ds_can_coh,ds_can_ph, ds_can_t_coh,cuda=True)\n\n2025-09-18 12:47:20 - log_args - INFO - running function: ds_temp_coh\n2025-09-18 12:47:20 - log_args - INFO - fetching args:\n2025-09-18 12:47:20 - log_args - INFO - coh = './co/ds_can_coh.zarr'\n2025-09-18 12:47:20 - log_args - INFO - ph = './pl/ds_can_ph.zarr'\n2025-09-18 12:47:20 - log_args - INFO - t_coh = './pl/ds_can_t_coh.zarr'\n2025-09-18 12:47:20 - log_args - INFO - tnet = None\n2025-09-18 12:47:20 - log_args - INFO - chunks = None\n2025-09-18 12:47:20 - log_args - INFO - cuda = False\n2025-09-18 12:47:20 - log_args - INFO - processes = None\n2025-09-18 12:47:20 - log_args - INFO - n_workers = None\n2025-09-18 12:47:20 - log_args - INFO - threads_per_worker = None\n2025-09-18 12:47:20 - log_args - INFO - rmm_pool_size = 0.9\n2025-09-18 12:47:20 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 12:47:20 - log_args - INFO - fetching args done.\n2025-09-18 12:47:20 - zarr_info - INFO - ./co/ds_can_coh.zarr zarray shape, chunks, dtype: (732727, 136), (100000, 1), complex64\n2025-09-18 12:47:20 - zarr_info - INFO - ./pl/ds_can_ph.zarr zarray shape, chunks, dtype: (732727, 17), (100000, 1), complex64\n2025-09-18 12:47:20 - ds_temp_coh - INFO - starting dask local cluster.\n2025-09-18 12:47:20 - ds_temp_coh - INFO - dask local cluster started.\n2025-09-18 12:47:20 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.4:8787/status', workers=1, threads=2, memory=256.00 GiB)\n2025-09-18 12:47:20 - darr_info - INFO - coh dask array shape, chunksize, dtype: (732727, 136), (100000, 136), complex64\n2025-09-18 12:47:20 - darr_info - INFO - ph dask array shape, chunksize, dtype: (732727, 17), (100000, 17), complex64\n2025-09-18 12:47:20 - ds_temp_coh - INFO - Estimate temporal coherence for DS.\n2025-09-18 12:47:20 - ds_temp_coh - INFO - got temporal coherence t_coh.\n2025-09-18 12:47:20 - darr_info - INFO - t_coh dask array shape, chunksize, dtype: (732727,), (100000,), float32\n2025-09-18 12:47:20 - ds_temp_coh - INFO - saving t_coh.\n2025-09-18 12:47:20 - ds_temp_coh - INFO - computing graph setted. doing all the computing.\n2025-09-18 12:47:22 - ds_temp_coh - INFO - computing finished. 1.8s\n2025-09-18 12:47:22 - ds_temp_coh - INFO - dask cluster closed.\n2025-09-18 12:47:22 - log_args - INFO - running function: ds_temp_coh\n2025-09-18 12:47:22 - log_args - INFO - fetching args:\n2025-09-18 12:47:22 - log_args - INFO - coh = './co/ds_can_coh.zarr'\n2025-09-18 12:47:22 - log_args - INFO - ph = './pl/ds_can_ph.zarr'\n2025-09-18 12:47:22 - log_args - INFO - t_coh = './pl/ds_can_t_coh.zarr'\n2025-09-18 12:47:22 - log_args - INFO - tnet = None\n2025-09-18 12:47:22 - log_args - INFO - chunks = None\n2025-09-18 12:47:22 - log_args - INFO - cuda = True\n2025-09-18 12:47:22 - log_args - INFO - processes = None\n2025-09-18 12:47:22 - log_args - INFO - n_workers = None\n2025-09-18 12:47:22 - log_args - INFO - threads_per_worker = None\n2025-09-18 12:47:22 - log_args - INFO - rmm_pool_size = 0.9\n2025-09-18 12:47:22 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 12:47:22 - log_args - INFO - fetching args done.\n2025-09-18 12:47:22 - zarr_info - INFO - ./co/ds_can_coh.zarr zarray shape, chunks, dtype: (732727, 136), (100000, 1), complex64\n2025-09-18 12:47:22 - zarr_info - INFO - ./pl/ds_can_ph.zarr zarray shape, chunks, dtype: (732727, 17), (100000, 1), complex64\n2025-09-18 12:47:22 - ds_temp_coh - INFO - starting dask local cluster.\n2025-09-18 12:47:24 - ds_temp_coh - INFO - dask local cluster started.\n2025-09-18 12:47:24 - dask_cluster_info - INFO - dask cluster: LocalCUDACluster(dashboard_link='http://127.0.0.1:8787/status', workers=2, threads=2, memory=256.00 GiB)\n2025-09-18 12:47:24 - darr_info - INFO - coh dask array shape, chunksize, dtype: (732727, 136), (100000, 136), complex64\n2025-09-18 12:47:24 - darr_info - INFO - ph dask array shape, chunksize, dtype: (732727, 17), (100000, 17), complex64\n2025-09-18 12:47:24 - ds_temp_coh - INFO - Estimate temporal coherence for DS.\n2025-09-18 12:47:24 - ds_temp_coh - INFO - got temporal coherence t_coh.\n2025-09-18 12:47:24 - darr_info - INFO - t_coh dask array shape, chunksize, dtype: (732727,), (100000,), float32\n2025-09-18 12:47:24 - ds_temp_coh - INFO - saving t_coh.\n2025-09-18 12:47:24 - ds_temp_coh - INFO - computing graph setted. doing all the computing.\n[                                        ] | 0% Completed |  0.0s\n\n\n2025-09-18 12:47:24,822 - distributed.worker - WARNING - Setting CPU affinity for GPU failed. Please refer to the following link for troubleshooting information: https://docs.rapids.ai/api/dask-cuda/nightly/troubleshooting/#setting-cpu-affinity-failure\n2025-09-18 12:47:24,851 - distributed.worker - WARNING - Setting CPU affinity for GPU failed. Please refer to the following link for troubleshooting information: https://docs.rapids.ai/api/dask-cuda/nightly/troubleshooting/#setting-cpu-affinity-failure\n\n\n2025-09-18 12:47:26 - ds_temp_coh - INFO - computing finished. 1.7s\n2025-09-18 12:47:27 - ds_temp_coh - INFO - dask cluster closed.\n\n\n\nds_can_gix = './shp/ds_can_gix.zarr'\nt_coh = './pl/t_coh.zarr'\nrslc_zarr = zarr.open('./raw/rslc.zarr/',mode='r')\nmc.pc2ras(ds_can_gix, ds_can_t_coh,t_coh,rslc_zarr.shape[:2])\n\n2025-09-18 12:47:27 - log_args - INFO - running function: pc2ras\n2025-09-18 12:47:27 - log_args - INFO - fetching args:\n2025-09-18 12:47:27 - log_args - INFO - idx = './shp/ds_can_gix.zarr'\n2025-09-18 12:47:27 - log_args - INFO - pc = './pl/ds_can_t_coh.zarr'\n2025-09-18 12:47:27 - log_args - INFO - ras = './pl/t_coh.zarr'\n2025-09-18 12:47:27 - log_args - INFO - shape = (2500, 1834)\n2025-09-18 12:47:27 - log_args - INFO - chunks = (1000, 1000)\n2025-09-18 12:47:27 - log_args - INFO - processes = False\n2025-09-18 12:47:27 - log_args - INFO - n_workers = 1\n2025-09-18 12:47:27 - log_args - INFO - threads_per_worker = 1\n2025-09-18 12:47:27 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 12:47:27 - log_args - INFO - fetching args done.\n2025-09-18 12:47:27 - zarr_info - INFO - ./shp/ds_can_gix.zarr zarray shape, chunks, dtype: (732727, 2), (100000, 1), int32\n2025-09-18 12:47:27 - pc2ras - INFO - loading gix into memory.\n2025-09-18 12:47:27 - pc2ras - INFO - starting dask local cluster.\n2025-09-18 12:47:27 - pc2ras - INFO - dask local cluster started.\n2025-09-18 12:47:27 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.4:8787/status', workers=1, threads=1, memory=256.00 GiB)\n2025-09-18 12:47:27 - pc2ras - INFO - start to work on ./pl/ds_can_t_coh.zarr\n2025-09-18 12:47:27 - zarr_info - INFO - ./pl/ds_can_t_coh.zarr zarray shape, chunks, dtype: (732727,), (100000,), float32\n2025-09-18 12:47:27 - darr_info - INFO - pc dask array shape, chunksize, dtype: (732727,), (732727,), float32\n2025-09-18 12:47:27 - pc2ras - INFO - create ras dask array\n2025-09-18 12:47:27 - darr_info - INFO - ras dask array shape, chunksize, dtype: (2500, 1834), (2500, 1834), float32\n2025-09-18 12:47:27 - pc2ras - INFO - save ras to ./pl/t_coh.zarr\n2025-09-18 12:47:27 - zarr_info - INFO - ./pl/t_coh.zarr zarray shape, chunks, dtype: (2500, 1834), (1000, 1000), float32\n2025-09-18 12:47:27 - pc2ras - INFO - computing graph setted. doing all the computing.\n2025-09-18 12:47:27 - pc2ras - INFO - computing finished.ed |  0.1s\n2025-09-18 12:47:27 - pc2ras - INFO - dask cluster closed.\n\n\n\nt_coh_zarr = zarr.open(t_coh,mode='r')\nfig, ax = plt.subplots(1,1,figsize=(10,10))\npcm = ax.imshow(t_coh_zarr[:],interpolation='nearest')\nax.set(title='DS temporal coherence',xlabel='Range Index',ylabel='Azimuth Index')\nfig.colorbar(pcm)\nplt.show()\n\n\n\n\n\n\n\n\n\nsource\n\n\nemperical_co_emi_temp_coh_pc\n\n emperical_co_emi_temp_coh_pc (rslc:str, is_shp_dir:str, gix:str,\n                               ph_dir:str, emi_quality_dir:str,\n                               t_coh_dir:str, batch_size:int=1000,\n                               chunks:int=None, cuda:bool=False,\n                               processes=None, n_workers=None,\n                               threads_per_worker=None, rmm_pool_size=0.9,\n                               **dask_cluster_arg)\n\nestimating emperical coherence matrix, phase linking and estimating temporal coherence on point cloud data.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nrslc\nstr\n\ninput: rslc stack, shape (nlines, width, nimages)\n\n\nis_shp_dir\nstr\n\ninput: directory for bool array indicating the SHPs of pc\n\n\ngix\nstr\n\ninput: bool array indicating pc, shape (2, n_points)\n\n\nph_dir\nstr\n\noutput: directory that hold complex coherence matrix for pc\n\n\nemi_quality_dir\nstr\n\noutput: directory that hold emi quality\n\n\nt_coh_dir\nstr\n\noutput: directory that hold temporal coherence\n\n\nbatch_size\nint\n1000\ninput, batch size\n\n\nchunks\nint\nNone\nparallel processing azimuth/range chunk size, optional. Default: rslc.chunks[:2]\n\n\ncuda\nbool\nFalse\nif use cuda for processing, false by default\n\n\nprocesses\nNoneType\nNone\nuse process for dask worker over thread, the default is False for cpu, only applied if cuda==False\n\n\nn_workers\nNoneType\nNone\nnumber of dask worker, the default is 1 for cpu, number of GPU for cuda\n\n\nthreads_per_worker\nNoneType\nNone\nnumber of threads per dask worker, the default is 2 for cpu, only applied if cuda==False\n\n\nrmm_pool_size\nfloat\n0.9\nset the rmm pool size, only applied when cuda==True\n\n\ndask_cluster_arg\nVAR_KEYWORD\n\n\n\n\n\n\nrslc = './raw/rslc.zarr/'\nds_can_is_shp_dir = './co/ds_can_is_shp/'\nds_can_ph_dir = './pl/ds_can_ph'\nds_can_emi_quality_dir = './pl/ds_can_emi_quality'\nds_can_t_coh_dir = './pl/ds_can_t_coh'\n\n\nemperical_co_emi_temp_coh_pc(rslc,ds_can_is_shp_dir,ds_can_gix,ds_can_ph_dir,ds_can_emi_quality_dir,ds_can_t_coh_dir,chunks=(1000,1000))\n\n2025-09-18 12:48:07 - log_args - INFO - running function: emperical_co_emi_temp_coh_pc\n2025-09-18 12:48:07 - log_args - INFO - fetching args:\n2025-09-18 12:48:07 - log_args - INFO - rslc = './raw/rslc.zarr/'\n2025-09-18 12:48:07 - log_args - INFO - is_shp_dir = './co/ds_can_is_shp/'\n2025-09-18 12:48:07 - log_args - INFO - gix = './shp/ds_can_gix.zarr'\n2025-09-18 12:48:07 - log_args - INFO - ph_dir = './pl/ds_can_ph'\n2025-09-18 12:48:07 - log_args - INFO - emi_quality_dir = './pl/ds_can_emi_quality'\n2025-09-18 12:48:07 - log_args - INFO - t_coh_dir = './pl/ds_can_t_coh'\n2025-09-18 12:48:07 - log_args - INFO - batch_size = 1000\n2025-09-18 12:48:07 - log_args - INFO - chunks = (1000, 1000)\n2025-09-18 12:48:07 - log_args - INFO - cuda = False\n2025-09-18 12:48:07 - log_args - INFO - processes = None\n2025-09-18 12:48:07 - log_args - INFO - n_workers = None\n2025-09-18 12:48:07 - log_args - INFO - threads_per_worker = None\n2025-09-18 12:48:07 - log_args - INFO - rmm_pool_size = 0.9\n2025-09-18 12:48:07 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 12:48:07 - log_args - INFO - fetching args done.\n2025-09-18 12:48:07 - zarr_info - INFO - ./raw/rslc.zarr/ zarray shape, chunks, dtype: (2500, 1834, 17), (1000, 1000, 1), complex64\n2025-09-18 12:48:07 - emperical_co_emi_temp_coh_pc - INFO - azimuth window size and half azimuth window size: 11, 5\n2025-09-18 12:48:07 - emperical_co_emi_temp_coh_pc - INFO - range window size and half range window size: 11, 5\n2025-09-18 12:48:07 - emperical_co_emi_temp_coh_pc - INFO - parallel processing azimuth chunk size: 1000\n2025-09-18 12:48:07 - emperical_co_emi_temp_coh_pc - INFO - parallel processing range chunk size: 1000\n2025-09-18 12:48:07 - zarr_info - INFO - ./shp/ds_can_gix.zarr zarray shape, chunks, dtype: (732727, 2), (100000, 1), int32\n2025-09-18 12:48:07 - emperical_co_emi_temp_coh_pc - INFO - loading gix into memory.\n2025-09-18 12:48:07 - emperical_co_emi_temp_coh_pc - INFO - convert gix to the order of ras chunk\n2025-09-18 12:48:14 - emperical_co_emi_temp_coh_pc - INFO - starting dask cluster.\n2025-09-18 12:48:14 - emperical_co_emi_temp_coh_pc - INFO - dask cluster started.\n2025-09-18 12:48:14 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.4:8787/status', workers=1, threads=2, memory=256.00 GiB)\n2025-09-18 12:48:14 - darr_info - INFO - rslc_overlap dask array shape, chunksize, dtype: (2520, 1844, 17), (1010, 1005, 17), complex64\n2025-09-18 12:48:14 - darr_info - INFO - gix in ras chunk order dask array shape, chunksize, dtype: (732727, 2), (201403, 2), int32\n2025-09-18 12:48:14 - emperical_co_emi_temp_coh_pc - INFO - estimating coherence matrix chunk by chunk.\n2025-09-18 12:48:14 - darr_info - INFO - is_shp for chunk 0 dask array shape, chunksize, dtype: (201097, 11, 11), (201097, 11, 11), bool\n2025-09-18 12:48:14 - darr_info - INFO - ph for chunk 0 dask array shape, chunksize, dtype: (201097, 17), (201097, 17), complex64\n2025-09-18 12:48:14 - darr_info - INFO - emi_quality for chunk 0 dask array shape, chunksize, dtype: (201097,), (201097,), float32\n2025-09-18 12:48:14 - darr_info - INFO - t_coh for chunk 0 dask array shape, chunksize, dtype: (201097,), (201097,), float32\n2025-09-18 12:48:14 - emperical_co_emi_temp_coh_pc - INFO - saving ph, emi_quality, t_coh for chunk 0\n2025-09-18 12:48:14 - zarr_info - INFO - pl/ds_can_ph/0.zarr zarray shape, chunks, dtype: (201097, 17), (201097, 1), complex64\n2025-09-18 12:48:14 - zarr_info - INFO - pl/ds_can_emi_quality/0.zarr zarray shape, chunks, dtype: (201097,), (201097,), float32\n2025-09-18 12:48:14 - zarr_info - INFO - pl/ds_can_t_coh/0.zarr zarray shape, chunks, dtype: (201097,), (201097,), float32\n2025-09-18 12:48:14 - darr_info - INFO - is_shp for chunk 1 dask array shape, chunksize, dtype: (137562, 11, 11), (137562, 11, 11), bool\n2025-09-18 12:48:14 - darr_info - INFO - ph for chunk 1 dask array shape, chunksize, dtype: (137562, 17), (137562, 17), complex64\n2025-09-18 12:48:14 - darr_info - INFO - emi_quality for chunk 1 dask array shape, chunksize, dtype: (137562,), (137562,), float32\n2025-09-18 12:48:14 - darr_info - INFO - t_coh for chunk 1 dask array shape, chunksize, dtype: (137562,), (137562,), float32\n2025-09-18 12:48:14 - emperical_co_emi_temp_coh_pc - INFO - saving ph, emi_quality, t_coh for chunk 1\n2025-09-18 12:48:14 - zarr_info - INFO - pl/ds_can_ph/1.zarr zarray shape, chunks, dtype: (137562, 17), (137562, 1), complex64\n2025-09-18 12:48:14 - zarr_info - INFO - pl/ds_can_emi_quality/1.zarr zarray shape, chunks, dtype: (137562,), (137562,), float32\n2025-09-18 12:48:14 - zarr_info - INFO - pl/ds_can_t_coh/1.zarr zarray shape, chunks, dtype: (137562,), (137562,), float32\n2025-09-18 12:48:14 - darr_info - INFO - is_shp for chunk 2 dask array shape, chunksize, dtype: (201403, 11, 11), (201403, 11, 11), bool\n2025-09-18 12:48:14 - darr_info - INFO - ph for chunk 2 dask array shape, chunksize, dtype: (201403, 17), (201403, 17), complex64\n2025-09-18 12:48:14 - darr_info - INFO - emi_quality for chunk 2 dask array shape, chunksize, dtype: (201403,), (201403,), float32\n2025-09-18 12:48:14 - darr_info - INFO - t_coh for chunk 2 dask array shape, chunksize, dtype: (201403,), (201403,), float32\n2025-09-18 12:48:14 - emperical_co_emi_temp_coh_pc - INFO - saving ph, emi_quality, t_coh for chunk 2\n2025-09-18 12:48:14 - zarr_info - INFO - pl/ds_can_ph/2.zarr zarray shape, chunks, dtype: (201403, 17), (201403, 1), complex64\n2025-09-18 12:48:14 - zarr_info - INFO - pl/ds_can_emi_quality/2.zarr zarray shape, chunks, dtype: (201403,), (201403,), float32\n2025-09-18 12:48:14 - zarr_info - INFO - pl/ds_can_t_coh/2.zarr zarray shape, chunks, dtype: (201403,), (201403,), float32\n2025-09-18 12:48:14 - darr_info - INFO - is_shp for chunk 3 dask array shape, chunksize, dtype: (73518, 11, 11), (73518, 11, 11), bool\n2025-09-18 12:48:14 - darr_info - INFO - ph for chunk 3 dask array shape, chunksize, dtype: (73518, 17), (73518, 17), complex64\n2025-09-18 12:48:14 - darr_info - INFO - emi_quality for chunk 3 dask array shape, chunksize, dtype: (73518,), (73518,), float32\n2025-09-18 12:48:14 - darr_info - INFO - t_coh for chunk 3 dask array shape, chunksize, dtype: (73518,), (73518,), float32\n2025-09-18 12:48:14 - emperical_co_emi_temp_coh_pc - INFO - saving ph, emi_quality, t_coh for chunk 3\n2025-09-18 12:48:14 - zarr_info - INFO - pl/ds_can_ph/3.zarr zarray shape, chunks, dtype: (73518, 17), (73518, 1), complex64\n2025-09-18 12:48:14 - zarr_info - INFO - pl/ds_can_emi_quality/3.zarr zarray shape, chunks, dtype: (73518,), (73518,), float32\n2025-09-18 12:48:14 - zarr_info - INFO - pl/ds_can_t_coh/3.zarr zarray shape, chunks, dtype: (73518,), (73518,), float32\n2025-09-18 12:48:14 - darr_info - INFO - is_shp for chunk 4 dask array shape, chunksize, dtype: (78445, 11, 11), (78445, 11, 11), bool\n2025-09-18 12:48:14 - darr_info - INFO - ph for chunk 4 dask array shape, chunksize, dtype: (78445, 17), (78445, 17), complex64\n2025-09-18 12:48:14 - darr_info - INFO - emi_quality for chunk 4 dask array shape, chunksize, dtype: (78445,), (78445,), float32\n2025-09-18 12:48:14 - darr_info - INFO - t_coh for chunk 4 dask array shape, chunksize, dtype: (78445,), (78445,), float32\n2025-09-18 12:48:14 - emperical_co_emi_temp_coh_pc - INFO - saving ph, emi_quality, t_coh for chunk 4\n2025-09-18 12:48:14 - zarr_info - INFO - pl/ds_can_ph/4.zarr zarray shape, chunks, dtype: (78445, 17), (78445, 1), complex64\n2025-09-18 12:48:14 - zarr_info - INFO - pl/ds_can_emi_quality/4.zarr zarray shape, chunks, dtype: (78445,), (78445,), float32\n2025-09-18 12:48:14 - zarr_info - INFO - pl/ds_can_t_coh/4.zarr zarray shape, chunks, dtype: (78445,), (78445,), float32\n2025-09-18 12:48:14 - darr_info - INFO - is_shp for chunk 5 dask array shape, chunksize, dtype: (40702, 11, 11), (40702, 11, 11), bool\n2025-09-18 12:48:14 - darr_info - INFO - ph for chunk 5 dask array shape, chunksize, dtype: (40702, 17), (40702, 17), complex64\n2025-09-18 12:48:14 - darr_info - INFO - emi_quality for chunk 5 dask array shape, chunksize, dtype: (40702,), (40702,), float32\n2025-09-18 12:48:14 - darr_info - INFO - t_coh for chunk 5 dask array shape, chunksize, dtype: (40702,), (40702,), float32\n2025-09-18 12:48:14 - emperical_co_emi_temp_coh_pc - INFO - saving ph, emi_quality, t_coh for chunk 5\n2025-09-18 12:48:14 - zarr_info - INFO - pl/ds_can_ph/5.zarr zarray shape, chunks, dtype: (40702, 17), (40702, 1), complex64\n2025-09-18 12:48:14 - zarr_info - INFO - pl/ds_can_emi_quality/5.zarr zarray shape, chunks, dtype: (40702,), (40702,), float32\n2025-09-18 12:48:14 - zarr_info - INFO - pl/ds_can_t_coh/5.zarr zarray shape, chunks, dtype: (40702,), (40702,), float32\n2025-09-18 12:48:14 - emperical_co_emi_temp_coh_pc - INFO - computing graph setted. doing all the computing.\n2025-09-18 12:48:24 - emperical_co_emi_temp_coh_pc - INFO - computing finished.\n2025-09-18 12:48:24 - emperical_co_emi_temp_coh_pc - INFO - dask cluster closed.\nCPU times: user 3min 30s, sys: 30 s, total: 4min\nWall time: 16.6 s\n\n\n\nif is_cuda_available():\n    emperical_co_emi_temp_coh_pc(rslc,ds_can_is_shp_dir,ds_can_gix,ds_can_ph_dir,ds_can_emi_quality_dir,ds_can_t_coh_dir,chunks=(1000,1000),cuda=True)\n\n2025-09-18 12:48:24 - log_args - INFO - running function: emperical_co_emi_temp_coh_pc\n2025-09-18 12:48:24 - log_args - INFO - fetching args:\n2025-09-18 12:48:24 - log_args - INFO - rslc = './raw/rslc.zarr/'\n2025-09-18 12:48:24 - log_args - INFO - is_shp_dir = './co/ds_can_is_shp/'\n2025-09-18 12:48:24 - log_args - INFO - gix = './shp/ds_can_gix.zarr'\n2025-09-18 12:48:24 - log_args - INFO - ph_dir = './pl/ds_can_ph'\n2025-09-18 12:48:24 - log_args - INFO - emi_quality_dir = './pl/ds_can_emi_quality'\n2025-09-18 12:48:24 - log_args - INFO - t_coh_dir = './pl/ds_can_t_coh'\n2025-09-18 12:48:24 - log_args - INFO - batch_size = 1000\n2025-09-18 12:48:24 - log_args - INFO - chunks = (1000, 1000)\n2025-09-18 12:48:24 - log_args - INFO - cuda = True\n2025-09-18 12:48:24 - log_args - INFO - processes = None\n2025-09-18 12:48:24 - log_args - INFO - n_workers = None\n2025-09-18 12:48:24 - log_args - INFO - threads_per_worker = None\n2025-09-18 12:48:24 - log_args - INFO - rmm_pool_size = 0.9\n2025-09-18 12:48:24 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 12:48:24 - log_args - INFO - fetching args done.\n2025-09-18 12:48:24 - zarr_info - INFO - ./raw/rslc.zarr/ zarray shape, chunks, dtype: (2500, 1834, 17), (1000, 1000, 1), complex64\n2025-09-18 12:48:24 - emperical_co_emi_temp_coh_pc - INFO - azimuth window size and half azimuth window size: 11, 5\n2025-09-18 12:48:24 - emperical_co_emi_temp_coh_pc - INFO - range window size and half range window size: 11, 5\n2025-09-18 12:48:24 - emperical_co_emi_temp_coh_pc - INFO - parallel processing azimuth chunk size: 1000\n2025-09-18 12:48:24 - emperical_co_emi_temp_coh_pc - INFO - parallel processing range chunk size: 1000\n2025-09-18 12:48:24 - zarr_info - INFO - ./shp/ds_can_gix.zarr zarray shape, chunks, dtype: (732727, 2), (100000, 1), int32\n2025-09-18 12:48:24 - emperical_co_emi_temp_coh_pc - INFO - loading gix into memory.\n2025-09-18 12:48:24 - emperical_co_emi_temp_coh_pc - INFO - convert gix to the order of ras chunk\n2025-09-18 12:48:24 - emperical_co_emi_temp_coh_pc - INFO - starting dask cluster.\n\n\n2025-09-18 12:48:26,875 - distributed.worker - WARNING - Setting CPU affinity for GPU failed. Please refer to the following link for troubleshooting information: https://docs.rapids.ai/api/dask-cuda/nightly/troubleshooting/#setting-cpu-affinity-failure\n2025-09-18 12:48:26,875 - distributed.worker - WARNING - Setting CPU affinity for GPU failed. Please refer to the following link for troubleshooting information: https://docs.rapids.ai/api/dask-cuda/nightly/troubleshooting/#setting-cpu-affinity-failure\n\n\n2025-09-18 12:48:27 - emperical_co_emi_temp_coh_pc - INFO - dask cluster started.\n2025-09-18 12:48:27 - dask_cluster_info - INFO - dask cluster: LocalCUDACluster(dashboard_link='http://127.0.0.1:8787/status', workers=2, threads=2, memory=256.00 GiB)\n2025-09-18 12:48:27 - darr_info - INFO - rslc_overlap dask array shape, chunksize, dtype: (2520, 1844, 17), (1010, 1005, 17), complex64\n2025-09-18 12:48:27 - darr_info - INFO - gix in ras chunk order dask array shape, chunksize, dtype: (732727, 2), (201403, 2), int32\n2025-09-18 12:48:27 - emperical_co_emi_temp_coh_pc - INFO - estimating coherence matrix chunk by chunk.\n2025-09-18 12:48:27 - darr_info - INFO - is_shp for chunk 0 dask array shape, chunksize, dtype: (201097, 11, 11), (201097, 11, 11), bool\n2025-09-18 12:48:27 - darr_info - INFO - ph for chunk 0 dask array shape, chunksize, dtype: (201097, 17), (201097, 17), complex64\n2025-09-18 12:48:27 - darr_info - INFO - emi_quality for chunk 0 dask array shape, chunksize, dtype: (201097,), (201097,), float32\n2025-09-18 12:48:27 - darr_info - INFO - t_coh for chunk 0 dask array shape, chunksize, dtype: (201097,), (201097,), float32\n2025-09-18 12:48:27 - emperical_co_emi_temp_coh_pc - INFO - saving ph, emi_quality, t_coh for chunk 0\n2025-09-18 12:48:27 - zarr_info - INFO - pl/ds_can_ph/0.zarr zarray shape, chunks, dtype: (201097, 17), (201097, 1), complex64\n2025-09-18 12:48:27 - zarr_info - INFO - pl/ds_can_emi_quality/0.zarr zarray shape, chunks, dtype: (201097,), (201097,), float32\n2025-09-18 12:48:27 - zarr_info - INFO - pl/ds_can_t_coh/0.zarr zarray shape, chunks, dtype: (201097,), (201097,), float32\n2025-09-18 12:48:27 - darr_info - INFO - is_shp for chunk 1 dask array shape, chunksize, dtype: (137562, 11, 11), (137562, 11, 11), bool\n2025-09-18 12:48:27 - darr_info - INFO - ph for chunk 1 dask array shape, chunksize, dtype: (137562, 17), (137562, 17), complex64\n2025-09-18 12:48:27 - darr_info - INFO - emi_quality for chunk 1 dask array shape, chunksize, dtype: (137562,), (137562,), float32\n2025-09-18 12:48:27 - darr_info - INFO - t_coh for chunk 1 dask array shape, chunksize, dtype: (137562,), (137562,), float32\n2025-09-18 12:48:27 - emperical_co_emi_temp_coh_pc - INFO - saving ph, emi_quality, t_coh for chunk 1\n2025-09-18 12:48:27 - zarr_info - INFO - pl/ds_can_ph/1.zarr zarray shape, chunks, dtype: (137562, 17), (137562, 1), complex64\n2025-09-18 12:48:27 - zarr_info - INFO - pl/ds_can_emi_quality/1.zarr zarray shape, chunks, dtype: (137562,), (137562,), float32\n2025-09-18 12:48:27 - zarr_info - INFO - pl/ds_can_t_coh/1.zarr zarray shape, chunks, dtype: (137562,), (137562,), float32\n2025-09-18 12:48:27 - darr_info - INFO - is_shp for chunk 2 dask array shape, chunksize, dtype: (201403, 11, 11), (201403, 11, 11), bool\n2025-09-18 12:48:27 - darr_info - INFO - ph for chunk 2 dask array shape, chunksize, dtype: (201403, 17), (201403, 17), complex64\n2025-09-18 12:48:27 - darr_info - INFO - emi_quality for chunk 2 dask array shape, chunksize, dtype: (201403,), (201403,), float32\n2025-09-18 12:48:27 - darr_info - INFO - t_coh for chunk 2 dask array shape, chunksize, dtype: (201403,), (201403,), float32\n2025-09-18 12:48:27 - emperical_co_emi_temp_coh_pc - INFO - saving ph, emi_quality, t_coh for chunk 2\n2025-09-18 12:48:27 - zarr_info - INFO - pl/ds_can_ph/2.zarr zarray shape, chunks, dtype: (201403, 17), (201403, 1), complex64\n2025-09-18 12:48:27 - zarr_info - INFO - pl/ds_can_emi_quality/2.zarr zarray shape, chunks, dtype: (201403,), (201403,), float32\n2025-09-18 12:48:27 - zarr_info - INFO - pl/ds_can_t_coh/2.zarr zarray shape, chunks, dtype: (201403,), (201403,), float32\n2025-09-18 12:48:27 - darr_info - INFO - is_shp for chunk 3 dask array shape, chunksize, dtype: (73518, 11, 11), (73518, 11, 11), bool\n2025-09-18 12:48:27 - darr_info - INFO - ph for chunk 3 dask array shape, chunksize, dtype: (73518, 17), (73518, 17), complex64\n2025-09-18 12:48:27 - darr_info - INFO - emi_quality for chunk 3 dask array shape, chunksize, dtype: (73518,), (73518,), float32\n2025-09-18 12:48:27 - darr_info - INFO - t_coh for chunk 3 dask array shape, chunksize, dtype: (73518,), (73518,), float32\n2025-09-18 12:48:27 - emperical_co_emi_temp_coh_pc - INFO - saving ph, emi_quality, t_coh for chunk 3\n2025-09-18 12:48:27 - zarr_info - INFO - pl/ds_can_ph/3.zarr zarray shape, chunks, dtype: (73518, 17), (73518, 1), complex64\n2025-09-18 12:48:27 - zarr_info - INFO - pl/ds_can_emi_quality/3.zarr zarray shape, chunks, dtype: (73518,), (73518,), float32\n2025-09-18 12:48:27 - zarr_info - INFO - pl/ds_can_t_coh/3.zarr zarray shape, chunks, dtype: (73518,), (73518,), float32\n2025-09-18 12:48:27 - darr_info - INFO - is_shp for chunk 4 dask array shape, chunksize, dtype: (78445, 11, 11), (78445, 11, 11), bool\n2025-09-18 12:48:27 - darr_info - INFO - ph for chunk 4 dask array shape, chunksize, dtype: (78445, 17), (78445, 17), complex64\n2025-09-18 12:48:27 - darr_info - INFO - emi_quality for chunk 4 dask array shape, chunksize, dtype: (78445,), (78445,), float32\n2025-09-18 12:48:27 - darr_info - INFO - t_coh for chunk 4 dask array shape, chunksize, dtype: (78445,), (78445,), float32\n2025-09-18 12:48:27 - emperical_co_emi_temp_coh_pc - INFO - saving ph, emi_quality, t_coh for chunk 4\n2025-09-18 12:48:27 - zarr_info - INFO - pl/ds_can_ph/4.zarr zarray shape, chunks, dtype: (78445, 17), (78445, 1), complex64\n2025-09-18 12:48:27 - zarr_info - INFO - pl/ds_can_emi_quality/4.zarr zarray shape, chunks, dtype: (78445,), (78445,), float32\n2025-09-18 12:48:27 - zarr_info - INFO - pl/ds_can_t_coh/4.zarr zarray shape, chunks, dtype: (78445,), (78445,), float32\n2025-09-18 12:48:27 - darr_info - INFO - is_shp for chunk 5 dask array shape, chunksize, dtype: (40702, 11, 11), (40702, 11, 11), bool\n2025-09-18 12:48:27 - darr_info - INFO - ph for chunk 5 dask array shape, chunksize, dtype: (40702, 17), (40702, 17), complex64\n2025-09-18 12:48:27 - darr_info - INFO - emi_quality for chunk 5 dask array shape, chunksize, dtype: (40702,), (40702,), float32\n2025-09-18 12:48:27 - darr_info - INFO - t_coh for chunk 5 dask array shape, chunksize, dtype: (40702,), (40702,), float32\n2025-09-18 12:48:27 - emperical_co_emi_temp_coh_pc - INFO - saving ph, emi_quality, t_coh for chunk 5\n2025-09-18 12:48:27 - zarr_info - INFO - pl/ds_can_ph/5.zarr zarray shape, chunks, dtype: (40702, 17), (40702, 1), complex64\n2025-09-18 12:48:27 - zarr_info - INFO - pl/ds_can_emi_quality/5.zarr zarray shape, chunks, dtype: (40702,), (40702,), float32\n2025-09-18 12:48:27 - zarr_info - INFO - pl/ds_can_t_coh/5.zarr zarray shape, chunks, dtype: (40702,), (40702,), float32\n2025-09-18 12:48:27 - emperical_co_emi_temp_coh_pc - INFO - computing graph setted. doing all the computing.\n2025-09-18 12:48:38 - emperical_co_emi_temp_coh_pc - INFO - computing finished.\n2025-09-18 12:48:39 - emperical_co_emi_temp_coh_pc - INFO - dask cluster closed.\n\n\nThen concat the result:\n\nds_can_ph_ = './pl/ds_can_ph_.zarr'\nds_can_emi_quality_ = './pl/ds_can_emi_quality_.zarr'\nds_can_t_coh_ = './pl/ds_can_t_coh_.zarr'\nds_can_key = './co/ds_can_key.zarr'\n\n\nchunks = zarr.open(ds_can_gix,mode='r').chunks[0]\nmc.pc_concat(\n    [ds_can_ph_dir,ds_can_emi_quality_dir,ds_can_t_coh_dir],\n    [ds_can_ph_,ds_can_emi_quality_,ds_can_t_coh_],\n    key=ds_can_key,\n    chunks=chunks)\n\n2025-09-18 12:48:39 - log_args - INFO - running function: pc_concat\n2025-09-18 12:48:39 - log_args - INFO - fetching args:\n2025-09-18 12:48:39 - log_args - INFO - pcs = ['./pl/ds_can_ph', './pl/ds_can_emi_quality', './pl/ds_can_t_coh']\n2025-09-18 12:48:39 - log_args - INFO - pc = ['./pl/ds_can_ph_.zarr', './pl/ds_can_emi_quality_.zarr', './pl/ds_can_t_coh_.zarr']\n2025-09-18 12:48:39 - log_args - INFO - key = './co/ds_can_key.zarr'\n2025-09-18 12:48:39 - log_args - INFO - chunks = 100000\n2025-09-18 12:48:39 - log_args - INFO - processes = False\n2025-09-18 12:48:39 - log_args - INFO - n_workers = 1\n2025-09-18 12:48:39 - log_args - INFO - threads_per_worker = 1\n2025-09-18 12:48:39 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 12:48:39 - log_args - INFO - fetching args done.\n2025-09-18 12:48:39 - pc_concat - INFO - input pcs: [[Path('pl/ds_can_ph/0.zarr'), Path('pl/ds_can_ph/1.zarr'), Path('pl/ds_can_ph/2.zarr'), Path('pl/ds_can_ph/3.zarr'), Path('pl/ds_can_ph/4.zarr'), Path('pl/ds_can_ph/5.zarr')], [Path('pl/ds_can_emi_quality/0.zarr'), Path('pl/ds_can_emi_quality/1.zarr'), Path('pl/ds_can_emi_quality/2.zarr'), Path('pl/ds_can_emi_quality/3.zarr'), Path('pl/ds_can_emi_quality/4.zarr'), Path('pl/ds_can_emi_quality/5.zarr')], [Path('pl/ds_can_t_coh/0.zarr'), Path('pl/ds_can_t_coh/1.zarr'), Path('pl/ds_can_t_coh/2.zarr'), Path('pl/ds_can_t_coh/3.zarr'), Path('pl/ds_can_t_coh/4.zarr'), Path('pl/ds_can_t_coh/5.zarr')]]\n2025-09-18 12:48:39 - pc_concat - INFO - output pc: ['./pl/ds_can_ph_.zarr', './pl/ds_can_emi_quality_.zarr', './pl/ds_can_t_coh_.zarr']\n2025-09-18 12:48:39 - pc_concat - INFO - load key\n2025-09-18 12:48:39 - zarr_info - INFO - ./co/ds_can_key.zarr zarray shape, chunks, dtype: (732727,), (100000,), int64\n2025-09-18 12:48:39 - pc_concat - INFO - starting dask local cluster.\n2025-09-18 12:48:39 - pc_concat - INFO - dask local cluster started.\n2025-09-18 12:48:39 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.4:8787/status', workers=1, threads=1, memory=256.00 GiB)\n2025-09-18 12:48:39 - pc_concat - INFO - read pc from [Path('pl/ds_can_ph/0.zarr'), Path('pl/ds_can_ph/1.zarr'), Path('pl/ds_can_ph/2.zarr'), Path('pl/ds_can_ph/3.zarr'), Path('pl/ds_can_ph/4.zarr'), Path('pl/ds_can_ph/5.zarr')]\n2025-09-18 12:48:39 - darr_info - INFO - concatenated pc dask array shape, chunksize, dtype: (732727, 17), (732727, 1), complex64\n2025-09-18 12:48:39 - pc_concat - INFO - sort pc according to key\n2025-09-18 12:48:39 - darr_info - INFO - sorted pc dask array shape, chunksize, dtype: (732727, 17), (732727, 1), complex64\n2025-09-18 12:48:39 - pc_concat - INFO - save pc to ./pl/ds_can_ph_.zarr\n2025-09-18 12:48:39 - zarr_info - INFO - ./pl/ds_can_ph_.zarr zarray shape, chunks, dtype: (732727, 17), (100000, 1), complex64\n2025-09-18 12:48:39 - pc_concat - INFO - read pc from [Path('pl/ds_can_emi_quality/0.zarr'), Path('pl/ds_can_emi_quality/1.zarr'), Path('pl/ds_can_emi_quality/2.zarr'), Path('pl/ds_can_emi_quality/3.zarr'), Path('pl/ds_can_emi_quality/4.zarr'), Path('pl/ds_can_emi_quality/5.zarr')]\n2025-09-18 12:48:39 - darr_info - INFO - concatenated pc dask array shape, chunksize, dtype: (732727,), (732727,), float32\n2025-09-18 12:48:39 - pc_concat - INFO - sort pc according to key\n2025-09-18 12:48:39 - darr_info - INFO - sorted pc dask array shape, chunksize, dtype: (732727,), (732727,), float32\n2025-09-18 12:48:39 - pc_concat - INFO - save pc to ./pl/ds_can_emi_quality_.zarr\n2025-09-18 12:48:39 - zarr_info - INFO - ./pl/ds_can_emi_quality_.zarr zarray shape, chunks, dtype: (732727,), (100000,), float32\n2025-09-18 12:48:39 - pc_concat - INFO - read pc from [Path('pl/ds_can_t_coh/0.zarr'), Path('pl/ds_can_t_coh/1.zarr'), Path('pl/ds_can_t_coh/2.zarr'), Path('pl/ds_can_t_coh/3.zarr'), Path('pl/ds_can_t_coh/4.zarr'), Path('pl/ds_can_t_coh/5.zarr')]\n2025-09-18 12:48:39 - darr_info - INFO - concatenated pc dask array shape, chunksize, dtype: (732727,), (732727,), float32\n2025-09-18 12:48:39 - pc_concat - INFO - sort pc according to key\n2025-09-18 12:48:39 - darr_info - INFO - sorted pc dask array shape, chunksize, dtype: (732727,), (732727,), float32\n2025-09-18 12:48:39 - pc_concat - INFO - save pc to ./pl/ds_can_t_coh_.zarr\n2025-09-18 12:48:39 - zarr_info - INFO - ./pl/ds_can_t_coh_.zarr zarray shape, chunks, dtype: (732727,), (100000,), float32\n2025-09-18 12:48:39 - pc_concat - INFO - computing graph setted. doing all the computing.\n2025-09-18 12:48:40 - pc_concat - INFO - computing finished.|  0.7s\n2025-09-18 12:48:40 - pc_concat - INFO - dask cluster closed.",
    "crumbs": [
      "CLI",
      "pl"
    ]
  },
  {
    "objectID": "CLI/transform.html",
    "href": "CLI/transform.html",
    "title": "transform",
    "section": "",
    "text": "import numpy as np\nfrom matplotlib import pyplot as plt\nimport moraine.cli as mc\n\n\nsource\n\ntransform\n\n transform (xx_in, yy_in, xx_out, yy_out, epsg_in=4326, epsg_out=3857)\n\nCoordinate transformation. By default, the input should be longitude (xx_in) and latitude (yy_in) (in degree) and outputs are x (east) and y (south) coordinate in web mercator projection (for plot with google earth map). The chunks, shape and dtype of output are same as xx_in.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nxx_in\n\n\ninput x coordinate\n\n\nyy_in\n\n\ninput y coordinate\n\n\nxx_out\n\n\noutput x coordinate\n\n\nyy_out\n\n\noutput y coordinate\n\n\nepsg_in\nint\n4326\ninput epsg\n\n\nepsg_out\nint\n3857\noutput epsg\n\n\n\ntransform do not have the API version since it can be easily achieved with pyproj.\nUsage:\n\nlon_ = './raw/lon.zarr/'; lat_ = './raw/lat.zarr/'\ne_ = './transform/e.zarr'; n_ = './transform/n.zarr'\n\n\nlogger = mc.get_logger()\n\n\ntransform(lon_,lat_,e_,n_)\n\n2025-09-18 12:17:27 - log_args - INFO - running function: transform\n2025-09-18 12:17:27 - log_args - INFO - fetching args:\n2025-09-18 12:17:27 - log_args - INFO - xx_in = './raw/lon.zarr/'\n2025-09-18 12:17:27 - log_args - INFO - yy_in = './raw/lat.zarr/'\n2025-09-18 12:17:27 - log_args - INFO - xx_out = './transform/e.zarr'\n2025-09-18 12:17:27 - log_args - INFO - yy_out = './transform/n.zarr'\n2025-09-18 12:17:27 - log_args - INFO - epsg_in = 4326\n2025-09-18 12:17:27 - log_args - INFO - epsg_out = 3857\n2025-09-18 12:17:27 - log_args - INFO - fetching args done.\n2025-09-18 12:17:27 - transform - INFO - input EPSG: 4326.\n2025-09-18 12:17:27 - zarr_info - INFO - xx_in zarray shape, chunks, dtype: (2500, 1834), (1000, 1000), float64\n2025-09-18 12:17:27 - zarr_info - INFO - yy_in zarray shape, chunks, dtype: (2500, 1834), (1000, 1000), float64\n2025-09-18 12:17:27 - transform - INFO - output EPSG: 3857.\n2025-09-18 12:17:27 - transform - INFO - do the transformation.\n2025-09-18 12:17:29 - transform - INFO - write output.\n2025-09-18 12:17:29 - transform - INFO - write done.\n\n\n\nlon = zarr.open(lon_,mode='r')[:]\nlat = zarr.open(lat_,mode='r')[:]\n\n\nfig,axes = plt.subplots(1,2,figsize=(11,5))\nim0 = axes[0].imshow(lon)\naxes[0].set_title('Longitude')\nfig.colorbar(im0, ax=axes[0])\nim1 = axes[1].imshow(lat)\naxes[1].set_title('Latitude')\nfig.colorbar(im1, ax=axes[1])\nfig.show()\n\n\n\n\n\n\n\n\n\ne = zarr.open(e_,mode='r')[:]\nn = zarr.open(n_,mode='r')[:]\n\n\nfig,axes = plt.subplots(1,2,figsize=(11,5))\nim0 = axes[0].imshow(e)\naxes[0].set_title('E')\nfig.colorbar(im0, ax=axes[0])\nim1 = axes[1].imshow(n)\naxes[1].set_title('N')\nfig.colorbar(im1, ax=axes[1])\nfig.show()",
    "crumbs": [
      "CLI",
      "transform"
    ]
  },
  {
    "objectID": "CLI/logging.html",
    "href": "CLI/logging.html",
    "title": "logging",
    "section": "",
    "text": "source\n\nget_logger\n\n get_logger (logfile:str=None)\n\nget logger for decorrelation cli application\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nlogfile\nstr\nNone\nlogfile, optional. default: no logfile\n\n\n\nIf no input logfile, the log information will be only printed on the screen. If provided logfile, the log information will be printed on the screen and saved to the file.\nUsage:\n\nlogger = get_logger() # or\nlogger = get_logger('process.log')",
    "crumbs": [
      "CLI",
      "logging"
    ]
  },
  {
    "objectID": "CLI/pqm.html",
    "href": "CLI/pqm.html",
    "title": "pqm",
    "section": "",
    "text": "import numpy as np\nimport zarr\nimport moraine.cli as mc\nfrom moraine.utils_ import is_cuda_available\nif is_cuda_available():\n    import cupy as cp\nfrom matplotlib import pyplot as plt\n\n\nsource\n\ntemp_coh\n\n temp_coh (intf:str, rslc:str, t_coh:str=None,\n           image_pairs:numpy.ndarray=None, chunks:int|tuple[int,int]=None,\n           cuda:bool=False, processes=None, n_workers=None,\n           threads_per_worker=None, rmm_pool_size=0.9, **dask_cluster_arg)\n\ntemporal coherence.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nintf\nstr\n\ncomplex interferograms/coherence metrix, dtype complex64, shape 2D(pc) or 3D(ras)\n\n\nrslc\nstr\n\ncomplex rslc/phase history, dtype complex64, shape 2D(pc) or 3D(ras)\n\n\nt_coh\nstr\nNone\noutput, temporal coherence\n\n\nimage_pairs\nndarray\nNone\nimage pairs\n\n\nchunks\nint | tuple[int, int]\nNone\nras/pc chunk size, same as intf by default\n\n\ncuda\nbool\nFalse\nif use cuda for processing, false by default\n\n\nprocesses\nNoneType\nNone\nuse process for dask worker over thread, the default is False for cpu, only applied if cuda==False\n\n\nn_workers\nNoneType\nNone\nnumber of dask worker, the default is 1 for cpu, number of GPU for cuda\n\n\nthreads_per_worker\nNoneType\nNone\nnumber of threads per dask worker, the default is 2 for cpu, only applied if cuda==False\n\n\nrmm_pool_size\nfloat\n0.9\nset the rmm pool size, only applied when cuda==True\n\n\ndask_cluster_arg\nVAR_KEYWORD\n\n\n\n\n\nCLI version of temp_coh.\n\nlogger = mc.get_logger()\n\n\nds_can_coh = './co/ds_can_coh.zarr'\nds_can_ph = './pl/ds_can_ph.zarr'\nds_can_t_coh = './pqm/ds_can_t_coh.zarr'\n\n\ntemp_coh(ds_can_coh,ds_can_ph, ds_can_t_coh)\n\n2025-09-20 23:15:04 - log_args - INFO - running function: temp_coh\n2025-09-20 23:15:04 - log_args - INFO - fetching args:\n2025-09-20 23:15:04 - log_args - INFO - intf = './co/ds_can_coh.zarr'\n2025-09-20 23:15:04 - log_args - INFO - rslc = './pl/ds_can_ph.zarr'\n2025-09-20 23:15:04 - log_args - INFO - t_coh = './pqm/ds_can_t_coh.zarr'\n2025-09-20 23:15:04 - log_args - INFO - image_pairs = None\n2025-09-20 23:15:04 - log_args - INFO - chunks = None\n2025-09-20 23:15:04 - log_args - INFO - cuda = False\n2025-09-20 23:15:04 - log_args - INFO - processes = None\n2025-09-20 23:15:04 - log_args - INFO - n_workers = None\n2025-09-20 23:15:04 - log_args - INFO - threads_per_worker = None\n2025-09-20 23:15:04 - log_args - INFO - rmm_pool_size = 0.9\n2025-09-20 23:15:04 - log_args - INFO - dask_cluster_arg = {}\n2025-09-20 23:15:04 - log_args - INFO - fetching args done.\n2025-09-20 23:15:04 - zarr_info - INFO - ./co/ds_can_coh.zarr zarray shape, chunks, dtype: (732727, 136), (100000, 1), complex64\n2025-09-20 23:15:04 - zarr_info - INFO - ./pl/ds_can_ph.zarr zarray shape, chunks, dtype: (732727, 17), (100000, 1), complex64\n2025-09-20 23:15:04 - temp_coh - INFO - starting dask local cluster.\n2025-09-20 23:15:06 - temp_coh - INFO - dask local cluster started.\n2025-09-20 23:15:06 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.10:8787/status', workers=1, threads=1, memory=1.95 TiB)\n2025-09-20 23:15:06 - darr_info - INFO - intf dask array shape, chunksize, dtype: (732727, 136), (100000, 136), complex64\n2025-09-20 23:15:06 - darr_info - INFO - rslc dask array shape, chunksize, dtype: (732727, 17), (100000, 17), complex64\n2025-09-20 23:15:06 - temp_coh - INFO - Estimate temporal coherence for DS.\n2025-09-20 23:15:06 - temp_coh - INFO - got temporal coherence t_coh.\n2025-09-20 23:15:06 - darr_info - INFO - t_coh dask array shape, chunksize, dtype: (732727,), (100000,), float32\n2025-09-20 23:15:06 - temp_coh - INFO - saving t_coh.\n2025-09-20 23:15:06 - temp_coh - INFO - computing graph setted. doing all the computing.\n2025-09-20 23:15:08 - temp_coh - INFO - computing finished. |  2.6s\n2025-09-20 23:15:08 - temp_coh - INFO - dask cluster closed.\n\n\n\nif is_cuda_available():\n    temp_coh(ds_can_coh,ds_can_ph, ds_can_t_coh,cuda=True)\n\n2025-09-20 23:15:08 - log_args - INFO - running function: temp_coh\n2025-09-20 23:15:08 - log_args - INFO - fetching args:\n2025-09-20 23:15:08 - log_args - INFO - intf = './co/ds_can_coh.zarr'\n2025-09-20 23:15:08 - log_args - INFO - rslc = './pl/ds_can_ph.zarr'\n2025-09-20 23:15:08 - log_args - INFO - t_coh = './pqm/ds_can_t_coh.zarr'\n2025-09-20 23:15:08 - log_args - INFO - image_pairs = None\n2025-09-20 23:15:08 - log_args - INFO - chunks = None\n2025-09-20 23:15:08 - log_args - INFO - cuda = True\n2025-09-20 23:15:08 - log_args - INFO - processes = None\n2025-09-20 23:15:08 - log_args - INFO - n_workers = None\n2025-09-20 23:15:08 - log_args - INFO - threads_per_worker = None\n2025-09-20 23:15:08 - log_args - INFO - rmm_pool_size = 0.9\n2025-09-20 23:15:08 - log_args - INFO - dask_cluster_arg = {}\n2025-09-20 23:15:08 - log_args - INFO - fetching args done.\n2025-09-20 23:15:08 - zarr_info - INFO - ./co/ds_can_coh.zarr zarray shape, chunks, dtype: (732727, 136), (100000, 1), complex64\n2025-09-20 23:15:08 - zarr_info - INFO - ./pl/ds_can_ph.zarr zarray shape, chunks, dtype: (732727, 17), (100000, 1), complex64\n2025-09-20 23:15:08 - temp_coh - INFO - starting dask local cluster.\n2025-09-20 23:15:15 - temp_coh - INFO - dask local cluster started.\n2025-09-20 23:15:15 - dask_cluster_info - INFO - dask cluster: LocalCUDACluster(dashboard_link='http://127.0.0.1:8787/status', workers=8, threads=8, memory=1.95 TiB)\n2025-09-20 23:15:15 - darr_info - INFO - intf dask array shape, chunksize, dtype: (732727, 136), (100000, 136), complex64\n2025-09-20 23:15:15 - darr_info - INFO - rslc dask array shape, chunksize, dtype: (732727, 17), (100000, 17), complex64\n2025-09-20 23:15:15 - temp_coh - INFO - Estimate temporal coherence for DS.\n2025-09-20 23:15:15 - temp_coh - INFO - got temporal coherence t_coh.\n2025-09-20 23:15:15 - darr_info - INFO - t_coh dask array shape, chunksize, dtype: (732727,), (100000,), float32\n2025-09-20 23:15:15 - temp_coh - INFO - saving t_coh.\n2025-09-20 23:15:15 - temp_coh - INFO - computing graph setted. doing all the computing.\n2025-09-20 23:15:16 - temp_coh - INFO - computing finished. |  1.2s\n2025-09-20 23:15:18 - temp_coh - INFO - dask cluster closed.\n\n\n\nds_can_gix = './shp/ds_can_gix.zarr'\nt_coh = './pqm/t_coh.zarr'\nrslc_zarr = zarr.open('./raw/rslc.zarr/',mode='r')\nmc.pc2ras(ds_can_gix, ds_can_t_coh,t_coh,rslc_zarr.shape[:2])\n\n2025-09-20 23:15:18 - log_args - INFO - running function: pc2ras\n2025-09-20 23:15:18 - log_args - INFO - fetching args:\n2025-09-20 23:15:18 - log_args - INFO - idx = './shp/ds_can_gix.zarr'\n2025-09-20 23:15:18 - log_args - INFO - pc = './pqm/ds_can_t_coh.zarr'\n2025-09-20 23:15:18 - log_args - INFO - ras = './pqm/t_coh.zarr'\n2025-09-20 23:15:18 - log_args - INFO - shape = (2500, 1834)\n2025-09-20 23:15:18 - log_args - INFO - chunks = (1000, 1000)\n2025-09-20 23:15:18 - log_args - INFO - processes = False\n2025-09-20 23:15:18 - log_args - INFO - n_workers = 1\n2025-09-20 23:15:18 - log_args - INFO - threads_per_worker = 1\n2025-09-20 23:15:18 - log_args - INFO - dask_cluster_arg = {}\n2025-09-20 23:15:18 - log_args - INFO - fetching args done.\n2025-09-20 23:15:18 - zarr_info - INFO - ./shp/ds_can_gix.zarr zarray shape, chunks, dtype: (732727, 2), (100000, 1), int32\n2025-09-20 23:15:18 - pc2ras - INFO - loading gix into memory.\n2025-09-20 23:15:18 - pc2ras - INFO - starting dask local cluster.\n2025-09-20 23:15:18 - pc2ras - INFO - dask local cluster started.\n2025-09-20 23:15:18 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.10:8787/status', workers=1, threads=1, memory=1.95 TiB)\n2025-09-20 23:15:18 - pc2ras - INFO - start to work on ./pqm/ds_can_t_coh.zarr\n2025-09-20 23:15:18 - zarr_info - INFO - ./pqm/ds_can_t_coh.zarr zarray shape, chunks, dtype: (732727,), (100000,), float32\n2025-09-20 23:15:18 - darr_info - INFO - pc dask array shape, chunksize, dtype: (732727,), (732727,), float32\n2025-09-20 23:15:18 - pc2ras - INFO - create ras dask array\n2025-09-20 23:15:18 - darr_info - INFO - ras dask array shape, chunksize, dtype: (2500, 1834), (2500, 1834), float32\n2025-09-20 23:15:18 - pc2ras - INFO - save ras to ./pqm/t_coh.zarr\n2025-09-20 23:15:18 - zarr_info - INFO - ./pqm/t_coh.zarr zarray shape, chunks, dtype: (2500, 1834), (1000, 1000), float32\n2025-09-20 23:15:18 - pc2ras - INFO - computing graph setted. doing all the computing.\n2025-09-20 23:15:19 - pc2ras - INFO - computing finished.ed |  0.1s\n2025-09-20 23:15:19 - pc2ras - INFO - dask cluster closed.\n\n\n\nt_coh_zarr = zarr.open(t_coh,mode='r')\nfig, ax = plt.subplots(1,1,figsize=(10,10))\npcm = ax.imshow(t_coh_zarr[:],interpolation='nearest',vmin=0.0,vmax=1.0)\nax.set(title='DS temporal coherence',xlabel='Range Index',ylabel='Azimuth Index')\nfig.colorbar(pcm)\nplt.show()\n\n\n\n\n\n\n\n\nOr with raster data:\n\nrslc = 'raw/rslc.zarr/'\nintf = 'dl/n2f_intf.zarr'\ntcoh = 'pqm/n2f_tcoh.zarr'\ntnet = mr.TempNet.from_bandwidth(zarr.open(rslc,mode='r').shape[-1],1)\n\n\ntemp_coh(intf,rslc,tcoh,image_pairs=tnet.image_pairs)\n\n2025-09-20 23:15:19 - log_args - INFO - running function: temp_coh\n2025-09-20 23:15:19 - log_args - INFO - fetching args:\n2025-09-20 23:15:19 - log_args - INFO - intf = 'dl/n2f_intf.zarr'\n2025-09-20 23:15:19 - log_args - INFO - rslc = 'raw/rslc.zarr/'\n2025-09-20 23:15:19 - log_args - INFO - t_coh = 'pqm/n2f_tcoh.zarr'\n2025-09-20 23:15:19 - log_args - INFO - image_pairs = array([[ 0,  1],\n       [ 1,  2],\n       [ 2,  3],\n       [ 3,  4],\n       [ 4,  5],\n       [ 5,  6],\n       [ 6,  7],\n       [ 7,  8],\n       [ 8,  9],\n       [ 9, 10],\n       [10, 11],\n       [11, 12],\n       [12, 13],\n       [13, 14],\n       [14, 15],\n       [15, 16]], dtype=int32)\n2025-09-20 23:15:19 - log_args - INFO - chunks = None\n2025-09-20 23:15:19 - log_args - INFO - cuda = False\n2025-09-20 23:15:19 - log_args - INFO - processes = None\n2025-09-20 23:15:19 - log_args - INFO - n_workers = None\n2025-09-20 23:15:19 - log_args - INFO - threads_per_worker = None\n2025-09-20 23:15:19 - log_args - INFO - rmm_pool_size = 0.9\n2025-09-20 23:15:19 - log_args - INFO - dask_cluster_arg = {}\n2025-09-20 23:15:19 - log_args - INFO - fetching args done.\n2025-09-20 23:15:19 - zarr_info - INFO - dl/n2f_intf.zarr zarray shape, chunks, dtype: (2500, 1834, 16), (1000, 1000, 1), complex64\n2025-09-20 23:15:19 - zarr_info - INFO - raw/rslc.zarr/ zarray shape, chunks, dtype: (2500, 1834, 17), (1000, 1000, 1), complex64\n2025-09-20 23:15:19 - temp_coh - INFO - starting dask local cluster.\n2025-09-20 23:15:19 - temp_coh - INFO - dask local cluster started.\n2025-09-20 23:15:19 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.10:8787/status', workers=1, threads=1, memory=1.95 TiB)\n2025-09-20 23:15:19 - darr_info - INFO - intf dask array shape, chunksize, dtype: (2500, 1834, 16), (1000, 1000, 16), complex64\n2025-09-20 23:15:19 - darr_info - INFO - rslc dask array shape, chunksize, dtype: (2500, 1834, 17), (1000, 1000, 17), complex64\n2025-09-20 23:15:19 - temp_coh - INFO - Estimate temporal coherence for DS.\n2025-09-20 23:15:19 - temp_coh - INFO - got temporal coherence t_coh.\n2025-09-20 23:15:19 - darr_info - INFO - t_coh dask array shape, chunksize, dtype: (2500, 1834), (1000, 1000), float32\n2025-09-20 23:15:19 - temp_coh - INFO - saving t_coh.\n2025-09-20 23:15:19 - temp_coh - INFO - computing graph setted. doing all the computing.\n2025-09-20 23:15:20 - temp_coh - INFO - computing finished. |  1.1s\n2025-09-20 23:15:20 - temp_coh - INFO - dask cluster closed.\n\n\nor with gpu:\n\nif is_cuda_available():\n    temp_coh(intf,rslc,tcoh,image_pairs=tnet.image_pairs,cuda=True)\n\n2025-09-20 23:15:20 - log_args - INFO - running function: temp_coh\n2025-09-20 23:15:20 - log_args - INFO - fetching args:\n2025-09-20 23:15:20 - log_args - INFO - intf = 'dl/n2f_intf.zarr'\n2025-09-20 23:15:20 - log_args - INFO - rslc = 'raw/rslc.zarr/'\n2025-09-20 23:15:20 - log_args - INFO - t_coh = 'pqm/n2f_tcoh.zarr'\n2025-09-20 23:15:20 - log_args - INFO - image_pairs = array([[ 0,  1],\n       [ 1,  2],\n       [ 2,  3],\n       [ 3,  4],\n       [ 4,  5],\n       [ 5,  6],\n       [ 6,  7],\n       [ 7,  8],\n       [ 8,  9],\n       [ 9, 10],\n       [10, 11],\n       [11, 12],\n       [12, 13],\n       [13, 14],\n       [14, 15],\n       [15, 16]], dtype=int32)\n2025-09-20 23:15:20 - log_args - INFO - chunks = None\n2025-09-20 23:15:20 - log_args - INFO - cuda = True\n2025-09-20 23:15:20 - log_args - INFO - processes = None\n2025-09-20 23:15:20 - log_args - INFO - n_workers = None\n2025-09-20 23:15:20 - log_args - INFO - threads_per_worker = None\n2025-09-20 23:15:20 - log_args - INFO - rmm_pool_size = 0.9\n2025-09-20 23:15:20 - log_args - INFO - dask_cluster_arg = {}\n2025-09-20 23:15:20 - log_args - INFO - fetching args done.\n2025-09-20 23:15:20 - zarr_info - INFO - dl/n2f_intf.zarr zarray shape, chunks, dtype: (2500, 1834, 16), (1000, 1000, 1), complex64\n2025-09-20 23:15:20 - zarr_info - INFO - raw/rslc.zarr/ zarray shape, chunks, dtype: (2500, 1834, 17), (1000, 1000, 1), complex64\n2025-09-20 23:15:20 - temp_coh - INFO - starting dask local cluster.\n2025-09-20 23:15:27 - temp_coh - INFO - dask local cluster started.\n2025-09-20 23:15:27 - dask_cluster_info - INFO - dask cluster: LocalCUDACluster(dashboard_link='http://127.0.0.1:8787/status', workers=8, threads=8, memory=1.95 TiB)\n2025-09-20 23:15:27 - darr_info - INFO - intf dask array shape, chunksize, dtype: (2500, 1834, 16), (1000, 1000, 16), complex64\n2025-09-20 23:15:27 - darr_info - INFO - rslc dask array shape, chunksize, dtype: (2500, 1834, 17), (1000, 1000, 17), complex64\n2025-09-20 23:15:27 - temp_coh - INFO - Estimate temporal coherence for DS.\n2025-09-20 23:15:27 - temp_coh - INFO - got temporal coherence t_coh.\n2025-09-20 23:15:27 - darr_info - INFO - t_coh dask array shape, chunksize, dtype: (2500, 1834), (1000, 1000), float32\n2025-09-20 23:15:27 - temp_coh - INFO - saving t_coh.\n2025-09-20 23:15:27 - temp_coh - INFO - computing graph setted. doing all the computing.\n2025-09-20 23:15:28 - temp_coh - INFO - computing finished. |  1.3s\n2025-09-20 23:15:30 - temp_coh - INFO - dask cluster closed.\n\n\n\nfig, ax = plt.subplots(1,1,figsize=(10,10))\npcm = ax.imshow(zarr.open(tcoh,mode='r')[:],interpolation='nearest',vmin=0.0,vmax=1.0)\nax.set(title='Noise2Fringe Temporal Coherence',xlabel='Range Index',ylabel='Azimuth Index')\nfig.colorbar(pcm)\nfig.show()",
    "crumbs": [
      "CLI",
      "pqm"
    ]
  },
  {
    "objectID": "CLI/shp.html",
    "href": "CLI/shp.html",
    "title": "shp",
    "section": "",
    "text": "from matplotlib import pyplot as plt\nimport zarr\nimport colorcet\nimport moraine.cli as mc\nfrom moraine.utils_ import is_cuda_available\n\n\nsource\n\nshp_test\n\n shp_test (rslc:str, pvalue:str, az_half_win:int, r_half_win:int,\n           method:str=None, chunks:tuple[int,int]=None, cuda:bool=False,\n           processes=None, n_workers=None, threads_per_worker=None,\n           rmm_pool_size=0.9, **dask_cluster_arg)\n\nSHP identification through hypothetic test.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nrslc\nstr\n\ninput: rslc stack\n\n\npvalue\nstr\n\noutput: the p value of the test\n\n\naz_half_win\nint\n\nazimuth half window size\n\n\nr_half_win\nint\n\nrange half window size\n\n\nmethod\nstr\nNone\nSHP identification method,optional. Default: ks\n\n\nchunks\ntuple\nNone\nchunk size, optional. Default: the chunk size in rslc\n\n\ncuda\nbool\nFalse\nif use cuda for processing, false by default\n\n\nprocesses\nNoneType\nNone\nuse process for dask worker over thread, the default is False for cpu, only applied if cuda==False\n\n\nn_workers\nNoneType\nNone\nnumber of dask worker, the default is 1 for cpu, number of GPU for cuda\n\n\nthreads_per_worker\nNoneType\nNone\nnumber of threads per dask worker, the default is 2 for cpu, only applied if cuda==False\n\n\nrmm_pool_size\nfloat\n0.9\nset the rmm pool size, only applied when cuda==True\n\n\ndask_cluster_arg\nVAR_KEYWORD\n\n\n\n\n\nThis function is a wrapper of functions in decorrelation.shp that provides file interface. Please refer it for the usage. It utilizes dask for parallel and distributed computation. Compared with the functions in decorrelation.shp, this function splits the dataset into several chunks and the computation in these chunks can run in parallel on multi-GPUs.\nThe r_chunk_size and az_chunk_size is used to determine how many pixels in range and azimuth in one chunk. The chunk size of the output pvalue is also setted according to them.\n\nrslc = './raw/rslc.zarr'\npvalue = './shp/pvalue.zarr'\n\n\nlogger = mc.get_logger()\n\n\nshp_test(rslc,pvalue,az_half_win=5,r_half_win=5,method=None)\n\n2025-09-18 12:36:38 - log_args - INFO - running function: shp_test\n2025-09-18 12:36:38 - log_args - INFO - fetching args:\n2025-09-18 12:36:38 - log_args - INFO - rslc = './raw/rslc.zarr'\n2025-09-18 12:36:38 - log_args - INFO - pvalue = './shp/pvalue.zarr'\n2025-09-18 12:36:38 - log_args - INFO - az_half_win = 5\n2025-09-18 12:36:38 - log_args - INFO - r_half_win = 5\n2025-09-18 12:36:38 - log_args - INFO - method = None\n2025-09-18 12:36:38 - log_args - INFO - chunks = None\n2025-09-18 12:36:38 - log_args - INFO - cuda = False\n2025-09-18 12:36:38 - log_args - INFO - processes = None\n2025-09-18 12:36:38 - log_args - INFO - n_workers = None\n2025-09-18 12:36:38 - log_args - INFO - threads_per_worker = None\n2025-09-18 12:36:38 - log_args - INFO - rmm_pool_size = 0.9\n2025-09-18 12:36:38 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 12:36:38 - log_args - INFO - fetching args done.\n2025-09-18 12:36:38 - shp_test - INFO - hypothetic test method: ks\n2025-09-18 12:36:38 - zarr_info - INFO - ./raw/rslc.zarr zarray shape, chunks, dtype: (2500, 1834, 17), (1000, 1000, 1), complex64\n2025-09-18 12:36:38 - shp_test - INFO - starting dask local cluster.\n2025-09-18 12:36:40 - shp_test - INFO - dask local cluster started.\n2025-09-18 12:36:40 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.4:8787/status', workers=1, threads=1, memory=256.00 GiB)\n2025-09-18 12:36:40 - shp_test - INFO - azimuth half window size: 5; azimuth window size: 11\n2025-09-18 12:36:40 - shp_test - INFO - range half window size: 5; range window size: 11\n2025-09-18 12:36:40 - darr_info - INFO - rslc with overlap dask array shape, chunksize, dtype: (2520, 1844, 17), (1010, 1005, 17), complex64\n2025-09-18 12:36:41 - shp_test - INFO - applying test on rmli stack.\n2025-09-18 12:36:41 - shp_test - INFO - trim shared boundaries between p value chunks\n2025-09-18 12:36:41 - darr_info - INFO - p value dask array shape, chunksize, dtype: (2500, 1834, 11, 11), (1000, 1000, 11, 11), float32\n2025-09-18 12:36:41 - shp_test - INFO - saving p value.\n2025-09-18 12:36:41 - zarr_info - INFO - ./shp/pvalue.zarr zarray shape, chunks, dtype: (2500, 1834, 11, 11), (1000, 1000, 1, 1), float32\n2025-09-18 12:36:41 - shp_test - INFO - computing graph setted. doing all the computing.\n2025-09-18 12:36:58 - shp_test - INFO - computing finished. | 16.5s\n2025-09-18 12:36:58 - shp_test - INFO - dask cluster closed.\nCPU times: user 2min 20s, sys: 7.29 s, total: 2min 28s\nWall time: 19.5 s\n\n\n\nif is_cuda_available():\n    shp_test(rslc,pvalue,az_half_win=5,r_half_win=5,cuda=True)\n\n2025-09-18 12:36:58 - log_args - INFO - running function: shp_test\n2025-09-18 12:36:58 - log_args - INFO - fetching args:\n2025-09-18 12:36:58 - log_args - INFO - rslc = './raw/rslc.zarr'\n2025-09-18 12:36:58 - log_args - INFO - pvalue = './shp/pvalue.zarr'\n2025-09-18 12:36:58 - log_args - INFO - az_half_win = 5\n2025-09-18 12:36:58 - log_args - INFO - r_half_win = 5\n2025-09-18 12:36:58 - log_args - INFO - method = None\n2025-09-18 12:36:58 - log_args - INFO - chunks = None\n2025-09-18 12:36:58 - log_args - INFO - cuda = True\n2025-09-18 12:36:58 - log_args - INFO - processes = None\n2025-09-18 12:36:58 - log_args - INFO - n_workers = None\n2025-09-18 12:36:58 - log_args - INFO - threads_per_worker = None\n2025-09-18 12:36:58 - log_args - INFO - rmm_pool_size = 0.9\n2025-09-18 12:36:58 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 12:36:58 - log_args - INFO - fetching args done.\n2025-09-18 12:36:58 - shp_test - INFO - hypothetic test method: ks\n2025-09-18 12:36:58 - zarr_info - INFO - ./raw/rslc.zarr zarray shape, chunks, dtype: (2500, 1834, 17), (1000, 1000, 1), complex64\n2025-09-18 12:36:58 - shp_test - INFO - starting dask local cluster.\n\n\n2025-09-18 12:37:00,433 - distributed.worker - WARNING - Setting CPU affinity for GPU failed. Please refer to the following link for troubleshooting information: https://docs.rapids.ai/api/dask-cuda/nightly/troubleshooting/#setting-cpu-affinity-failure\n2025-09-18 12:37:00,437 - distributed.worker - WARNING - Setting CPU affinity for GPU failed. Please refer to the following link for troubleshooting information: https://docs.rapids.ai/api/dask-cuda/nightly/troubleshooting/#setting-cpu-affinity-failure\n\n\n2025-09-18 12:37:00 - shp_test - INFO - dask local cluster started.\n2025-09-18 12:37:00 - dask_cluster_info - INFO - dask cluster: LocalCUDACluster(dashboard_link='http://127.0.0.1:8787/status', workers=2, threads=2, memory=256.00 GiB)\n2025-09-18 12:37:00 - shp_test - INFO - azimuth half window size: 5; azimuth window size: 11\n2025-09-18 12:37:00 - shp_test - INFO - range half window size: 5; range window size: 11\n2025-09-18 12:37:00 - darr_info - INFO - rslc with overlap dask array shape, chunksize, dtype: (2520, 1844, 17), (1010, 1005, 17), complex64\n2025-09-18 12:37:01 - shp_test - INFO - applying test on rmli stack.\n2025-09-18 12:37:01 - shp_test - INFO - trim shared boundaries between p value chunks\n2025-09-18 12:37:01 - darr_info - INFO - p value dask array shape, chunksize, dtype: (2500, 1834, 11, 11), (1000, 1000, 11, 11), float32\n2025-09-18 12:37:01 - shp_test - INFO - saving p value.\n2025-09-18 12:37:01 - zarr_info - INFO - ./shp/pvalue.zarr zarray shape, chunks, dtype: (2500, 1834, 11, 11), (1000, 1000, 1, 1), float32\n2025-09-18 12:37:01 - shp_test - INFO - computing graph setted. doing all the computing.\n2025-09-18 12:37:08 - shp_test - INFO - computing finished. |  6.8s\n2025-09-18 12:37:09 - shp_test - INFO - dask cluster closed.\nCPU times: user 358 ms, sys: 646 ms, total: 1 s\nWall time: 10.8 s\n\n\n\nsource\n\n\nselect_shp\n\n select_shp (pvalue:str, is_shp:str, shp_num:str, p_max:float=0.05,\n             chunks:tuple[int,int]=None, processes=False, n_workers=1,\n             threads_per_worker=1, **dask_cluster_arg)\n\nSelect SHP based on pvalue of SHP test.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\npvalue\nstr\n\ninput: pvalue of hypothetic test\n\n\nis_shp\nstr\n\noutput: bool array indicating the SHPs\n\n\nshp_num\nstr\n\noutput: integer array indicating number of SHPs\n\n\np_max\nfloat\n0.05\nthreshold of p value to select SHP,optional. Default: 0.05\n\n\nchunks\ntuple\nNone\nchunk size, optional. Default: the chunk size in rslc\n\n\nprocesses\nbool\nFalse\nuse process for dask worker over thread, the default is False\n\n\nn_workers\nint\n1\nnumber of dask worker, the default is 1\n\n\nthreads_per_worker\nint\n1\nnumber of threads per dask worker\n\n\ndask_cluster_arg\nVAR_KEYWORD\n\n\n\n\n\n\npvalue = './shp/pvalue.zarr'\nis_shp = './shp/is_shp.zarr'\nshp_num = './shp/num.zarr'\np_max = 0.05\n\n\nselect_shp(pvalue,is_shp,shp_num,p_max=p_max)\n\n2025-09-18 12:37:09 - log_args - INFO - running function: select_shp\n2025-09-18 12:37:09 - log_args - INFO - fetching args:\n2025-09-18 12:37:09 - log_args - INFO - pvalue = './shp/pvalue.zarr'\n2025-09-18 12:37:09 - log_args - INFO - is_shp = './shp/is_shp.zarr'\n2025-09-18 12:37:09 - log_args - INFO - shp_num = './shp/num.zarr'\n2025-09-18 12:37:09 - log_args - INFO - p_max = 0.05\n2025-09-18 12:37:09 - log_args - INFO - chunks = None\n2025-09-18 12:37:09 - log_args - INFO - processes = False\n2025-09-18 12:37:09 - log_args - INFO - n_workers = 1\n2025-09-18 12:37:09 - log_args - INFO - threads_per_worker = 1\n2025-09-18 12:37:09 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 12:37:09 - log_args - INFO - fetching args done.\n2025-09-18 12:37:09 - zarr_info - INFO - ./shp/pvalue.zarr zarray shape, chunks, dtype: (2500, 1834, 11, 11), (1000, 1000, 1, 1), float32\n2025-09-18 12:37:09 - select_shp - INFO - starting dask cluster.\n2025-09-18 12:37:09 - select_shp - INFO - dask cluster started.\n2025-09-18 12:37:09 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.4:8787/status', workers=1, threads=1, memory=256.00 GiB)\n2025-09-18 12:37:09 - darr_info - INFO - pvalue dask array shape, chunksize, dtype: (2500, 1834, 11, 11), (1000, 1000, 11, 11), float32\n2025-09-18 12:37:09 - select_shp - INFO - selecting SHPs based on pvalue threshold: 0.05\n2025-09-18 12:37:09 - darr_info - INFO - is_shp dask array shape, chunksize, dtype: (2500, 1834, 11, 11), (1000, 1000, 11, 11), bool\n2025-09-18 12:37:09 - select_shp - INFO - calculate shp_num.\n2025-09-18 12:37:09 - darr_info - INFO - shp_num dask array shape, chunksize, dtype: (2500, 1834), (1000, 1000), int32\n2025-09-18 12:37:09 - select_shp - INFO - saving is_shp.\n2025-09-18 12:37:09 - zarr_info - INFO - ./shp/is_shp.zarr zarray shape, chunks, dtype: (2500, 1834, 11, 11), (1000, 1000, 1, 1), bool\n2025-09-18 12:37:09 - select_shp - INFO - saving shp_num.\n2025-09-18 12:37:09 - zarr_info - INFO - ./shp/num.zarr zarray shape, chunks, dtype: (2500, 1834), (1000, 1000), int32\n2025-09-18 12:37:09 - select_shp - INFO - computing graph setted. doing all the computing.\n2025-09-18 12:37:18 - select_shp - INFO - computing finished.  9.0s\n2025-09-18 12:37:18 - select_shp - INFO - dask cluster closed.\nCPU times: user 34.9 s, sys: 6.94 s, total: 41.8 s\nWall time: 9.45 s\n\n\n\nshp_num_zarr = zarr.open(shp_num,mode='r')\nfig, ax = plt.subplots(1,1,figsize=(10,10))\npcm = ax.imshow(shp_num_zarr[:],cmap=colorcet.cm.fire)\nax.set(title='Number of SHPs',xlabel='Range Index',ylabel='Azimuth Index')\nfig.colorbar(pcm)\nfig.show()\n\n\n\n\n\n\n\n\nThen we can select DS candidates based on number of SHPs and slice is_shp only on DS candidates.\n\nds_can_gix = './shp/ds_can_gix.zarr'\nis_ds_can= './shp/is_ds_can.zarr'\n\n\nmc.pc_logic_ras(shp_num,ds_can_gix,'ras&gt;=50')\n\n2025-09-18 12:37:19 - log_args - INFO - running function: pc_logic_ras\n2025-09-18 12:37:19 - log_args - INFO - fetching args:\n2025-09-18 12:37:19 - log_args - INFO - ras = './shp/num.zarr'\n2025-09-18 12:37:19 - log_args - INFO - gix = './shp/ds_can_gix.zarr'\n2025-09-18 12:37:19 - log_args - INFO - operation = 'ras&gt;=50'\n2025-09-18 12:37:19 - log_args - INFO - chunks = 100000\n2025-09-18 12:37:19 - log_args - INFO - fetching args done.\n2025-09-18 12:37:19 - zarr_info - INFO - ./shp/num.zarr zarray shape, chunks, dtype: (2500, 1834), (1000, 1000), int32\n2025-09-18 12:37:19 - pc_logic_ras - INFO - loading ras into memory.\n2025-09-18 12:37:19 - pc_logic_ras - INFO - select pc based on operation: ras&gt;=50\n2025-09-18 12:37:19 - pc_logic_ras - INFO - number of selected pixels: 732727.\n2025-09-18 12:37:19 - zarr_info - INFO - ./shp/ds_can_gix.zarr zarray shape, chunks, dtype: (732727, 2), (100000, 1), int32\n2025-09-18 12:37:19 - pc_logic_ras - INFO - writing gix.\n2025-09-18 12:37:19 - pc_logic_ras - INFO - write done.\n\n\n\nmc.gix2bool(ds_can_gix, is_ds_can, shape= shp_num_zarr.shape)\n\n2025-09-18 12:37:19 - log_args - INFO - running function: gix2bool\n2025-09-18 12:37:19 - log_args - INFO - fetching args:\n2025-09-18 12:37:19 - log_args - INFO - gix = './shp/ds_can_gix.zarr'\n2025-09-18 12:37:19 - log_args - INFO - is_pc = './shp/is_ds_can.zarr'\n2025-09-18 12:37:19 - log_args - INFO - shape = (2500, 1834)\n2025-09-18 12:37:19 - log_args - INFO - chunks = (1000, 1000)\n2025-09-18 12:37:19 - log_args - INFO - fetching args done.\n2025-09-18 12:37:19 - zarr_info - INFO - gix zarray shape, chunks, dtype: (732727, 2), (100000, 1), int32\n2025-09-18 12:37:19 - gix2bool - INFO - loading gix into memory.\n2025-09-18 12:37:19 - gix2bool - INFO - calculate the bool array\n2025-09-18 12:37:19 - zarr_info - INFO - is_pc zarray shape, chunks, dtype: (2500, 1834), (1000, 1000), bool\n2025-09-18 12:37:19 - gix2bool - INFO - write the bool array.\n2025-09-18 12:37:19 - gix2bool - INFO - write done.\n\n\n\nis_ds_can_zarr = zarr.open(is_ds_can,mode='r')\nfig, ax = plt.subplots(1,1,figsize=(10,10))\npcm = ax.imshow(is_ds_can_zarr[:].astype(np.float32)*10)\nax.set(title='DS candidiate distribution',xlabel='Range Index',ylabel='Azimuth Index')\nfig.colorbar(pcm)\nfig.show()",
    "crumbs": [
      "CLI",
      "shp"
    ]
  },
  {
    "objectID": "CLI/pu.html",
    "href": "CLI/pu.html",
    "title": "Phase Unwrapping",
    "section": "",
    "text": "import moraine.cli as mc\nimport zarr\nimport numpy as np\nimport toml\nimport holoviews as hv\nfrom bokeh.models import WheelZoomTool\n\n\nhv.extension('bokeh')\nhv.output(widget_location='bottom')\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n  \n  \n\n\n\n\n\n\n\n\nⓘ\n\n\n\n\n\nsource\n\ngamma_mcf_pt\n\n gamma_mcf_pt (pc_x:str, pc_y:str, ph:str, unw_ph:str,\n               image_pairs:numpy.ndarray, ref_point:int=1,\n               out_chunks:int=None, n_workers=1, threads_per_worker=2,\n               **dask_cluster_arg)\n\nA wrapper for mcf_pt in GAMMA software.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\npc_x\nstr\n\nx coordinate, shape of (N,)\n\n\npc_y\nstr\n\ny coordinate, shape of (N,)\n\n\nph\nstr\n\nstack of wrapped phase, shape of (N,M)\n\n\nunw_ph\nstr\n\noutput, unwrapped phase, shape of (N,L)\n\n\nimage_pairs\nndarray\n\nimage pairs to construct interferograms for unwrapping\n\n\nref_point\nint\n1\nreference point, the first point by default\n\n\nout_chunks\nint\nNone\nunw_ph point cloud chunk size, same as ph by default\n\n\nn_workers\nint\n1\nnumber of dask worker, number of interferograms to be unwrapped in the same time\n\n\nthreads_per_worker\nint\n2\nnumber of threads per dask worker\n\n\ndask_cluster_arg\nVAR_KEYWORD\n\n\n\n\n\nUsage:\n\nlogger = mc.get_logger()\n\n\n# load phase-linked wrapped phase\nds_ph = './pu/ds_ph.zarr/'\nds_e = './pu/ds_e.zarr/'\nds_n = './pu/ds_n.zarr/'\nds_unw = './pu/ds_unw.zarr/'\nds_ph_zarr = zarr.open(ds_ph,mode='r')\ntnet = mr.TempNet.from_bandwidth(ds_ph_zarr.shape[1],bandwidth=1)\n\n\ngamma_mcf_pt(ds_e, ds_n, ds_ph, ds_unw, tnet.image_pairs)\n\n2025-09-18 13:24:52 - log_args - INFO - running function: gamma_mcf_pt\n2025-09-18 13:24:52 - log_args - INFO - fetching args:\n2025-09-18 13:24:52 - log_args - INFO - pc_x = './pu/ds_e.zarr/'\n2025-09-18 13:24:52 - log_args - INFO - pc_y = './pu/ds_n.zarr/'\n2025-09-18 13:24:52 - log_args - INFO - ph = './pu/ds_ph.zarr/'\n2025-09-18 13:24:52 - log_args - INFO - unw_ph = './pu/ds_unw.zarr/'\n2025-09-18 13:24:52 - log_args - INFO - image_pairs = array([[ 0,  1],\n       [ 1,  2],\n       [ 2,  3],\n       [ 3,  4],\n       [ 4,  5],\n       [ 5,  6],\n       [ 6,  7],\n       [ 7,  8],\n       [ 8,  9],\n       [ 9, 10],\n       [10, 11],\n       [11, 12],\n       [12, 13],\n       [13, 14],\n       [14, 15],\n       [15, 16]], dtype=int32)\n2025-09-18 13:24:52 - log_args - INFO - ref_point = 1\n2025-09-18 13:24:52 - log_args - INFO - out_chunks = None\n2025-09-18 13:24:52 - log_args - INFO - n_workers = 1\n2025-09-18 13:24:52 - log_args - INFO - threads_per_worker = 2\n2025-09-18 13:24:52 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 13:24:52 - log_args - INFO - fetching args done.\n2025-09-18 13:24:52 - gamma_mcf_pt - INFO - load coordinates\n2025-09-18 13:24:52 - gamma_mcf_pt - INFO - Done\n2025-09-18 13:24:52 - zarr_info - INFO - ./pu/ds_ph.zarr/ zarray shape, chunks, dtype: (293814, 17), (200000, 1), complex64\n2025-09-18 13:24:52 - gamma_mcf_pt - INFO - starting dask local cluster.\n2025-09-18 13:24:53 - gamma_mcf_pt - INFO - dask local cluster started.\n2025-09-18 13:24:53 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://127.0.0.1:8787/status', workers=1, threads=2, memory=256.00 GiB)\n2025-09-18 13:24:53 - darr_info - INFO - ph dask array shape, chunksize, dtype: (293814, 17), (293814, 1), complex64\n2025-09-18 13:24:53 - gamma_mcf_pt - INFO - phase wrapping with mcf.\n2025-09-18 13:24:53 - gamma_mcf_pt - INFO - got unwrapped phase.\n2025-09-18 13:24:53 - darr_info - INFO - unw_ph dask array shape, chunksize, dtype: (293814, 16), (293814, 1), float32\n2025-09-18 13:24:53 - gamma_mcf_pt - INFO - save unw_ph\n2025-09-18 13:24:53 - zarr_info - INFO - ./pu/ds_unw.zarr/ zarray shape, chunks, dtype: (293814, 16), (200000, 1), float32\n2025-09-18 13:24:53 - gamma_mcf_pt - INFO - computing graph setted. doing all the computing.\n2025-09-18 13:25:02 - gamma_mcf_pt - INFO - computing finished.8.9s\n2025-09-18 13:25:02 - gamma_mcf_pt - INFO - dask cluster closed.\n\n\n\n# note that the data is already in hilbert order\nmc.pc_pyramid(\n    './pu/ds_ph.zarr',\n    './pu/ds_ph_geo_pyramid',\n    x = './pu/ds_e.zarr/',\n    y = './pu/ds_n.zarr/',\n    ras_resolution=20,\n)\nmc.pc_pyramid(\n    './pu/ds_unw.zarr',\n    './pu/ds_unw_geo_pyramid',\n    x = './pu/ds_e.zarr/',\n    y = './pu/ds_n.zarr/',\n    ras_resolution=20,\n)\n\n2025-09-18 13:25:02 - log_args - INFO - running function: pc_pyramid\n2025-09-18 13:25:02 - log_args - INFO - fetching args:\n2025-09-18 13:25:02 - log_args - INFO - pc = './pu/ds_ph.zarr'\n2025-09-18 13:25:02 - log_args - INFO - out_dir = './pu/ds_ph_geo_pyramid'\n2025-09-18 13:25:02 - log_args - INFO - x = './pu/ds_e.zarr/'\n2025-09-18 13:25:02 - log_args - INFO - y = './pu/ds_n.zarr/'\n2025-09-18 13:25:02 - log_args - INFO - yx = None\n2025-09-18 13:25:02 - log_args - INFO - ras_resolution = 20\n2025-09-18 13:25:02 - log_args - INFO - ras_chunks = (256, 256)\n2025-09-18 13:25:02 - log_args - INFO - pc_chunks = 65536\n2025-09-18 13:25:02 - log_args - INFO - processes = False\n2025-09-18 13:25:02 - log_args - INFO - n_workers = 1\n2025-09-18 13:25:02 - log_args - INFO - threads_per_worker = 2\n2025-09-18 13:25:02 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 13:25:02 - log_args - INFO - fetching args done.\n2025-09-18 13:25:02 - pc_pyramid - INFO - clean out dir\n2025-09-18 13:25:02 - zarr_info - INFO - ./pu/ds_ph.zarr zarray shape, chunks, dtype: (293814, 17), (200000, 1), complex64\n2025-09-18 13:25:02 - pc_pyramid - INFO - rendering point cloud data coordinates:\n2025-09-18 13:25:02 - pc_pyramid - INFO - rasterizing point cloud data to grid with bounds: [np.float64(-16498471.798140068), np.float64(8649651.33657227), np.float64(-16470131.798140068), np.float64(8674811.33657227)].\n2025-09-18 13:25:03 - zarr_info - INFO - pu/ds_ph_geo_pyramid/x.zarr zarray shape, chunks, dtype: (293814,), (65536,), float64\n2025-09-18 13:25:03 - zarr_info - INFO - pu/ds_ph_geo_pyramid/y.zarr zarray shape, chunks, dtype: (293814,), (65536,), float64\n2025-09-18 13:25:03 - pc_pyramid - INFO - pc data coordinates rendering ends.\n2025-09-18 13:25:03 - zarr_info - INFO - pu/ds_ph_geo_pyramid/idx_0.zarr zarray shape, chunks, dtype: (1259, 1418), (256, 256), int64\n2025-09-18 13:25:04 - zarr_info - INFO - pu/ds_ph_geo_pyramid/idx_1.zarr zarray shape, chunks, dtype: (630, 709), (256, 256), int64\n2025-09-18 13:25:04 - zarr_info - INFO - pu/ds_ph_geo_pyramid/idx_2.zarr zarray shape, chunks, dtype: (315, 355), (256, 256), int64\n2025-09-18 13:25:04 - zarr_info - INFO - pu/ds_ph_geo_pyramid/idx_3.zarr zarray shape, chunks, dtype: (158, 178), (256, 256), int64\n2025-09-18 13:25:04 - zarr_info - INFO - pu/ds_ph_geo_pyramid/idx_4.zarr zarray shape, chunks, dtype: (79, 89), (256, 256), int64\n2025-09-18 13:25:04 - zarr_info - INFO - pu/ds_ph_geo_pyramid/idx_5.zarr zarray shape, chunks, dtype: (40, 45), (256, 256), int64\n2025-09-18 13:25:04 - zarr_info - INFO - pu/ds_ph_geo_pyramid/idx_6.zarr zarray shape, chunks, dtype: (20, 23), (256, 256), int64\n2025-09-18 13:25:04 - zarr_info - INFO - pu/ds_ph_geo_pyramid/idx_7.zarr zarray shape, chunks, dtype: (10, 12), (256, 256), int64\n2025-09-18 13:25:04 - zarr_info - INFO - pu/ds_ph_geo_pyramid/idx_8.zarr zarray shape, chunks, dtype: (5, 6), (256, 256), int64\n2025-09-18 13:25:04 - zarr_info - INFO - pu/ds_ph_geo_pyramid/idx_9.zarr zarray shape, chunks, dtype: (3, 3), (256, 256), int64\n2025-09-18 13:25:04 - zarr_info - INFO - pu/ds_ph_geo_pyramid/idx_10.zarr zarray shape, chunks, dtype: (2, 2), (256, 256), int64\n2025-09-18 13:25:04 - pc_pyramid - INFO - rasterized idx rendering ends\n2025-09-18 13:25:05 - pc_pyramid - INFO - dask local cluster started to render pc data.\n2025-09-18 13:25:05 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.4:8787/status', workers=1, threads=2, memory=256.00 GiB)\n2025-09-18 13:25:05 - zarr_info - INFO - pu/ds_ph_geo_pyramid/pc.zarr zarray shape, chunks, dtype: (293814, 17), (65536, 1), complex64\n2025-09-18 13:25:05 - zarr_info - INFO - pu/ds_ph_geo_pyramid/0.zarr zarray shape, chunks, dtype: (1259, 1418, 17), (256, 256, 1), complex64\n2025-09-18 13:25:05 - zarr_info - INFO - pu/ds_ph_geo_pyramid/1.zarr zarray shape, chunks, dtype: (630, 709, 17), (256, 256, 1), complex64\n2025-09-18 13:25:05 - zarr_info - INFO - pu/ds_ph_geo_pyramid/2.zarr zarray shape, chunks, dtype: (315, 355, 17), (256, 256, 1), complex64\n2025-09-18 13:25:05 - zarr_info - INFO - pu/ds_ph_geo_pyramid/3.zarr zarray shape, chunks, dtype: (158, 178, 17), (256, 256, 1), complex64\n2025-09-18 13:25:05 - zarr_info - INFO - pu/ds_ph_geo_pyramid/4.zarr zarray shape, chunks, dtype: (79, 89, 17), (256, 256, 1), complex64\n2025-09-18 13:25:05 - zarr_info - INFO - pu/ds_ph_geo_pyramid/5.zarr zarray shape, chunks, dtype: (40, 45, 17), (256, 256, 1), complex64\n2025-09-18 13:25:05 - zarr_info - INFO - pu/ds_ph_geo_pyramid/6.zarr zarray shape, chunks, dtype: (20, 23, 17), (256, 256, 1), complex64\n2025-09-18 13:25:05 - zarr_info - INFO - pu/ds_ph_geo_pyramid/7.zarr zarray shape, chunks, dtype: (10, 12, 17), (256, 256, 1), complex64\n2025-09-18 13:25:05 - zarr_info - INFO - pu/ds_ph_geo_pyramid/8.zarr zarray shape, chunks, dtype: (5, 6, 17), (256, 256, 1), complex64\n2025-09-18 13:25:05 - zarr_info - INFO - pu/ds_ph_geo_pyramid/9.zarr zarray shape, chunks, dtype: (3, 3, 17), (256, 256, 1), complex64\n2025-09-18 13:25:05 - zarr_info - INFO - pu/ds_ph_geo_pyramid/10.zarr zarray shape, chunks, dtype: (2, 2, 17), (256, 256, 1), complex64\n2025-09-18 13:25:05 - pc_pyramid - INFO - computing graph setted. doing all the computing.\n2025-09-18 13:25:06 - pc_pyramid - INFO - computing finished.  1.5s\n2025-09-18 13:25:06 - pc_pyramid - INFO - dask cluster closed.\n2025-09-18 13:25:06 - log_args - INFO - running function: pc_pyramid\n2025-09-18 13:25:06 - log_args - INFO - fetching args:\n2025-09-18 13:25:06 - log_args - INFO - pc = './pu/ds_unw.zarr'\n2025-09-18 13:25:06 - log_args - INFO - out_dir = './pu/ds_unw_geo_pyramid'\n2025-09-18 13:25:06 - log_args - INFO - x = './pu/ds_e.zarr/'\n2025-09-18 13:25:06 - log_args - INFO - y = './pu/ds_n.zarr/'\n2025-09-18 13:25:06 - log_args - INFO - yx = None\n2025-09-18 13:25:06 - log_args - INFO - ras_resolution = 20\n2025-09-18 13:25:06 - log_args - INFO - ras_chunks = (256, 256)\n2025-09-18 13:25:06 - log_args - INFO - pc_chunks = 65536\n2025-09-18 13:25:06 - log_args - INFO - processes = False\n2025-09-18 13:25:06 - log_args - INFO - n_workers = 1\n2025-09-18 13:25:06 - log_args - INFO - threads_per_worker = 2\n2025-09-18 13:25:06 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 13:25:06 - log_args - INFO - fetching args done.\n2025-09-18 13:25:06 - pc_pyramid - INFO - clean out dir\n2025-09-18 13:25:07 - zarr_info - INFO - ./pu/ds_unw.zarr zarray shape, chunks, dtype: (293814, 16), (200000, 1), float32\n2025-09-18 13:25:07 - pc_pyramid - INFO - rendering point cloud data coordinates:\n2025-09-18 13:25:07 - pc_pyramid - INFO - rasterizing point cloud data to grid with bounds: [np.float64(-16498471.798140068), np.float64(8649651.33657227), np.float64(-16470131.798140068), np.float64(8674811.33657227)].\n2025-09-18 13:25:07 - zarr_info - INFO - pu/ds_unw_geo_pyramid/x.zarr zarray shape, chunks, dtype: (293814,), (65536,), float64\n2025-09-18 13:25:07 - zarr_info - INFO - pu/ds_unw_geo_pyramid/y.zarr zarray shape, chunks, dtype: (293814,), (65536,), float64\n2025-09-18 13:25:07 - pc_pyramid - INFO - pc data coordinates rendering ends.\n2025-09-18 13:25:07 - zarr_info - INFO - pu/ds_unw_geo_pyramid/idx_0.zarr zarray shape, chunks, dtype: (1259, 1418), (256, 256), int64\n2025-09-18 13:25:07 - zarr_info - INFO - pu/ds_unw_geo_pyramid/idx_1.zarr zarray shape, chunks, dtype: (630, 709), (256, 256), int64\n2025-09-18 13:25:07 - zarr_info - INFO - pu/ds_unw_geo_pyramid/idx_2.zarr zarray shape, chunks, dtype: (315, 355), (256, 256), int64\n2025-09-18 13:25:07 - zarr_info - INFO - pu/ds_unw_geo_pyramid/idx_3.zarr zarray shape, chunks, dtype: (158, 178), (256, 256), int64\n2025-09-18 13:25:07 - zarr_info - INFO - pu/ds_unw_geo_pyramid/idx_4.zarr zarray shape, chunks, dtype: (79, 89), (256, 256), int64\n2025-09-18 13:25:07 - zarr_info - INFO - pu/ds_unw_geo_pyramid/idx_5.zarr zarray shape, chunks, dtype: (40, 45), (256, 256), int64\n2025-09-18 13:25:07 - zarr_info - INFO - pu/ds_unw_geo_pyramid/idx_6.zarr zarray shape, chunks, dtype: (20, 23), (256, 256), int64\n2025-09-18 13:25:07 - zarr_info - INFO - pu/ds_unw_geo_pyramid/idx_7.zarr zarray shape, chunks, dtype: (10, 12), (256, 256), int64\n2025-09-18 13:25:07 - zarr_info - INFO - pu/ds_unw_geo_pyramid/idx_8.zarr zarray shape, chunks, dtype: (5, 6), (256, 256), int64\n2025-09-18 13:25:07 - zarr_info - INFO - pu/ds_unw_geo_pyramid/idx_9.zarr zarray shape, chunks, dtype: (3, 3), (256, 256), int64\n2025-09-18 13:25:07 - zarr_info - INFO - pu/ds_unw_geo_pyramid/idx_10.zarr zarray shape, chunks, dtype: (2, 2), (256, 256), int64\n2025-09-18 13:25:07 - pc_pyramid - INFO - rasterized idx rendering ends\n2025-09-18 13:25:07 - pc_pyramid - INFO - dask local cluster started to render pc data.\n2025-09-18 13:25:07 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.4:8787/status', workers=1, threads=2, memory=256.00 GiB)\n2025-09-18 13:25:07 - zarr_info - INFO - pu/ds_unw_geo_pyramid/pc.zarr zarray shape, chunks, dtype: (293814, 16), (65536, 1), float32\n2025-09-18 13:25:07 - zarr_info - INFO - pu/ds_unw_geo_pyramid/0.zarr zarray shape, chunks, dtype: (1259, 1418, 16), (256, 256, 1), float32\n2025-09-18 13:25:07 - zarr_info - INFO - pu/ds_unw_geo_pyramid/1.zarr zarray shape, chunks, dtype: (630, 709, 16), (256, 256, 1), float32\n2025-09-18 13:25:07 - zarr_info - INFO - pu/ds_unw_geo_pyramid/2.zarr zarray shape, chunks, dtype: (315, 355, 16), (256, 256, 1), float32\n2025-09-18 13:25:07 - zarr_info - INFO - pu/ds_unw_geo_pyramid/3.zarr zarray shape, chunks, dtype: (158, 178, 16), (256, 256, 1), float32\n2025-09-18 13:25:07 - zarr_info - INFO - pu/ds_unw_geo_pyramid/4.zarr zarray shape, chunks, dtype: (79, 89, 16), (256, 256, 1), float32\n2025-09-18 13:25:07 - zarr_info - INFO - pu/ds_unw_geo_pyramid/5.zarr zarray shape, chunks, dtype: (40, 45, 16), (256, 256, 1), float32\n2025-09-18 13:25:07 - zarr_info - INFO - pu/ds_unw_geo_pyramid/6.zarr zarray shape, chunks, dtype: (20, 23, 16), (256, 256, 1), float32\n2025-09-18 13:25:07 - zarr_info - INFO - pu/ds_unw_geo_pyramid/7.zarr zarray shape, chunks, dtype: (10, 12, 16), (256, 256, 1), float32\n2025-09-18 13:25:07 - zarr_info - INFO - pu/ds_unw_geo_pyramid/8.zarr zarray shape, chunks, dtype: (5, 6, 16), (256, 256, 1), float32\n2025-09-18 13:25:07 - zarr_info - INFO - pu/ds_unw_geo_pyramid/9.zarr zarray shape, chunks, dtype: (3, 3, 16), (256, 256, 1), float32\n2025-09-18 13:25:07 - zarr_info - INFO - pu/ds_unw_geo_pyramid/10.zarr zarray shape, chunks, dtype: (2, 2, 16), (256, 256, 1), float32\n2025-09-18 13:25:08 - pc_pyramid - INFO - computing graph setted. doing all the computing.\n2025-09-18 13:25:10 - pc_pyramid - INFO - computing finished.  1.7s\n2025-09-18 13:25:10 - pc_pyramid - INFO - dask cluster closed.\n\n\n\nwith open('./raw/meta.toml','r') as f:\n    dates = toml.load(f)['dates']\nds_geo_intf_plot = mc.pc_plot('./pu/ds_ph_geo_pyramid',post_proc_ras='intf_seq', post_proc_pc='intf_seq',level_increase=0)\nds_geo_intf_plot = ds_geo_intf_plot.redim(\n    i=hv.Dimension('i', label='Intf index', range=(0,len(dates)-2), value_format=(lambda i: dates[i]+'_'+dates[i+1])),\n    x=hv.Dimension('lon', label='Longitude'),\n    y=hv.Dimension('lat',label='Latitude'),\n    z=hv.Dimension('Wrapped Phase',range=(-np.pi,np.pi))\n)\nds_geo_intf_plot = ds_geo_intf_plot.opts(\n    hv.opts.Image(\n        cmap='colorwheel',frame_width=500, frame_height=400, colorbar=True,\n        default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],\n        active_tools=['wheel_zoom'],\n        title=\"Wrapped Phase\",\n    ),\n    hv.opts.Points(\n        color='Wrapped Phase', cmap='colorwheel',frame_width=500, frame_height=400, colorbar=True,\n        default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],\n        active_tools=['wheel_zoom'],\n        title=\"Wrapped Phase\",\n    ),\n)\n\nds_geo_unw_plot = mc.pc_plot('./pu/ds_unw_geo_pyramid',level_increase=0)\nds_geo_unw_plot = ds_geo_unw_plot.redim(\n    i=hv.Dimension('i', label='Intf index', range=(0,len(dates)-2), value_format=(lambda i: dates[i]+'_'+dates[i+1])),\n    x=hv.Dimension('lon', label='Longitude'),\n    y=hv.Dimension('lat',label='Latitude'),\n    z=hv.Dimension('Unwrapped Phase',range=(-10,10))\n)\nds_geo_unw_plot = ds_geo_unw_plot.opts(\n    hv.opts.Image(\n        cmap='colorwheel',frame_width=500, frame_height=400, colorbar=True,\n        default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],\n        active_tools=['wheel_zoom'],\n        title=\"Unwrapped Phase\",\n    ),\n    hv.opts.Points(\n        color='Unwrapped Phase', cmap='colorwheel',frame_width=500, frame_height=400, colorbar=True,\n        default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],\n        active_tools=['wheel_zoom'],\n        title=\"Unwrapped Phase\",\n    ),\n)\n\n\nhv.element.tiles.EsriImagery()*(ds_geo_intf_plot+ds_geo_unw_plot)",
    "crumbs": [
      "CLI",
      "Phase Unwrapping"
    ]
  },
  {
    "objectID": "CLI/ps.html",
    "href": "CLI/ps.html",
    "title": "ps",
    "section": "",
    "text": "import zarr\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport colorcet\nimport moraine.cli as mc\nfrom moraine.utils_ import is_cuda_available\n\n\nsource\n\namp_disp\n\n amp_disp (rslc:str, adi:str, chunks:tuple[int,int]=None,\n           out_chunks:tuple[int,int]=None, cuda:bool=False,\n           processes=None, n_workers=None, threads_per_worker=None,\n           rmm_pool_size=0.9, **dask_cluster_arg)\n\ncalculation the amplitude dispersion index from SLC stack.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nrslc\nstr\n\nrslc stack\n\n\nadi\nstr\n\noutput, amplitude dispersion index\n\n\nchunks\ntuple\nNone\ndata processing chunk size, same as rslc by default\n\n\nout_chunks\ntuple\nNone\noutput data chunk size, same as chunks by default\n\n\ncuda\nbool\nFalse\nif use cuda for processing, false by default\n\n\nprocesses\nNoneType\nNone\nuse process for dask worker over thread, the default is False for cpu, only applied if cuda==False\n\n\nn_workers\nNoneType\nNone\nnumber of dask worker, the default is 1 for cpu, number of GPU for cuda\n\n\nthreads_per_worker\nNoneType\nNone\nnumber of threads per dask worker, the default is 1 for cpu, only applied if cuda==False\n\n\nrmm_pool_size\nfloat\n0.9\nset the rmm pool size, only applied when cuda==True\n\n\ndask_cluster_arg\nVAR_KEYWORD\n\n\n\n\n\nUsing amplitude dispersion index (ADI) to identify persistent scatterers is first used in (Ferretti, Prati, and Rocca Jan./2001).\n\nFerretti, A., C. Prati, and F. Rocca. Jan./2001. “Permanent Scatterers in SAR Interferometry.” IEEE Transactions on Geoscience and Remote Sensing 39 (1): 8–20. https://doi.org/10.1109/36.898661.\nUsage:\n\nrslc = './raw/rslc.zarr'\nadi = './ps/adi.zarr'\n\n\nlogger = mc.get_logger()\n\n\namp_disp(rslc,adi)\n\n2025-09-18 12:30:08 - log_args - INFO - running function: amp_disp\n2025-09-18 12:30:08 - log_args - INFO - fetching args:\n2025-09-18 12:30:08 - log_args - INFO - rslc = './raw/rslc.zarr'\n2025-09-18 12:30:08 - log_args - INFO - adi = './ps/adi.zarr'\n2025-09-18 12:30:08 - log_args - INFO - chunks = None\n2025-09-18 12:30:08 - log_args - INFO - out_chunks = None\n2025-09-18 12:30:08 - log_args - INFO - cuda = False\n2025-09-18 12:30:08 - log_args - INFO - processes = None\n2025-09-18 12:30:08 - log_args - INFO - n_workers = None\n2025-09-18 12:30:08 - log_args - INFO - threads_per_worker = None\n2025-09-18 12:30:08 - log_args - INFO - rmm_pool_size = 0.9\n2025-09-18 12:30:08 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 12:30:08 - log_args - INFO - fetching args done.\n2025-09-18 12:30:08 - zarr_info - INFO - ./raw/rslc.zarr zarray shape, chunks, dtype: (2500, 1834, 17), (1000, 1000, 1), complex64\n2025-09-18 12:30:08 - amp_disp - INFO - starting dask local cluster.\n2025-09-18 12:30:10 - amp_disp - INFO - dask local cluster started.\n2025-09-18 12:30:10 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.4:8787/status', workers=1, threads=1, memory=256.00 GiB)\n2025-09-18 12:30:10 - darr_info - INFO - rslc dask array shape, chunksize, dtype: (2500, 1834, 17), (1000, 1000, 17), complex64\n2025-09-18 12:30:10 - amp_disp - INFO - calculate amplitude dispersion index.\n2025-09-18 12:30:10 - amp_disp - INFO - got amplitude dispersion index.\n2025-09-18 12:30:10 - darr_info - INFO - adi dask array shape, chunksize, dtype: (2500, 1834), (1000, 1000), float32\n2025-09-18 12:30:10 - darr_info - INFO - adi dask array shape, chunksize, dtype: (2500, 1834), (1000, 1000), float32\n2025-09-18 12:30:10 - amp_disp - INFO - saving adi.\n2025-09-18 12:30:10 - zarr_info - INFO - ./ps/adi.zarr zarray shape, chunks, dtype: (2500, 1834), (1000, 1000), float32\n2025-09-18 12:30:10 - amp_disp - INFO - computing graph setted. doing all the computing.\n2025-09-18 12:30:12 - amp_disp - INFO - computing finished. |  2.2s\n2025-09-18 12:30:12 - amp_disp - INFO - dask cluster closed.\n\n\n\nif is_cuda_available:\n    amp_disp(rslc,adi,cuda=True)\n\n2025-09-18 12:30:12 - log_args - INFO - running function: amp_disp\n2025-09-18 12:30:12 - log_args - INFO - fetching args:\n2025-09-18 12:30:12 - log_args - INFO - rslc = './raw/rslc.zarr'\n2025-09-18 12:30:12 - log_args - INFO - adi = './ps/adi.zarr'\n2025-09-18 12:30:12 - log_args - INFO - chunks = None\n2025-09-18 12:30:12 - log_args - INFO - out_chunks = None\n2025-09-18 12:30:12 - log_args - INFO - cuda = True\n2025-09-18 12:30:12 - log_args - INFO - processes = None\n2025-09-18 12:30:12 - log_args - INFO - n_workers = None\n2025-09-18 12:30:12 - log_args - INFO - threads_per_worker = None\n2025-09-18 12:30:12 - log_args - INFO - rmm_pool_size = 0.9\n2025-09-18 12:30:12 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 12:30:12 - log_args - INFO - fetching args done.\n2025-09-18 12:30:12 - zarr_info - INFO - ./raw/rslc.zarr zarray shape, chunks, dtype: (2500, 1834, 17), (1000, 1000, 1), complex64\n2025-09-18 12:30:12 - amp_disp - INFO - starting dask local cluster.\n\n\n2025-09-18 12:30:14,589 - distributed.worker - WARNING - Setting CPU affinity for GPU failed. Please refer to the following link for troubleshooting information: https://docs.rapids.ai/api/dask-cuda/nightly/troubleshooting/#setting-cpu-affinity-failure\n2025-09-18 12:30:14,600 - distributed.worker - WARNING - Setting CPU affinity for GPU failed. Please refer to the following link for troubleshooting information: https://docs.rapids.ai/api/dask-cuda/nightly/troubleshooting/#setting-cpu-affinity-failure\n\n\n2025-09-18 12:30:15 - amp_disp - INFO - dask local cluster started.\n2025-09-18 12:30:15 - dask_cluster_info - INFO - dask cluster: LocalCUDACluster(dashboard_link='http://127.0.0.1:8787/status', workers=2, threads=2, memory=256.00 GiB)\n2025-09-18 12:30:15 - darr_info - INFO - rslc dask array shape, chunksize, dtype: (2500, 1834, 17), (1000, 1000, 17), complex64\n2025-09-18 12:30:15 - amp_disp - INFO - calculate amplitude dispersion index.\n2025-09-18 12:30:15 - amp_disp - INFO - got amplitude dispersion index.\n2025-09-18 12:30:15 - darr_info - INFO - adi dask array shape, chunksize, dtype: (2500, 1834), (1000, 1000), float32\n2025-09-18 12:30:15 - darr_info - INFO - adi dask array shape, chunksize, dtype: (2500, 1834), (1000, 1000), float32\n2025-09-18 12:30:15 - amp_disp - INFO - saving adi.\n2025-09-18 12:30:15 - zarr_info - INFO - ./ps/adi.zarr zarray shape, chunks, dtype: (2500, 1834), (1000, 1000), float32\n2025-09-18 12:30:15 - amp_disp - INFO - computing graph setted. doing all the computing.\n2025-09-18 12:30:17 - amp_disp - INFO - computing finished. |  1.6s\n2025-09-18 12:30:17 - amp_disp - INFO - dask cluster closed.\n\n\n\nadi = zarr.open('./ps/adi.zarr/',mode='r')[:]\n\n\nfig, ax = plt.subplots(1,1,figsize=(10,10))\npcm = ax.imshow(adi,vmin=0,vmax=1)\nax.set(title='Amplitude Dispersion Index',xlabel='Range Index',ylabel='Azimuth Index')\nfig.colorbar(pcm)\nfig.show()\n\n\n\n\n\n\n\n\nWe can then select PS candidate according to adi:\n\nps_can_gix = './ps/ps_can_gix.zarr'\nmc.pc_logic_ras('./ps/adi.zarr/',ps_can_gix,'(ras&gt;=0)&(ras&lt;=0.3)')\nmc.ras2pc(\n    ps_can_gix, \n    ['raw/rslc.zarr', 'ps/adi.zarr',  'transform/e.zarr', 'transform/n.zarr'],\n    ['ps/ps_can_rslc.zarr', 'ps/ps_can_adi.zarr',  'ps/ps_can_e.zarr', 'ps/ps_can_n.zarr'],\n)\n\n2025-09-18 12:30:19 - log_args - INFO - running function: pc_logic_ras\n2025-09-18 12:30:19 - log_args - INFO - fetching args:\n2025-09-18 12:30:19 - log_args - INFO - ras = './ps/adi.zarr/'\n2025-09-18 12:30:19 - log_args - INFO - gix = './ps/ps_can_gix.zarr'\n2025-09-18 12:30:19 - log_args - INFO - operation = '(ras&gt;=0)&(ras&lt;=0.3)'\n2025-09-18 12:30:19 - log_args - INFO - chunks = 100000\n2025-09-18 12:30:19 - log_args - INFO - fetching args done.\n2025-09-18 12:30:19 - zarr_info - INFO - ./ps/adi.zarr/ zarray shape, chunks, dtype: (2500, 1834), (1000, 1000), float32\n2025-09-18 12:30:19 - pc_logic_ras - INFO - loading ras into memory.\n2025-09-18 12:30:19 - pc_logic_ras - INFO - select pc based on operation: (ras&gt;=0)&(ras&lt;=0.3)\n2025-09-18 12:30:19 - pc_logic_ras - INFO - number of selected pixels: 43201.\n2025-09-18 12:30:19 - zarr_info - INFO - ./ps/ps_can_gix.zarr zarray shape, chunks, dtype: (43201, 2), (100000, 1), int32\n2025-09-18 12:30:19 - pc_logic_ras - INFO - writing gix.\n2025-09-18 12:30:19 - pc_logic_ras - INFO - write done.\n2025-09-18 12:30:19 - log_args - INFO - running function: ras2pc\n2025-09-18 12:30:19 - log_args - INFO - fetching args:\n2025-09-18 12:30:19 - log_args - INFO - idx = './ps/ps_can_gix.zarr'\n2025-09-18 12:30:19 - log_args - INFO - ras = ['raw/rslc.zarr', 'ps/adi.zarr', 'transform/e.zarr', 'transform/n.zarr']\n2025-09-18 12:30:19 - log_args - INFO - pc = ['ps/ps_can_rslc.zarr', 'ps/ps_can_adi.zarr', 'ps/ps_can_e.zarr', 'ps/ps_can_n.zarr']\n2025-09-18 12:30:19 - log_args - INFO - chunks = None\n2025-09-18 12:30:19 - log_args - INFO - processes = False\n2025-09-18 12:30:19 - log_args - INFO - n_workers = 1\n2025-09-18 12:30:19 - log_args - INFO - threads_per_worker = 1\n2025-09-18 12:30:19 - log_args - INFO - dask_cluster_arg = {}\n2025-09-18 12:30:19 - log_args - INFO - fetching args done.\n2025-09-18 12:30:19 - zarr_info - INFO - ./ps/ps_can_gix.zarr zarray shape, chunks, dtype: (43201, 2), (100000, 1), int32\n2025-09-18 12:30:19 - ras2pc - INFO - loading gix into memory.\n2025-09-18 12:30:19 - ras2pc - INFO - starting dask local cluster.\n2025-09-18 12:30:19 - ras2pc - INFO - dask local cluster started.\n2025-09-18 12:30:19 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.4:8787/status', workers=1, threads=1, memory=256.00 GiB)\n2025-09-18 12:30:19 - ras2pc - INFO - start to slice on raw/rslc.zarr\n2025-09-18 12:30:19 - zarr_info - INFO - raw/rslc.zarr zarray shape, chunks, dtype: (2500, 1834, 17), (1000, 1000, 1), complex64\n2025-09-18 12:30:19 - darr_info - INFO - ras dask array shape, chunksize, dtype: (2500, 1834, 17), (2500, 1834, 1), complex64\n2025-09-18 12:30:19 - darr_info - INFO - pc dask array shape, chunksize, dtype: (43201, 17), (43201, 1), complex64\n2025-09-18 12:30:19 - ras2pc - INFO - saving to ps/ps_can_rslc.zarr.\n2025-09-18 12:30:19 - zarr_info - INFO - ps/ps_can_rslc.zarr zarray shape, chunks, dtype: (43201, 17), (100000, 1), complex64\n2025-09-18 12:30:19 - ras2pc - INFO - start to slice on ps/adi.zarr\n2025-09-18 12:30:19 - zarr_info - INFO - ps/adi.zarr zarray shape, chunks, dtype: (2500, 1834), (1000, 1000), float32\n2025-09-18 12:30:19 - darr_info - INFO - ras dask array shape, chunksize, dtype: (2500, 1834), (2500, 1834), float32\n2025-09-18 12:30:19 - darr_info - INFO - pc dask array shape, chunksize, dtype: (43201,), (43201,), float32\n2025-09-18 12:30:19 - ras2pc - INFO - saving to ps/ps_can_adi.zarr.\n2025-09-18 12:30:19 - zarr_info - INFO - ps/ps_can_adi.zarr zarray shape, chunks, dtype: (43201,), (100000,), float32\n2025-09-18 12:30:19 - ras2pc - INFO - start to slice on transform/e.zarr\n2025-09-18 12:30:19 - zarr_info - INFO - transform/e.zarr zarray shape, chunks, dtype: (2500, 1834), (1000, 1000), float64\n2025-09-18 12:30:19 - darr_info - INFO - ras dask array shape, chunksize, dtype: (2500, 1834), (2500, 1834), float64\n2025-09-18 12:30:19 - darr_info - INFO - pc dask array shape, chunksize, dtype: (43201,), (43201,), float64\n2025-09-18 12:30:19 - ras2pc - INFO - saving to ps/ps_can_e.zarr.\n2025-09-18 12:30:19 - zarr_info - INFO - ps/ps_can_e.zarr zarray shape, chunks, dtype: (43201,), (100000,), float64\n2025-09-18 12:30:19 - ras2pc - INFO - start to slice on transform/n.zarr\n2025-09-18 12:30:19 - zarr_info - INFO - transform/n.zarr zarray shape, chunks, dtype: (2500, 1834), (1000, 1000), float64\n2025-09-18 12:30:19 - darr_info - INFO - ras dask array shape, chunksize, dtype: (2500, 1834), (2500, 1834), float64\n2025-09-18 12:30:19 - darr_info - INFO - pc dask array shape, chunksize, dtype: (43201,), (43201,), float64\n2025-09-18 12:30:19 - ras2pc - INFO - saving to ps/ps_can_n.zarr.\n2025-09-18 12:30:19 - zarr_info - INFO - ps/ps_can_n.zarr zarray shape, chunks, dtype: (43201,), (100000,), float64\n2025-09-18 12:30:19 - ras2pc - INFO - computing graph setted. doing all the computing.\n2025-09-18 12:30:20 - ras2pc - INFO - computing finished.ed |  0.9s\n2025-09-18 12:30:20 - ras2pc - INFO - dask cluster closed.",
    "crumbs": [
      "CLI",
      "ps"
    ]
  },
  {
    "objectID": "Tutorials/CLI/load_data.html",
    "href": "Tutorials/CLI/load_data.html",
    "title": "Load Data",
    "section": "",
    "text": "Currently, only interface to the GAMMA software is porvided.",
    "crumbs": [
      "Tutorials",
      "CLI",
      "Load Data"
    ]
  },
  {
    "objectID": "Tutorials/CLI/load_data.html#load-gamma-result",
    "href": "Tutorials/CLI/load_data.html#load-gamma-result",
    "title": "Load Data",
    "section": "Load GAMMA result",
    "text": "Load GAMMA result\nThe data from gamma software needed for this tutorial:\n\n!ls -R ../../../data/gamma/\n\n../../../data/gamma/:\nDEM  geocoding  rslc\n\n../../../data/gamma/DEM:\ndem_seg  dem_seg_par\n\n../../../data/gamma/geocoding:\n20210802.diff_par  20210802.lt_fine  20210802.lv_theta\n20210802.hgt       20210802.lv_phi\n\n../../../data/gamma/rslc:\n20210802.rslc      20211011.rslc.par  20220718.rslc  20220912.rslc.par\n20210802.rslc.par  20211025.rslc      20220718.rslc.par  20220926.rslc\n20210816.rslc      20211025.rslc.par  20220801.rslc  20220926.rslc.par\n20210816.rslc.par  20220606.rslc      20220801.rslc.par  20221010.rslc\n20210830.rslc      20220606.rslc.par  20220815.rslc  20221010.rslc.par\n20210830.rslc.par  20220620.rslc      20220815.rslc.par  20221024.rslc\n20210913.rslc      20220620.rslc.par  20220829.rslc  20221024.rslc.par\n20210913.rslc.par  20220704.rslc      20220829.rslc.par\n20211011.rslc      20220704.rslc.par  20220912.rslc\n\n\nImport Moraine:\n\nimport moraine.cli as mc\n\n\nlogger = mc.get_logger()\n\n\nrslc_dir = '../../../data/gamma/rslc'\nreference = '20220620'\nrslc_par = '../../../data/gamma/rslc/20220620.rslc.par'\nhgt = '../../../data/gamma/geocoding/20210802.hgt'\nlt = '../../../data/gamma/geocoding/20210802.lt_fine'\ndiff_par = '../../../data/gamma/geocoding/20210802.diff_par'\ndem_par = '../../../data/gamma/DEM/dem_seg_par'\ntheta = '../../../data/gamma/geocoding/20210802.lv_theta'\nphi = '../../../data/gamma/geocoding/20210802.lv_phi'\n\nscratch_dir = './load_data/scratch'\nrslc_zarr = './load_data/rslc.zarr'\nlat_zarr = './load_data/lat.zarr'\nlon_zarr = './load_data/lon.zarr'\ntheta_zarr = './load_data/theta.zarr'\nphi_zarr = './load_data/phi.zarr'\nhgt_zarr = './load_data/hgt.zarr'\nrange_zarr = './load_data/range.zarr'\nmeta_file = './load_data/meta.toml'\n\n\n!mkdir load_data\n!mkdir load_data/scratch\n\nmkdir: cannot create directory ‘load_data’: File exists\nmkdir: cannot create directory ‘load_data/scratch’: File exists\n\n\n\nmc.load_gamma_flatten_rslc(rslc_dir,reference,hgt,scratch_dir,rslc_zarr,chunks=(1000,1000))\nmc.load_gamma_lat_lon_hgt(diff_par,rslc_par,dem_par,hgt,scratch_dir,lat_zarr,lon_zarr,hgt_zarr,chunks=(1000,1000))\nmc.load_gamma_look_vector(theta,phi,lt,rslc_par,dem_par,scratch_dir,theta_zarr,phi_zarr,chunks=(1000,1000))\nmc.load_gamma_range(rslc_par,range_zarr,chunks=(1000,1000))\nmc.load_gamma_metadata(rslc_dir,dem_par,reference,meta_file)\n\n2025-09-20 22:56:17 - log_args - INFO - running function: load_gamma_flatten_rslc\n2025-09-20 22:56:17 - log_args - INFO - fetching args:\n2025-09-20 22:56:17 - log_args - INFO - rslc_dir = '../../../data/gamma/rslc'\n2025-09-20 22:56:17 - log_args - INFO - reference = '20220620'\n2025-09-20 22:56:17 - log_args - INFO - hgt = '../../../data/gamma/geocoding/20210802.hgt'\n2025-09-20 22:56:17 - log_args - INFO - scratch_dir = './load_data/scratch'\n2025-09-20 22:56:17 - log_args - INFO - rslc = './load_data/rslc.zarr'\n2025-09-20 22:56:17 - log_args - INFO - chunks = (1000, 1000)\n2025-09-20 22:56:17 - log_args - INFO - processes = False\n2025-09-20 22:56:17 - log_args - INFO - n_workers = 1\n2025-09-20 22:56:17 - log_args - INFO - threads_per_worker = 1\n2025-09-20 22:56:17 - log_args - INFO - dask_cluster_arg = {}\n2025-09-20 22:56:17 - log_args - INFO - fetching args done.\n2025-09-20 22:56:17 - load_gamma_flatten_rslc - INFO - rslc found: \n        date                                    rslc  \\\n0   20210802  ../../../data/gamma/rslc/20210802.rslc   \n1   20210816  ../../../data/gamma/rslc/20210816.rslc   \n2   20210830  ../../../data/gamma/rslc/20210830.rslc   \n3   20210913  ../../../data/gamma/rslc/20210913.rslc   \n4   20211011  ../../../data/gamma/rslc/20211011.rslc   \n5   20211025  ../../../data/gamma/rslc/20211025.rslc   \n6   20220606  ../../../data/gamma/rslc/20220606.rslc   \n7   20220620  ../../../data/gamma/rslc/20220620.rslc   \n8   20220704  ../../../data/gamma/rslc/20220704.rslc   \n9   20220718  ../../../data/gamma/rslc/20220718.rslc   \n10  20220801  ../../../data/gamma/rslc/20220801.rslc   \n11  20220815  ../../../data/gamma/rslc/20220815.rslc   \n12  20220829  ../../../data/gamma/rslc/20220829.rslc   \n13  20220912  ../../../data/gamma/rslc/20220912.rslc   \n14  20220926  ../../../data/gamma/rslc/20220926.rslc   \n15  20221010  ../../../data/gamma/rslc/20221010.rslc   \n16  20221024  ../../../data/gamma/rslc/20221024.rslc   \n\n                                           par  \n0   ../../../data/gamma/rslc/20210802.rslc.par  \n1   ../../../data/gamma/rslc/20210816.rslc.par  \n2   ../../../data/gamma/rslc/20210830.rslc.par  \n3   ../../../data/gamma/rslc/20210913.rslc.par  \n4   ../../../data/gamma/rslc/20211011.rslc.par  \n5   ../../../data/gamma/rslc/20211025.rslc.par  \n6   ../../../data/gamma/rslc/20220606.rslc.par  \n7   ../../../data/gamma/rslc/20220620.rslc.par  \n8   ../../../data/gamma/rslc/20220704.rslc.par  \n9   ../../../data/gamma/rslc/20220718.rslc.par  \n10  ../../../data/gamma/rslc/20220801.rslc.par  \n11  ../../../data/gamma/rslc/20220815.rslc.par  \n12  ../../../data/gamma/rslc/20220829.rslc.par  \n13  ../../../data/gamma/rslc/20220912.rslc.par  \n14  ../../../data/gamma/rslc/20220926.rslc.par  \n15  ../../../data/gamma/rslc/20221010.rslc.par  \n16  ../../../data/gamma/rslc/20221024.rslc.par  \n2025-09-20 22:56:17 - load_gamma_flatten_rslc - INFO - number of images: 17.\n2025-09-20 22:56:17 - load_gamma_flatten_rslc - INFO - image number of lines: 2500.\n2025-09-20 22:56:17 - load_gamma_flatten_rslc - INFO - image width: 1834.\n2025-09-20 22:56:17 - load_gamma_flatten_rslc - INFO - run gamma command to generate required data for flattened rslcs:\n2025-09-20 22:56:17 - load_gamma_flatten_rslc - INFO - run command: create_offset ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20210802.rslc.par load_data/scratch/20220620_20210802.off 1 1 1 0 &gt;&gt; load_data/scratch/gamma.log\n2025-09-20 22:56:17 - load_gamma_flatten_rslc - INFO - load_data/scratch/20220620_20210802.sim_orb exists. skip runing phase_sim_orb ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20210802.rslc.par load_data/scratch/20220620_20210802.off ../../../data/gamma/geocoding/20210802.hgt load_data/scratch/20220620_20210802.sim_orb ../../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; load_data/scratch/gamma.log\n2025-09-20 22:56:17 - load_gamma_flatten_rslc - INFO - run command: create_offset ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20210816.rslc.par load_data/scratch/20220620_20210816.off 1 1 1 0 &gt;&gt; load_data/scratch/gamma.log\n2025-09-20 22:56:17 - load_gamma_flatten_rslc - INFO - load_data/scratch/20220620_20210816.sim_orb exists. skip runing phase_sim_orb ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20210816.rslc.par load_data/scratch/20220620_20210816.off ../../../data/gamma/geocoding/20210802.hgt load_data/scratch/20220620_20210816.sim_orb ../../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; load_data/scratch/gamma.log\n2025-09-20 22:56:17 - load_gamma_flatten_rslc - INFO - run command: create_offset ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20210830.rslc.par load_data/scratch/20220620_20210830.off 1 1 1 0 &gt;&gt; load_data/scratch/gamma.log\n2025-09-20 22:56:18 - load_gamma_flatten_rslc - INFO - load_data/scratch/20220620_20210830.sim_orb exists. skip runing phase_sim_orb ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20210830.rslc.par load_data/scratch/20220620_20210830.off ../../../data/gamma/geocoding/20210802.hgt load_data/scratch/20220620_20210830.sim_orb ../../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; load_data/scratch/gamma.log\n2025-09-20 22:56:18 - load_gamma_flatten_rslc - INFO - run command: create_offset ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20210913.rslc.par load_data/scratch/20220620_20210913.off 1 1 1 0 &gt;&gt; load_data/scratch/gamma.log\n2025-09-20 22:56:18 - load_gamma_flatten_rslc - INFO - load_data/scratch/20220620_20210913.sim_orb exists. skip runing phase_sim_orb ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20210913.rslc.par load_data/scratch/20220620_20210913.off ../../../data/gamma/geocoding/20210802.hgt load_data/scratch/20220620_20210913.sim_orb ../../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; load_data/scratch/gamma.log\n2025-09-20 22:56:18 - load_gamma_flatten_rslc - INFO - run command: create_offset ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20211011.rslc.par load_data/scratch/20220620_20211011.off 1 1 1 0 &gt;&gt; load_data/scratch/gamma.log\n2025-09-20 22:56:18 - load_gamma_flatten_rslc - INFO - load_data/scratch/20220620_20211011.sim_orb exists. skip runing phase_sim_orb ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20211011.rslc.par load_data/scratch/20220620_20211011.off ../../../data/gamma/geocoding/20210802.hgt load_data/scratch/20220620_20211011.sim_orb ../../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; load_data/scratch/gamma.log\n2025-09-20 22:56:18 - load_gamma_flatten_rslc - INFO - run command: create_offset ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20211025.rslc.par load_data/scratch/20220620_20211025.off 1 1 1 0 &gt;&gt; load_data/scratch/gamma.log\n2025-09-20 22:56:18 - load_gamma_flatten_rslc - INFO - load_data/scratch/20220620_20211025.sim_orb exists. skip runing phase_sim_orb ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20211025.rslc.par load_data/scratch/20220620_20211025.off ../../../data/gamma/geocoding/20210802.hgt load_data/scratch/20220620_20211025.sim_orb ../../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; load_data/scratch/gamma.log\n2025-09-20 22:56:18 - load_gamma_flatten_rslc - INFO - run command: create_offset ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20220606.rslc.par load_data/scratch/20220620_20220606.off 1 1 1 0 &gt;&gt; load_data/scratch/gamma.log\n2025-09-20 22:56:18 - load_gamma_flatten_rslc - INFO - load_data/scratch/20220620_20220606.sim_orb exists. skip runing phase_sim_orb ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20220606.rslc.par load_data/scratch/20220620_20220606.off ../../../data/gamma/geocoding/20210802.hgt load_data/scratch/20220620_20220606.sim_orb ../../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; load_data/scratch/gamma.log\n2025-09-20 22:56:18 - load_gamma_flatten_rslc - INFO - run command: create_offset ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20220620.rslc.par load_data/scratch/20220620_20220620.off 1 1 1 0 &gt;&gt; load_data/scratch/gamma.log\n2025-09-20 22:56:18 - load_gamma_flatten_rslc - INFO - load_data/scratch/20220620_20220620.sim_orb exists. skip runing phase_sim_orb ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20220620.rslc.par load_data/scratch/20220620_20220620.off ../../../data/gamma/geocoding/20210802.hgt load_data/scratch/20220620_20220620.sim_orb ../../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; load_data/scratch/gamma.log\n2025-09-20 22:56:18 - load_gamma_flatten_rslc - INFO - run command: create_offset ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20220704.rslc.par load_data/scratch/20220620_20220704.off 1 1 1 0 &gt;&gt; load_data/scratch/gamma.log\n2025-09-20 22:56:18 - load_gamma_flatten_rslc - INFO - load_data/scratch/20220620_20220704.sim_orb exists. skip runing phase_sim_orb ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20220704.rslc.par load_data/scratch/20220620_20220704.off ../../../data/gamma/geocoding/20210802.hgt load_data/scratch/20220620_20220704.sim_orb ../../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; load_data/scratch/gamma.log\n2025-09-20 22:56:18 - load_gamma_flatten_rslc - INFO - run command: create_offset ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20220718.rslc.par load_data/scratch/20220620_20220718.off 1 1 1 0 &gt;&gt; load_data/scratch/gamma.log\n2025-09-20 22:56:18 - load_gamma_flatten_rslc - INFO - load_data/scratch/20220620_20220718.sim_orb exists. skip runing phase_sim_orb ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20220718.rslc.par load_data/scratch/20220620_20220718.off ../../../data/gamma/geocoding/20210802.hgt load_data/scratch/20220620_20220718.sim_orb ../../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; load_data/scratch/gamma.log\n2025-09-20 22:56:18 - load_gamma_flatten_rslc - INFO - run command: create_offset ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20220801.rslc.par load_data/scratch/20220620_20220801.off 1 1 1 0 &gt;&gt; load_data/scratch/gamma.log\n2025-09-20 22:56:18 - load_gamma_flatten_rslc - INFO - load_data/scratch/20220620_20220801.sim_orb exists. skip runing phase_sim_orb ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20220801.rslc.par load_data/scratch/20220620_20220801.off ../../../data/gamma/geocoding/20210802.hgt load_data/scratch/20220620_20220801.sim_orb ../../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; load_data/scratch/gamma.log\n2025-09-20 22:56:18 - load_gamma_flatten_rslc - INFO - run command: create_offset ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20220815.rslc.par load_data/scratch/20220620_20220815.off 1 1 1 0 &gt;&gt; load_data/scratch/gamma.log\n2025-09-20 22:56:18 - load_gamma_flatten_rslc - INFO - load_data/scratch/20220620_20220815.sim_orb exists. skip runing phase_sim_orb ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20220815.rslc.par load_data/scratch/20220620_20220815.off ../../../data/gamma/geocoding/20210802.hgt load_data/scratch/20220620_20220815.sim_orb ../../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; load_data/scratch/gamma.log\n2025-09-20 22:56:18 - load_gamma_flatten_rslc - INFO - run command: create_offset ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20220829.rslc.par load_data/scratch/20220620_20220829.off 1 1 1 0 &gt;&gt; load_data/scratch/gamma.log\n2025-09-20 22:56:18 - load_gamma_flatten_rslc - INFO - load_data/scratch/20220620_20220829.sim_orb exists. skip runing phase_sim_orb ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20220829.rslc.par load_data/scratch/20220620_20220829.off ../../../data/gamma/geocoding/20210802.hgt load_data/scratch/20220620_20220829.sim_orb ../../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; load_data/scratch/gamma.log\n2025-09-20 22:56:18 - load_gamma_flatten_rslc - INFO - run command: create_offset ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20220912.rslc.par load_data/scratch/20220620_20220912.off 1 1 1 0 &gt;&gt; load_data/scratch/gamma.log\n2025-09-20 22:56:18 - load_gamma_flatten_rslc - INFO - load_data/scratch/20220620_20220912.sim_orb exists. skip runing phase_sim_orb ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20220912.rslc.par load_data/scratch/20220620_20220912.off ../../../data/gamma/geocoding/20210802.hgt load_data/scratch/20220620_20220912.sim_orb ../../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; load_data/scratch/gamma.log\n2025-09-20 22:56:18 - load_gamma_flatten_rslc - INFO - run command: create_offset ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20220926.rslc.par load_data/scratch/20220620_20220926.off 1 1 1 0 &gt;&gt; load_data/scratch/gamma.log\n2025-09-20 22:56:18 - load_gamma_flatten_rslc - INFO - load_data/scratch/20220620_20220926.sim_orb exists. skip runing phase_sim_orb ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20220926.rslc.par load_data/scratch/20220620_20220926.off ../../../data/gamma/geocoding/20210802.hgt load_data/scratch/20220620_20220926.sim_orb ../../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; load_data/scratch/gamma.log\n2025-09-20 22:56:18 - load_gamma_flatten_rslc - INFO - run command: create_offset ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20221010.rslc.par load_data/scratch/20220620_20221010.off 1 1 1 0 &gt;&gt; load_data/scratch/gamma.log\n2025-09-20 22:56:18 - load_gamma_flatten_rslc - INFO - load_data/scratch/20220620_20221010.sim_orb exists. skip runing phase_sim_orb ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20221010.rslc.par load_data/scratch/20220620_20221010.off ../../../data/gamma/geocoding/20210802.hgt load_data/scratch/20220620_20221010.sim_orb ../../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; load_data/scratch/gamma.log\n2025-09-20 22:56:18 - load_gamma_flatten_rslc - INFO - run command: create_offset ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20221024.rslc.par load_data/scratch/20220620_20221024.off 1 1 1 0 &gt;&gt; load_data/scratch/gamma.log\n2025-09-20 22:56:19 - load_gamma_flatten_rslc - INFO - load_data/scratch/20220620_20221024.sim_orb exists. skip runing phase_sim_orb ../../../data/gamma/rslc/20220620.rslc.par ../../../data/gamma/rslc/20221024.rslc.par load_data/scratch/20220620_20221024.off ../../../data/gamma/geocoding/20210802.hgt load_data/scratch/20220620_20221024.sim_orb ../../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt;&gt; load_data/scratch/gamma.log\n2025-09-20 22:56:19 - load_gamma_flatten_rslc - INFO - gamma command finished.\n2025-09-20 22:56:19 - load_gamma_flatten_rslc - INFO - using dask to load data in gamma binary format to calculate flatten rslcs and save it to zarr.\n2025-09-20 22:56:19 - load_gamma_flatten_rslc - INFO - starting dask local cluster.\n2025-09-20 22:56:24 - load_gamma_flatten_rslc - INFO - dask local cluster started.\n2025-09-20 22:56:24 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.10:8787/status', workers=1, threads=1, memory=1.95 TiB)\n2025-09-20 22:56:24 - darr_info - INFO - flattened rslc dask array shape, chunksize, dtype: (2500, 1834, 17), (2500, 1834, 1), complex64\n2025-09-20 22:56:24 - zarr_info - INFO - ./load_data/rslc.zarr zarray shape, chunks, dtype: (2500, 1834, 17), (1000, 1000, 1), complex64\n2025-09-20 22:56:24 - load_gamma_flatten_rslc - INFO - computing graph setted. doing all the computing.\n2025-09-20 22:56:35 - load_gamma_flatten_rslc - INFO - computing finished.\n2025-09-20 22:56:35 - load_gamma_flatten_rslc - INFO - dask cluster closed.\n2025-09-20 22:56:35 - log_args - INFO - running function: load_gamma_lat_lon_hgt\n2025-09-20 22:56:35 - log_args - INFO - fetching args:\n2025-09-20 22:56:35 - log_args - INFO - diff_par = '../../../data/gamma/geocoding/20210802.diff_par'\n2025-09-20 22:56:35 - log_args - INFO - rslc_par = '../../../data/gamma/rslc/20220620.rslc.par'\n2025-09-20 22:56:35 - log_args - INFO - dem_par = '../../../data/gamma/DEM/dem_seg_par'\n2025-09-20 22:56:35 - log_args - INFO - hgt = '../../../data/gamma/geocoding/20210802.hgt'\n2025-09-20 22:56:35 - log_args - INFO - scratch_dir = './load_data/scratch'\n2025-09-20 22:56:35 - log_args - INFO - lat_zarr = './load_data/lat.zarr'\n2025-09-20 22:56:35 - log_args - INFO - lon_zarr = './load_data/lon.zarr'\n2025-09-20 22:56:35 - log_args - INFO - hgt_zarr = './load_data/hgt.zarr'\n2025-09-20 22:56:35 - log_args - INFO - chunks = (1000, 1000)\n2025-09-20 22:56:35 - log_args - INFO - fetching args done.\n2025-09-20 22:56:35 - load_gamma_lat_lon_hgt - INFO - image shape: (2500,1834)\n2025-09-20 22:56:35 - load_gamma_lat_lon_hgt - INFO - run gamma command to generate longitude, latitude and height:\n2025-09-20 22:56:35 - load_gamma_lat_lon_hgt - INFO - load_data/scratch/plist exists. skip runing mkgrid load_data/scratch/plist 1834 2500 1 1 &gt;&gt; load_data/scratch/gamma.log\n2025-09-20 22:56:35 - load_gamma_lat_lon_hgt - INFO - load_data/scratch/phgt_wgs84 exists. skip runing pt2geo load_data/scratch/plist - ../../../data/gamma/rslc/20220620.rslc.par - ../../../data/gamma/geocoding/20210802.hgt ../../../data/gamma/DEM/dem_seg_par ../../../data/gamma/geocoding/20210802.diff_par 1 1 - - load_data/scratch/plat_lon load_data/scratch/phgt_wgs84 &gt;&gt; load_data/scratch/gamma.log\n2025-09-20 22:56:35 - load_gamma_lat_lon_hgt - INFO - writing zarr file.\n2025-09-20 22:56:35 - load_gamma_lat_lon_hgt - INFO - write done.\n2025-09-20 22:56:35 - log_args - INFO - running function: load_gamma_look_vector\n2025-09-20 22:56:35 - log_args - INFO - fetching args:\n2025-09-20 22:56:35 - log_args - INFO - theta = '../../../data/gamma/geocoding/20210802.lv_theta'\n2025-09-20 22:56:35 - log_args - INFO - phi = '../../../data/gamma/geocoding/20210802.lv_phi'\n2025-09-20 22:56:35 - log_args - INFO - lt = '../../../data/gamma/geocoding/20210802.lt_fine'\n2025-09-20 22:56:35 - log_args - INFO - rslc_par = '../../../data/gamma/rslc/20220620.rslc.par'\n2025-09-20 22:56:35 - log_args - INFO - dem_par = '../../../data/gamma/DEM/dem_seg_par'\n2025-09-20 22:56:35 - log_args - INFO - scratch_dir = './load_data/scratch'\n2025-09-20 22:56:35 - log_args - INFO - theta_zarr = './load_data/theta.zarr'\n2025-09-20 22:56:35 - log_args - INFO - phi_zarr = './load_data/phi.zarr'\n2025-09-20 22:56:35 - log_args - INFO - chunks = (1000, 1000)\n2025-09-20 22:56:35 - log_args - INFO - fetching args done.\n2025-09-20 22:56:35 - load_gamma_look_vector - INFO - image shape: (2500,1834)\n2025-09-20 22:56:35 - load_gamma_look_vector - INFO - load_data/scratch/theta_rdc exists. skip runing geocode ../../../data/gamma/geocoding/20210802.lt_fine ../../../data/gamma/geocoding/20210802.lv_theta 5741 load_data/scratch/theta_rdc 1834 2500 &gt;&gt; load_data/scratch/gamma.log\n2025-09-20 22:56:35 - load_gamma_look_vector - INFO - writing data.\n2025-09-20 22:56:36 - load_gamma_look_vector - INFO - load_data/scratch/phi_rdc exists. skip runing geocode ../../../data/gamma/geocoding/20210802.lt_fine ../../../data/gamma/geocoding/20210802.lv_phi 5741 load_data/scratch/phi_rdc 1834 2500 &gt;&gt; load_data/scratch/gamma.log\n2025-09-20 22:56:36 - load_gamma_look_vector - INFO - writing data.\n2025-09-20 22:56:36 - load_gamma_look_vector - INFO - Done.\n2025-09-20 22:56:36 - log_args - INFO - running function: load_gamma_range\n2025-09-20 22:56:36 - log_args - INFO - fetching args:\n2025-09-20 22:56:36 - log_args - INFO - rslc_par = '../../../data/gamma/rslc/20220620.rslc.par'\n2025-09-20 22:56:36 - log_args - INFO - range_zarr = './load_data/range.zarr'\n2025-09-20 22:56:36 - log_args - INFO - chunks = (1000, 1000)\n2025-09-20 22:56:36 - log_args - INFO - fetching args done.\n2025-09-20 22:56:36 - load_gamma_range - INFO - image shape: (2500,1834)\n2025-09-20 22:56:36 - load_gamma_range - INFO - Calculating slant range distance.\n2025-09-20 22:56:36 - load_gamma_range - INFO - writing data.\n2025-09-20 22:56:36 - load_gamma_range - INFO - Done.\n2025-09-20 22:56:36 - log_args - INFO - running function: load_gamma_metadata\n2025-09-20 22:56:36 - log_args - INFO - fetching args:\n2025-09-20 22:56:36 - log_args - INFO - rslc_dir = '../../../data/gamma/rslc'\n2025-09-20 22:56:36 - log_args - INFO - dem_par = '../../../data/gamma/DEM/dem_seg_par'\n2025-09-20 22:56:36 - log_args - INFO - reference = '20220620'\n2025-09-20 22:56:36 - log_args - INFO - meta_file = './load_data/meta.toml'\n2025-09-20 22:56:36 - log_args - INFO - fetching args done.\n2025-09-20 22:56:36 - load_gamma_metadata - INFO - fetching slc related metadata.\n2025-09-20 22:56:36 - load_gamma_metadata - INFO - Fetching heading angle\n2025-09-20 22:56:36 - load_gamma_metadata - INFO - Fetching range pixel spacing\n2025-09-20 22:56:36 - load_gamma_metadata - INFO - fetching azimuth pixel spacing\n2025-09-20 22:56:36 - load_gamma_metadata - INFO - Fetching randar wavelength\n2025-09-20 22:56:36 - load_gamma_metadata - INFO - fetching dem related metadata\n2025-09-20 22:56:36 - load_gamma_metadata - INFO - Run gamma command to calculate baseline:\n2025-09-20 22:56:36 - load_gamma_metadata - INFO - run command: base_calc /tmp/tmp4rcpx26a/slc_tab ../../../data/gamma/rslc/20220620.rslc.par /tmp/tmp4rcpx26a/bperp /tmp/tmp4rcpx26a/itab - &gt; /tmp/tmp4rcpx26a/log\n2025-09-20 22:56:36 - load_gamma_metadata - INFO - gamma command finished.\n2025-09-20 22:56:36 - load_gamma_metadata - INFO - All meta data: \ndates = [ \"20210802\", \"20210816\", \"20210830\", \"20210913\", \"20211011\", \"20211025\", \"20220606\", \"20220620\", \"20220704\", \"20220718\", \"20220801\", \"20220815\", \"20220829\", \"20220912\", \"20220926\", \"20221010\", \"20221024\",]\nradar_wavelength = 0.24245249210715603\nrange_pixel_spacing = 4.29054\nazimuth_pixel_spacing = 3.740105\nlonlat_bbox = [ -148.2606018, 61.099475398661994, -147.89598577255998, 61.2183333,]\nmerca_bbox = [ -16504294.694782883, 8648700.085300261, -16463705.824278845, 8676129.004166307,]\nperpendicular_baseline = [ -97.61360168457031, -45.58580017089844, 17.86680030822754, -26.258899688720703, -63.72420120239258, -56.363399505615234, 64.75759887695312, 0.0, -9.043999671936035, -13.02869987487793, -112.94960021972656, -86.09490203857422, -129.9635009765625, -127.6594009399414, -182.29519653320312, -129.735107421875, -184.31100463867188,]\n\n2025-09-20 22:56:36 - load_gamma_metadata - INFO - writing data in toml file.\n2025-09-20 22:56:36 - load_gamma_metadata - INFO - Done.\n\n\nHere we get all needed data: look vector, latitude, lontitude, height, metadata, slant range distance, and flattened rslc stack.",
    "crumbs": [
      "Tutorials",
      "CLI",
      "Load Data"
    ]
  },
  {
    "objectID": "Tutorials/CLI/load_data.html#visualize-the-loaded-interferograms",
    "href": "Tutorials/CLI/load_data.html#visualize-the-loaded-interferograms",
    "title": "Load Data",
    "section": "visualize the loaded interferograms",
    "text": "visualize the loaded interferograms\nThen we can visualize the loaded data, e.g., the interferograms:\n\nmc.ras_pyramid(rslc_zarr, './load_data/rslc_pyramid')\n\n2025-09-20 22:56:36 - log_args - INFO - running function: ras_pyramid\n2025-09-20 22:56:36 - log_args - INFO - fetching args:\n2025-09-20 22:56:36 - log_args - INFO - ras = './load_data/rslc.zarr'\n2025-09-20 22:56:36 - log_args - INFO - out_dir = './load_data/rslc_pyramid'\n2025-09-20 22:56:36 - log_args - INFO - chunks = (256, 256)\n2025-09-20 22:56:36 - log_args - INFO - processes = False\n2025-09-20 22:56:36 - log_args - INFO - n_workers = 1\n2025-09-20 22:56:36 - log_args - INFO - threads_per_worker = 2\n2025-09-20 22:56:36 - log_args - INFO - dask_cluster_arg = {}\n2025-09-20 22:56:36 - log_args - INFO - fetching args done.\n2025-09-20 22:56:36 - ras_pyramid - INFO - clean out dir\n2025-09-20 22:56:37 - zarr_info - INFO - ./load_data/rslc.zarr zarray shape, chunks, dtype: (2500, 1834, 17), (1000, 1000, 1), complex64\n2025-09-20 22:56:37 - ras_pyramid - INFO - rendered raster pyramid with zoom level ranging from 0 (finest resolution) to 10 (coarsest resolution).\n2025-09-20 22:56:37 - ras_pyramid - INFO - dask local cluster started.\n2025-09-20 22:56:37 - dask_cluster_info - INFO - dask cluster: LocalCluster(dashboard_link='http://10.211.48.10:8787/status', workers=1, threads=2, memory=1.95 TiB)\n2025-09-20 22:56:37 - zarr_info - INFO - load_data/rslc_pyramid/0.zarr zarray shape, chunks, dtype: (2500, 1834, 17), (256, 256, 1), complex64\n2025-09-20 22:56:37 - zarr_info - INFO - load_data/rslc_pyramid/1.zarr zarray shape, chunks, dtype: (1250, 917, 17), (256, 256, 1), complex64\n2025-09-20 22:56:37 - zarr_info - INFO - load_data/rslc_pyramid/2.zarr zarray shape, chunks, dtype: (625, 459, 17), (256, 256, 1), complex64\n2025-09-20 22:56:37 - zarr_info - INFO - load_data/rslc_pyramid/3.zarr zarray shape, chunks, dtype: (313, 230, 17), (256, 256, 1), complex64\n2025-09-20 22:56:37 - zarr_info - INFO - load_data/rslc_pyramid/4.zarr zarray shape, chunks, dtype: (157, 115, 17), (256, 256, 1), complex64\n2025-09-20 22:56:38 - zarr_info - INFO - load_data/rslc_pyramid/5.zarr zarray shape, chunks, dtype: (79, 58, 17), (256, 256, 1), complex64\n2025-09-20 22:56:38 - zarr_info - INFO - load_data/rslc_pyramid/6.zarr zarray shape, chunks, dtype: (40, 29, 17), (256, 256, 1), complex64\n2025-09-20 22:56:38 - zarr_info - INFO - load_data/rslc_pyramid/7.zarr zarray shape, chunks, dtype: (20, 15, 17), (256, 256, 1), complex64\n2025-09-20 22:56:38 - zarr_info - INFO - load_data/rslc_pyramid/8.zarr zarray shape, chunks, dtype: (10, 8, 17), (256, 256, 1), complex64\n2025-09-20 22:56:38 - zarr_info - INFO - load_data/rslc_pyramid/9.zarr zarray shape, chunks, dtype: (5, 4, 17), (256, 256, 1), complex64\n2025-09-20 22:56:38 - zarr_info - INFO - load_data/rslc_pyramid/10.zarr zarray shape, chunks, dtype: (3, 2, 17), (256, 256, 1), complex64\n2025-09-20 22:56:38 - ras_pyramid - INFO - computing graph setted. doing all the computing.\n2025-09-20 22:56:41 - ras_pyramid - INFO - computing finished. 3.6s\n2025-09-20 22:56:41 - ras_pyramid - INFO - dask cluster closed.\n\n\n\nimport toml\nwith open(meta_file,'r') as f:\n    meta = toml.load(f)\ndates = meta['dates']\n\n\nimport holoviews as hv\nfrom bokeh.models import WheelZoomTool\nfrom holoviews import opts\nimport numpy as np\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n  \n  \n\n\n\n\n\n\n\n\nⓘ\n\n\n\n\n\nhv.extension('bokeh')\nhv.output(widget_location='bottom')\n\nInterferograms with the first slc as reference:\n\nintf0_plot = mc.ras_plot('./load_data/rslc_pyramid', post_proc='intf_0', level_increase=0)\n\n\nintf0_plot = intf0_plot.redim(i=hv.Dimension('i', label='Interferogram', range=(0,len(dates)-1), value_format=(lambda i: dates[0]+'_'+dates[i])),\n                              x=hv.Dimension('r', label='Range'), y=hv.Dimension('az',label='Azimuth'), z=hv.Dimension('Phase',range=(-np.pi,np.pi)))\n\n\nintf0_plot.opts(opts.Image(cmap='colorwheel',width=600, height=600, colorbar=True,\n                          invert_yaxis=True,\n                          default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],active_tools=['wheel_zoom']))\n\n\n\n\n\n  \n\n\n\n\nOr all of the interferograms:\n\nintf_plot = mc.ras_plot('./load_data/rslc_pyramid',post_proc='intf_all',n_kdim=2,level_increase=0)\n\n\nintf_plot = intf_plot.redim(i=hv.Dimension('i', label='Reference Image', range=(0,16), value_format=(lambda i: dates[i])),\n                            j=hv.Dimension('j', label='Secondary Image', range=(0,16), value_format=(lambda i: dates[i])),\n                            x=hv.Dimension('r', label='Range'), y=hv.Dimension('az',label='Azimuth'), z=hv.Dimension('Phase',range=(-np.pi,np.pi)))\n\nSpecify plotting options and plot:\n\nhv.output(widget_location='bottom')\nintf_plot.opts(opts.Image(cmap='colorwheel',frame_width=500, frame_height=600, colorbar=True,\n                          invert_yaxis=True,\n                          default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],active_tools=['wheel_zoom']))",
    "crumbs": [
      "Tutorials",
      "CLI",
      "Load Data"
    ]
  },
  {
    "objectID": "Tutorials/CLI/load_data.html#calculate-web-mercator-coordinates",
    "href": "Tutorials/CLI/load_data.html#calculate-web-mercator-coordinates",
    "title": "Load Data",
    "section": "calculate Web Mercator coordinates",
    "text": "calculate Web Mercator coordinates\nFor visulization on Google Map tiles, coordinates on Web Mercator projection is needed:\n\ne_zarr = './load_data/e.zarr'\nn_zarr = './load_data/n.zarr'\n\n\nmc.transform(lon_zarr,lat_zarr,e_zarr,n_zarr)\n\n2025-09-20 22:56:44 - log_args - INFO - running function: transform\n2025-09-20 22:56:44 - log_args - INFO - fetching args:\n2025-09-20 22:56:44 - log_args - INFO - xx_in = './load_data/lon.zarr'\n2025-09-20 22:56:44 - log_args - INFO - yy_in = './load_data/lat.zarr'\n2025-09-20 22:56:44 - log_args - INFO - xx_out = './load_data/e.zarr'\n2025-09-20 22:56:44 - log_args - INFO - yy_out = './load_data/n.zarr'\n2025-09-20 22:56:44 - log_args - INFO - epsg_in = 4326\n2025-09-20 22:56:44 - log_args - INFO - epsg_out = 3857\n2025-09-20 22:56:44 - log_args - INFO - fetching args done.\n2025-09-20 22:56:44 - transform - INFO - input EPSG: 4326.\n2025-09-20 22:56:44 - zarr_info - INFO - xx_in zarray shape, chunks, dtype: (2500, 1834), (1000, 1000), float64\n2025-09-20 22:56:44 - zarr_info - INFO - yy_in zarray shape, chunks, dtype: (2500, 1834), (1000, 1000), float64\n2025-09-20 22:56:44 - transform - INFO - output EPSG: 3857.\n2025-09-20 22:56:44 - transform - INFO - do the transformation.\n\n\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\n\n\n2025-09-20 22:56:48 - transform - INFO - write output.\n2025-09-20 22:56:48 - transform - INFO - write done.",
    "crumbs": [
      "Tutorials",
      "CLI",
      "Load Data"
    ]
  },
  {
    "objectID": "Tutorials/CLI/overview.html",
    "href": "Tutorials/CLI/overview.html",
    "title": "Tutorials for CLI Overview",
    "section": "",
    "text": "This is a series of tutorials to show how to use CLI for InSAR processing.",
    "crumbs": [
      "Tutorials",
      "CLI",
      "Tutorials for CLI Overview"
    ]
  },
  {
    "objectID": "Tutorials/adaptive_multilook.html",
    "href": "Tutorials/adaptive_multilook.html",
    "title": "Adaptive Multilook",
    "section": "",
    "text": "In this tutorial, we demostrate how to use Moraine package to identify spatially homogeneous pixels, extimate the coherence matrix and compare the original interferogram, multilook intergerogram and the adaptive multilook interferogram.\nimport numpy as np\nimport zarr\nfrom matplotlib import pyplot as plt\n\nfrom moraine.utils_ import is_cuda_available\nif is_cuda_available():\n    import cupy as cp\n    from cupyx.scipy.ndimage import uniform_filter\n\nimport moraine as mr",
    "crumbs": [
      "Tutorials",
      "API",
      "Adaptive Multilook"
    ]
  },
  {
    "objectID": "Tutorials/adaptive_multilook.html#load-rslc-stack",
    "href": "Tutorials/adaptive_multilook.html#load-rslc-stack",
    "title": "Adaptive Multilook",
    "section": "Load rslc stack",
    "text": "Load rslc stack\n\nif is_cuda_available():\n    print(cp.cuda.Device(1).use())\n    rslc = cp.asarray(zarr.open('../../data/rslc.zarr',mode='r')[:])\n    print(rslc.shape)\n\n&lt;CUDA Device 1&gt;\n(2500, 1834, 17)",
    "crumbs": [
      "Tutorials",
      "API",
      "Adaptive Multilook"
    ]
  },
  {
    "objectID": "Tutorials/adaptive_multilook.html#apply-ks-test",
    "href": "Tutorials/adaptive_multilook.html#apply-ks-test",
    "title": "Adaptive Multilook",
    "section": "Apply ks test",
    "text": "Apply ks test\n\nif is_cuda_available():\n    rmli = cp.abs(rslc)**2\n\n    az_half_win = 5\n    r_half_win = 5\n    az_win = 2*az_half_win+1\n    r_win = 2*r_half_win+1\n\n    p = mr.ks_test(rmli,az_half_win=az_half_win,r_half_win=r_half_win)\n\nCPU times: user 216 ms, sys: 65.8 ms, total: 282 ms\nWall time: 2.56 s",
    "crumbs": [
      "Tutorials",
      "API",
      "Adaptive Multilook"
    ]
  },
  {
    "objectID": "Tutorials/adaptive_multilook.html#select-shps",
    "href": "Tutorials/adaptive_multilook.html#select-shps",
    "title": "Adaptive Multilook",
    "section": "Select SHPs",
    "text": "Select SHPs\n\nif is_cuda_available():\n    is_shp = (p &lt; 0.05) & (p &gt;= 0.0)\n\n\nif is_cuda_available():\n    shp_num = cp.count_nonzero(is_shp,axis=(-2,-1))\n    shp_num_np = cp.asnumpy(shp_num)\n\n\nif is_cuda_available():\n    fig, ax = plt.subplots(1,1,figsize=(10,10))\n    pcm = ax.imshow(shp_num_np)\n    ax.set(title='Number of SHPs',xlabel='Range Index',ylabel='Azimuth Index')\n    fig.colorbar(pcm)\n    fig.show()",
    "crumbs": [
      "Tutorials",
      "API",
      "Adaptive Multilook"
    ]
  },
  {
    "objectID": "Tutorials/adaptive_multilook.html#estimate-coherence-matrix",
    "href": "Tutorials/adaptive_multilook.html#estimate-coherence-matrix",
    "title": "Adaptive Multilook",
    "section": "Estimate coherence matrix",
    "text": "Estimate coherence matrix\n\nif is_cuda_available():\n    coh = mr.emperical_co(rslc,is_shp)[1]\n\nCPU times: user 127 ms, sys: 20.6 ms, total: 148 ms\nWall time: 151 ms",
    "crumbs": [
      "Tutorials",
      "API",
      "Adaptive Multilook"
    ]
  },
  {
    "objectID": "Tutorials/adaptive_multilook.html#compare",
    "href": "Tutorials/adaptive_multilook.html#compare",
    "title": "Adaptive Multilook",
    "section": "Compare",
    "text": "Compare\nHere we compare 1-look interferogram, multilook interferogram and adaptive multilook interferogram\n\nref_image = 15\nsec_image = 16\n\n1 look interferogram:\n\nif is_cuda_available():\n    diff = rslc[:,:,ref_image]*rslc[:,:,sec_image].conj()\n\nMultilook interferogram:\n\nif is_cuda_available():\n    ml_diff = uniform_filter(diff,size=(az_win,r_win))\n\nAdaptive multilook interferogram:\n\nif is_cuda_available():\n    ad_ml_diff = coh[:,:,ref_image,sec_image]\n\nThe plot background:\n\nif is_cuda_available():\n    plot_bg = rmli[:,:,0]\n    plot_bg = cp.asnumpy(plot_bg)\n    plot_bg = np.nan_to_num(plot_bg)\n    alpha = mr.bg_alpha(plot_bg)\n\nPlot:\n\nif is_cuda_available():\n    fig,axes = plt.subplots(1,3,figsize=(24/2,7/2))\n    xlabel = 'Range Index'\n    ylabel = 'Azimuth Index'\n    pcm0 = axes[0].imshow(cp.asnumpy(cp.angle(diff)),alpha=alpha,interpolation='nearest',cmap='hsv')\n    pcm1 = axes[1].imshow(cp.asnumpy(cp.angle(ml_diff)),alpha=alpha,interpolation='nearest',cmap='hsv')\n    pcm2 = axes[2].imshow(cp.asnumpy(cp.angle(ad_ml_diff)),alpha=alpha,interpolation='nearest',cmap='hsv')\n    for ax in axes:\n        ax.set(facecolor = \"black\")\n    axes[0].set(title='Orignal Interferogram',xlabel=xlabel,ylabel=ylabel)\n    axes[1].set(title=f'Multilook {az_win} by {r_win}',xlabel=xlabel,ylabel=ylabel)\n    axes[2].set(title=f'Adaptively multilook {az_win} by {r_win}',xlabel=xlabel,ylabel=ylabel)\n    fig.colorbar(pcm0,ax=axes[0])\n    fig.colorbar(pcm1,ax=axes[1])\n    fig.colorbar(pcm1,ax=axes[2])\n    fig.show()",
    "crumbs": [
      "Tutorials",
      "API",
      "Adaptive Multilook"
    ]
  },
  {
    "objectID": "Tutorials/adaptive_multilook.html#conclusion",
    "href": "Tutorials/adaptive_multilook.html#conclusion",
    "title": "Adaptive Multilook",
    "section": "Conclusion",
    "text": "Conclusion\n\nAdaptive multilooking based on SHPs selection performs better than non-adaptive one;\nks_test and emperical_co implemented in Moraine package are fast.",
    "crumbs": [
      "Tutorials",
      "API",
      "Adaptive Multilook"
    ]
  },
  {
    "objectID": "API/chunk_.html",
    "href": "API/chunk_.html",
    "title": "chunk",
    "section": "",
    "text": "source\n\nfill_slice\n\n fill_slice (shape, slices)\n\n\n\n\n\nDetails\n\n\n\n\nshape\nnumpy arr, cupy arr, zarr,\n\n\nslices\ntuple of slice object, len == data_arr.ndim\n\n\n\n\nsource\n\n\nall_chunk_slices\n\n all_chunk_slices (shape, chunks)\n\nget the slices for every input chunks\n\n\n\n\nDetails\n\n\n\n\nshape\nnp.array, cp.array,zarr\n\n\nchunks\n\n\n\n\nusage:\n\na = np.zeros((50,100,11))\nchunks = (15,40,6)\nall_chunk_slices(a.shape,chunks)\n\n[(slice(0, 15, None), slice(0, 40, None), slice(0, 6, None)),\n (slice(0, 15, None), slice(0, 40, None), slice(6, 11, None)),\n (slice(0, 15, None), slice(40, 80, None), slice(0, 6, None)),\n (slice(0, 15, None), slice(40, 80, None), slice(6, 11, None)),\n (slice(0, 15, None), slice(80, 100, None), slice(0, 6, None)),\n (slice(0, 15, None), slice(80, 100, None), slice(6, 11, None)),\n (slice(15, 30, None), slice(0, 40, None), slice(0, 6, None)),\n (slice(15, 30, None), slice(0, 40, None), slice(6, 11, None)),\n (slice(15, 30, None), slice(40, 80, None), slice(0, 6, None)),\n (slice(15, 30, None), slice(40, 80, None), slice(6, 11, None)),\n (slice(15, 30, None), slice(80, 100, None), slice(0, 6, None)),\n (slice(15, 30, None), slice(80, 100, None), slice(6, 11, None)),\n (slice(30, 45, None), slice(0, 40, None), slice(0, 6, None)),\n (slice(30, 45, None), slice(0, 40, None), slice(6, 11, None)),\n (slice(30, 45, None), slice(40, 80, None), slice(0, 6, None)),\n (slice(30, 45, None), slice(40, 80, None), slice(6, 11, None)),\n (slice(30, 45, None), slice(80, 100, None), slice(0, 6, None)),\n (slice(30, 45, None), slice(80, 100, None), slice(6, 11, None)),\n (slice(45, 50, None), slice(0, 40, None), slice(0, 6, None)),\n (slice(45, 50, None), slice(0, 40, None), slice(6, 11, None)),\n (slice(45, 50, None), slice(40, 80, None), slice(0, 6, None)),\n (slice(45, 50, None), slice(40, 80, None), slice(6, 11, None)),\n (slice(45, 50, None), slice(80, 100, None), slice(0, 6, None)),\n (slice(45, 50, None), slice(80, 100, None), slice(6, 11, None))]\n\n\n\na = np.zeros(343)\nall_chunk_slices(a.shape,(15,))\n\n[(slice(0, 15, None),),\n (slice(15, 30, None),),\n (slice(30, 45, None),),\n (slice(45, 60, None),),\n (slice(60, 75, None),),\n (slice(75, 90, None),),\n (slice(90, 105, None),),\n (slice(105, 120, None),),\n (slice(120, 135, None),),\n (slice(135, 150, None),),\n (slice(150, 165, None),),\n (slice(165, 180, None),),\n (slice(180, 195, None),),\n (slice(195, 210, None),),\n (slice(210, 225, None),),\n (slice(225, 240, None),),\n (slice(240, 255, None),),\n (slice(255, 270, None),),\n (slice(270, 285, None),),\n (slice(285, 300, None),),\n (slice(300, 315, None),),\n (slice(315, 330, None),),\n (slice(330, 343, None),)]\n\n\n\nsource\n\n\nall_chunk_slices_with_overlap\n\n all_chunk_slices_with_overlap (shape, chunks, depths)\n\nget the slices for every input chunks with overlap\n\na = np.zeros((50,100,11))\nchunks = (15,40,6)\ndepth = (1,2,0)\nall_chunk_slices_with_overlap(a.shape,chunks,depth)\n\n[(slice(0, 16, None), slice(0, 42, None), slice(0, 6, None)),\n (slice(0, 16, None), slice(0, 42, None), slice(6, 11, None)),\n (slice(0, 16, None), slice(38, 82, None), slice(0, 6, None)),\n (slice(0, 16, None), slice(38, 82, None), slice(6, 11, None)),\n (slice(0, 16, None), slice(78, 100, None), slice(0, 6, None)),\n (slice(0, 16, None), slice(78, 100, None), slice(6, 11, None)),\n (slice(14, 31, None), slice(0, 42, None), slice(0, 6, None)),\n (slice(14, 31, None), slice(0, 42, None), slice(6, 11, None)),\n (slice(14, 31, None), slice(38, 82, None), slice(0, 6, None)),\n (slice(14, 31, None), slice(38, 82, None), slice(6, 11, None)),\n (slice(14, 31, None), slice(78, 100, None), slice(0, 6, None)),\n (slice(14, 31, None), slice(78, 100, None), slice(6, 11, None)),\n (slice(29, 46, None), slice(0, 42, None), slice(0, 6, None)),\n (slice(29, 46, None), slice(0, 42, None), slice(6, 11, None)),\n (slice(29, 46, None), slice(38, 82, None), slice(0, 6, None)),\n (slice(29, 46, None), slice(38, 82, None), slice(6, 11, None)),\n (slice(29, 46, None), slice(78, 100, None), slice(0, 6, None)),\n (slice(29, 46, None), slice(78, 100, None), slice(6, 11, None)),\n (slice(44, 50, None), slice(0, 42, None), slice(0, 6, None)),\n (slice(44, 50, None), slice(0, 42, None), slice(6, 11, None)),\n (slice(44, 50, None), slice(38, 82, None), slice(0, 6, None)),\n (slice(44, 50, None), slice(38, 82, None), slice(6, 11, None)),\n (slice(44, 50, None), slice(78, 100, None), slice(0, 6, None)),\n (slice(44, 50, None), slice(78, 100, None), slice(6, 11, None))]\n\n\n\nsource\n\n\nchunkwise_slicing_mapping\n\n chunkwise_slicing_mapping (shape, chunks, depths)\n\nget the slices for every input chunks with overlap output chunks without overlap and their mapping slices\n\na = np.zeros((50,100))\nchunks = (15,40)\ndepth = [1,2] # or {0:1, 1:2, 2:3}\nchunkwise_slicing_mapping(a.shape,chunks,depth)\n\n([(slice(0, 16, None), slice(0, 42, None)),\n  (slice(0, 16, None), slice(38, 82, None)),\n  (slice(0, 16, None), slice(78, 100, None)),\n  (slice(14, 31, None), slice(0, 42, None)),\n  (slice(14, 31, None), slice(38, 82, None)),\n  (slice(14, 31, None), slice(78, 100, None)),\n  (slice(29, 46, None), slice(0, 42, None)),\n  (slice(29, 46, None), slice(38, 82, None)),\n  (slice(29, 46, None), slice(78, 100, None)),\n  (slice(44, 50, None), slice(0, 42, None)),\n  (slice(44, 50, None), slice(38, 82, None)),\n  (slice(44, 50, None), slice(78, 100, None))],\n [(slice(0, 15, None), slice(0, 40, None)),\n  (slice(0, 15, None), slice(40, 80, None)),\n  (slice(0, 15, None), slice(80, 100, None)),\n  (slice(15, 30, None), slice(0, 40, None)),\n  (slice(15, 30, None), slice(40, 80, None)),\n  (slice(15, 30, None), slice(80, 100, None)),\n  (slice(30, 45, None), slice(0, 40, None)),\n  (slice(30, 45, None), slice(40, 80, None)),\n  (slice(30, 45, None), slice(80, 100, None)),\n  (slice(45, 50, None), slice(0, 40, None)),\n  (slice(45, 50, None), slice(40, 80, None)),\n  (slice(45, 50, None), slice(80, 100, None))],\n [(slice(0, 15, None), slice(0, 40, None)),\n  (slice(0, 15, None), slice(2, 42, None)),\n  (slice(0, 15, None), slice(2, 22, None)),\n  (slice(1, 16, None), slice(0, 40, None)),\n  (slice(1, 16, None), slice(2, 42, None)),\n  (slice(1, 16, None), slice(2, 22, None)),\n  (slice(1, 16, None), slice(0, 40, None)),\n  (slice(1, 16, None), slice(2, 42, None)),\n  (slice(1, 16, None), slice(2, 22, None)),\n  (slice(1, 6, None), slice(0, 40, None)),\n  (slice(1, 6, None), slice(2, 42, None)),\n  (slice(1, 6, None), slice(2, 22, None))])\n\n\n\nsource\n\n\nchunkwise_knn_mapping\n\n chunkwise_knn_mapping (x, y, chunks:int, k=128)"
  },
  {
    "objectID": "API/pl.html",
    "href": "API/pl.html",
    "title": "pl",
    "section": "",
    "text": "import numpy as np\nimport zarr\nimport moraine as mr\nfrom moraine.utils_ import is_cuda_available\nif is_cuda_available():\n    import cupy as cp\nfrom matplotlib import pyplot as plt",
    "crumbs": [
      "API",
      "pl"
    ]
  },
  {
    "objectID": "API/pl.html#emi",
    "href": "API/pl.html#emi",
    "title": "pl",
    "section": "EMI",
    "text": "EMI\n\nsource\n\nemi\n\n emi (coh:numpy.ndarray, ref:int=0)\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ncoh\nndarray\n\ncomplex coherence metrix,dtype cupy.complex\n\n\nref\nint\n0\nindex of reference image in the phase history output, optional. Default: 0\n\n\nReturns\ntuple\n\nestimated phase history ph, dtype complex; quality (minimum eigvalue, dtype float)\n\n\n\n\n# #| export\n# def emi(coh:np.ndarray, #complex coherence metrix,dtype cupy.complex\n#         ref:int=0, #index of reference image in the phase history output, optional. Default: 0\n#        )-&gt; tuple[np.ndarray,np.ndarray]: # estimated phase history `ph`, dtype complex; quality (minimum eigvalue, dtype float)\n#     xp = get_array_module(coh)\n#     coh_mag = xp.abs(coh)\n#     coh_mag_inv = xp.linalg.inv(coh_mag)\n#     min_eigval, min_eig = xp.linalg.eigh(coh_mag_inv*coh)\n#     min_eigval = min_eigval[...,0]\n#     # min_eig = min_eig[...,0]\n#     min_eig = min_eig[...,0]*min_eig[...,[ref],0].conj()\n\n#     return min_eig/abs(min_eig), min_eigval\n\nemi is a phase estimator base on Eigendecomposition-based Maximum-likelihood-estimator of Interferometric phase (EMI) (Ansari, De Zan, and Bamler 2018) phase linking method.\n\nAnsari, Homa, Francesco De Zan, and Richard Bamler. 2018. “Efficient Phase Estimation for Interferogram Stacks.” IEEE Transactions on Geoscience and Remote Sensing 56 (7): 4109–25. https://doi.org/10.1109/TGRS.2018.2826045.\nThe amplitude of coh should range between 0 and 1 and the phase of coh should be the interferometric phase. The returned phase is also complex but the amplitude is setted to 1. The quality factor is a measure for the inadequacy of EMI’s model that adding real-valued dyadic for calibration of real coherence matrix which is generally poorly estimated. It is supposed to larger than 1 and smaller means better.\n\n\n\n\n\n\nImportant\n\n\n\nThis function is deprecated as estimate coherence for all pixels are not necessary. Please use emperical_co_pc instead.\n\n\nExample: Complex coherence matrix from a stack of 17 SLC images:\n\nrslc = zarr.open('../../data/rslc.zarr/',mode='r')[:]\n\n# SHP selection\naz_half_win = 5; r_half_win = 5\naz_win = 2*az_half_win+1; r_win = 2*r_half_win+1\n\nrmli = np.abs(rslc)**2\n\np = mr.ks_test(rmli,az_half_win=az_half_win,r_half_win=r_half_win)\nis_shp = p &lt; 0.05\n\n# Select DS candidate\nshp_num = np.count_nonzero(is_shp,axis=(-2,-1))\nis_ds_can = shp_num &gt;= 50\n\nds_can_is_shp = is_shp[is_ds_can]\nds_can_idx = np.stack(np.where(is_ds_can),axis=-1)\nds_can_coh = mr.emperical_co_pc(rslc,ds_can_idx,ds_can_is_shp)\nprint(ds_can_coh.shape)\n\n(732727, 136)\n\n\n\nds_can_ph, ds_can_emi_quality = emi(ds_can_coh)\nprint(ds_can_ph.shape, ds_can_emi_quality.shape)\n\n(732727, 17) (732727,)\nCPU times: user 35.1 s, sys: 1.52 s, total: 36.6 s\nWall time: 4.11 s\n\n\n\nds_can_emi_quality_2d = np.empty_like(is_ds_can,dtype=ds_can_emi_quality.dtype)\nds_can_emi_quality_2d[:] = np.nan\nds_can_emi_quality_2d[is_ds_can] = ds_can_emi_quality\n\n\nfig, ax = plt.subplots(1,1,figsize=(10,10))\npcm = ax.imshow(ds_can_emi_quality_2d,interpolation='nearest',vmin=1,vmax=1.3)\nax.set(title='DS EMI quality factor',xlabel='Range Index',ylabel='Azimuth Index')\nfig.colorbar(pcm)\nfig.show()\n\n\n\n\n\n\n\n\ncupy.ndarray is also supported:\n\nif is_cuda_available():\n    ds_can_ph_, ds_can_emi_quality_ = emi(cp.asarray(ds_can_coh))",
    "crumbs": [
      "API",
      "pl"
    ]
  },
  {
    "objectID": "API/pl.html#temporal-coherence-for-distributed-scatterer",
    "href": "API/pl.html#temporal-coherence-for-distributed-scatterer",
    "title": "pl",
    "section": "Temporal Coherence for Distributed Scatterer",
    "text": "Temporal Coherence for Distributed Scatterer\n\nsource\n\nds_temp_coh\n\n ds_temp_coh (coh:numpy.ndarray, ph:numpy.ndarray,\n              image_pairs:numpy.ndarray=None, block_size:int=128)\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ncoh\nndarray\n\ncomplex coherence metrix, np.complex64 or cp.complex64\n\n\nph\nndarray\n\ncomplex phase history, np.complex64 or cp.complex64\n\n\nimage_pairs\nndarray\nNone\nimage pairs, all image pairs by default\n\n\nblock_size\nint\n128\nthe CUDA block size, only applied for cuda\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nThis function is deprecated and will be removed in the future release. Please use temp_coh from Pixel Quality Metrics.\n\n\nThis function estimate the temporal coherence of as\n\\[\\gamma = \\frac{1}{N_{IP}} \\left| \\sum_{n, k \\in IP} e^{i\\phi_{nk}} e^{-i(\\theta_n-\\theta_k)} \\right| \\]\nWhere \\(\\phi_{nk}\\) is the phase of complex interferogram/coherence matrix, \\(\\theta_{n}\\) is the phase of rslc or phase after phase linking, \\(IP\\) is the image pairs, \\(N_{IP}\\) is the number of image pairs.\nIf all image pairs are considered, then it is:\n\\[\\gamma = \\frac{2}{N^2-N} \\left| \\sum_{n=1}^{N} \\sum_{k=n+1}^{N} e^{i\\phi_{nk}} e^{-i(\\theta_n-\\theta_k)} \\right| \\]\n\nrslc = zarr.open('../../data/rslc.zarr/',mode='r')[:]\n\n# SHP selection\naz_half_win = 5; r_half_win = 5\naz_win = 2*az_half_win+1; r_win = 2*r_half_win+1\n\nrmli = np.abs(rslc)**2\np = mr.ks_test(rmli,az_half_win=az_half_win,r_half_win=r_half_win)\nis_shp = p &lt; 0.05\n\n# Select DS candidate\nshp_num = np.count_nonzero(is_shp,axis=(-2,-1))\nis_ds_can = shp_num &gt;= 50\n\nds_can_is_shp = is_shp[is_ds_can]\nds_can_idx = np.stack(np.where(is_ds_can),axis=-1)\nds_can_coh = mr.emperical_co_pc(rslc,ds_can_idx,ds_can_is_shp)\nds_can_ph = emi(ds_can_coh)[0]\nprint(ds_can_coh.shape,ds_can_ph.shape)\n\n(732727, 136) (732727, 17)\n\n\n\nds_can_temp_coh = ds_temp_coh(ds_can_coh,ds_can_ph)\nprint(ds_can_temp_coh.shape)\nif is_cuda_available():\n    ds_can_temp_coh_cp = ds_temp_coh(cp.asarray(ds_can_coh), cp.asarray(ds_can_ph))\n    np.testing.assert_array_almost_equal(ds_can_temp_coh, ds_can_temp_coh_cp.get())\n\n(732727,)\n\n\n\nds_can_temp_coh_2d = np.empty_like(is_ds_can,dtype=ds_can_temp_coh.dtype)\nds_can_temp_coh_2d[:] = np.nan\nds_can_temp_coh_2d[is_ds_can] = ds_can_temp_coh\n\n\nfig, ax = plt.subplots(1,1,figsize=(10,10))\npcm = ax.imshow(ds_can_temp_coh_2d,interpolation='nearest',vmin=0,vmax=1)\nax.set(title='DS Temporal Coherence',xlabel='Range Index',ylabel='Azimuth Index')\nfig.colorbar(pcm)\nfig.show()\n\n\n\n\n\n\n\n\n\nsource\n\n\nemperical_co_emi_temp_coh_pc\n\n emperical_co_emi_temp_coh_pc (rslc:numpy.ndarray, idx:numpy.ndarray,\n                               pc_is_shp:numpy.ndarray,\n                               batch_size:int=1000)\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nrslc\nndarray\n\nrslc stack, dtype:‘np.complex64’\n\n\nidx\nndarray\n\nindex of point target (azimuth_index, range_index), dtype: np.int32, shape: (n_pc, 2)\n\n\npc_is_shp\nndarray\n\nshp bool, dtype:‘np.bool’\n\n\nbatch_size\nint\n1000\n\n\n\n\nemperical_co_emi_temp_coh_pc is the combination of emperical_co_pc, emi and ds_temp_coh. But it does not return the coherence matrix as the full coherence matrix may be too big to fill the memory. The functions provide the batch_size options to do the processing in batch.\n\nrslc = zarr.open('../../data/rslc.zarr/',mode='r')[:]\n\n# SHP selection\naz_half_win = 5; r_half_win = 5\naz_win = 2*az_half_win+1; r_win = 2*r_half_win+1\n\nrmli = np.abs(rslc)**2\np = mr.ks_test(rmli,az_half_win=az_half_win,r_half_win=r_half_win)\nis_shp = p &lt; 0.05\n\n# Select DS candidate\nshp_num = np.count_nonzero(is_shp,axis=(-2,-1))\nis_ds_can = shp_num &gt;= 50\n\nds_can_is_shp = is_shp[is_ds_can]\nds_can_idx = np.stack(np.where(is_ds_can),axis=-1)\n\n\nds_can_ph, ds_can_emi_quality, ds_can_t_coh = emperical_co_emi_temp_coh_pc(rslc,ds_can_idx,ds_can_is_shp,batch_size=1000)\n\n\nds_can_coh_ = mr.emperical_co_pc(rslc,ds_can_idx,ds_can_is_shp)\nds_can_ph_, ds_can_emi_quality_ = emi(ds_can_coh_)\nds_can_t_coh_ = ds_temp_coh(ds_can_coh_,ds_can_ph_)\nnp.testing.assert_array_equal(ds_can_ph,ds_can_ph_)\nnp.testing.assert_array_equal(ds_can_emi_quality,ds_can_emi_quality_)\nnp.testing.assert_array_equal(ds_can_t_coh,ds_can_t_coh_)",
    "crumbs": [
      "API",
      "pl"
    ]
  },
  {
    "objectID": "API/co.html",
    "href": "API/co.html",
    "title": "co",
    "section": "",
    "text": "import zarr\nimport moraine as mr\nimport math\nimport itertools\nfrom moraine.utils_ import is_cuda_available\nif is_cuda_available():\n    import cupy as cp",
    "crumbs": [
      "API",
      "co"
    ]
  },
  {
    "objectID": "API/co.html#interferograms",
    "href": "API/co.html#interferograms",
    "title": "co",
    "section": "interferograms",
    "text": "interferograms\n\nsource\n\nmulti_look\n\n multi_look (rslc1, rslc2, looks=(1, 1))\n\nmulti looked interferogram for raster data.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nrslc1\n\n\nreference rslc\n\n\nrslc2\n\n\nsecondary rslc\n\n\nlooks\ntuple\n(1, 1)\n# range and azimuth looks\n\n\n\n\nsource\n\n\nintf\n\n intf (rslc1, rslc2)\n\n1 by 1 look interferogram for both raster and point cloud.\n\n\n\n\n\n\n\n\nDetails\n\n\n\n\nrslc1\nreference rslc, arbitrary dims, e.g., 3D(raster stack), 2D(raster or point cloud stack) or 1D(point cloud)\n\n\nrslc2\nsecondary rslc",
    "crumbs": [
      "API",
      "co"
    ]
  },
  {
    "objectID": "API/co.html#covariance-and-coherence-matrix-estimator",
    "href": "API/co.html#covariance-and-coherence-matrix-estimator",
    "title": "co",
    "section": "Covariance and Coherence Matrix Estimator",
    "text": "Covariance and Coherence Matrix Estimator\n\nsource\n\nemperical_co\n\n emperical_co (rslc:numpy.ndarray, is_shp:numpy.ndarray,\n               block_size:int=128)\n\nMaximum likelihood covariance estimator.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nrslc\nndarray\n\nrslc stack, dtype: cupy.complexfloating\n\n\nis_shp\nndarray\n\nshp bool, dtype: cupy.bool\n\n\nblock_size\nint\n128\nthe CUDA block size, it only affects the calculation speed\n\n\nReturns\ntuple\n\nthe covariance and coherence matrix cov and coh\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nThis function is deprecated as estimate coherence for all pixels are not necessary. Please use emperical_co_pc instead.\n\n\nThe cov and coh is defined as:\n\\[\ncov = E(z_1z_2^*) \\quad coh=\\frac{E(z_1z_2^*)}{\\sqrt{E(|z_1|^2)E(|z_2|^2)}}\n\\]\nwhere \\(z_1\\) and \\(z_2\\) are the reference and secondary SLC images, respectively. cov and coh are estimated as:\n\\[\ncov = \\frac{\\sum_{i=1}^{L}z_1^{i}z_2^{i*}}{L} \\quad coh = \\frac{\\sum_{i=1}^{L}z_1^{i}z_2^{i*}}{\\sqrt(\\sum_{i=1}^{L}|z_1^{i}|^2)(\\sum_{i=1}^{L}|z_2^{i}|^2)}\n\\]\nusing all selected SHPs. Their shapes are [nlines,width,nimages,nimages]. Note dim 2 and dim 3 are reference images and secondary images, respectively.\nThe rslc is a three dimentional cupy ndarray. The dtype should be cupy.complex64. From outerest to innerest, the three dimentions are azimuth, range and image. is_shp is a four dimentional cupy ndarray. It describes if pixels in the search window are SHP to the central pixel. From outerest ot innerest, they are azimuth, range, secondary pixel relative azimuth, secondary pixel relative range.\nHere is an example:\n\n# synthetic data\nrslc = np.random.rand(5,10,17).astype(np.float32) + 1j*np.random.rand(5,10,17).astype(np.float32)\nhalf_az_win = 1;\nhalf_r_win = 2;\nis_shp = np.random.choice(a=[False, True], size=(5,10,2*half_az_win+1,2*half_r_win+1), p=[0.3, 0.7])\nfor i, j, k, l in itertools.product(range(is_shp.shape[0]),range(is_shp.shape[1]),range(is_shp.shape[2]),range(is_shp.shape[3])):\n    if (k == half_az_win) and (l == half_r_win):\n        is_shp[i,j,k,l] = True\n    if (i+k-half_az_win&lt;0) or (i+k-half_az_win&gt;=rslc.shape[0]) or (j+l-half_r_win&lt;0) or (j+l-half_r_win&gt;=rslc.shape[1]):\n        is_shp[i,j,k,l] = False\n\n\nprint(rslc.shape, is_shp.shape, is_shp[2,3])\n\n(5, 10, 17) (5, 10, 3, 5) [[ True False  True  True False]\n [ True  True  True False  True]\n [ True False  True  True  True]]\n\n\nrslc is a stack of 17 rslc images. Each of the image has 5 pixel in azimuth dimention and 10 pixels in range dimention. It shows for pixel (2,3), the (3*5) window around it has 2 SHPs to it (the central one is itself).\n\nif is_cuda_available():\n    rslc_cp = cp.asarray(rslc)\n    is_shp_cp = cp.asarray(is_shp)\n    cov_cp,coh_cp = emperical_co(rslc_cp,is_shp_cp)\n    print(cov_cp.shape, coh_cp.shape)\n\n(5, 10, 17, 17) (5, 10, 17, 17)\n\n\nBoth cov and coh are complex data. The shape shows each covarience or coherence matrix is 17 by 17 since there are 17 images. And cov and coh are matrix for all 5*10 pixels.\n\nsource\n\n\nemperical_co_pc\n\n emperical_co_pc (rslc:numpy.ndarray, idx:numpy.ndarray,\n                  pc_is_shp:numpy.ndarray, block_size:int=128,\n                  image_pairs:numpy.ndarray=None)\n\nMaximum likelihood covariance estimator for point cloud data.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nrslc\nndarray\n\nrslc stack, dtype: np.complex64\n\n\nidx\nndarray\n\nindex of point target (azimuth_index, range_index), dtype: np.int32, shape: (n_pc, 2)\n\n\npc_is_shp\nndarray\n\nshp bool, dtype: bool\n\n\nblock_size\nint\n128\nthe CUDA block size, it only affects the calculation speed\n\n\nimage_pairs\nndarray\nNone\nonly coherence of those image pairs will estimated, dtype: np.int32, shape: (n_image_pair, 2)\n\n\nReturns\nndarray\n\ncoh, dtype:np.complex64, shape(n_pc, n_image_pair)\n\n\n\nemperical_co_pc is the emperical_co on sparse data, e.g., DSs. rslc is same as emperical_co. sp_idx is the index, i.e., a tuple of (azimuth_idx, range_idx). Each index is 1D array. pc_is_shp is similar to is_shp in emperical_co but it only contains information about the point cloud data. It is a 3D array with shape [number_of_point,az_win,r_win].\nCompared with emperical_co, emperical_co_pc only estimate coherence at specific position so the memory usage is much small.\nemperical_co only return the coherence of specified image pairs to save data volume (compressed coherence). By default, only the upper triangle (with offset=1) of the coherence matrix is returned.\nExample:\n\n# synthetic data\nrslc = np.random.rand(5,10,17).astype(np.float32) + 1j*np.random.rand(5,10,17).astype(np.float32)\nhalf_az_win = 1;\nhalf_r_win = 2;\n\nis_shp = np.random.choice(a=[False, True], size=(5,10,2*half_az_win+1,2*half_r_win+1), p=[0.9, 0.1])\n# ensure the format of is_shp is correct:\nfor i, j, k, l in itertools.product(range(is_shp.shape[0]),range(is_shp.shape[1]),range(is_shp.shape[2]),range(is_shp.shape[3])):\n    if (k == half_az_win) and (l == half_r_win):\n        is_shp[i,j,k,l] = True\n    if (i+k-half_az_win&lt;0) or (i+k-half_az_win&gt;=rslc.shape[0]) or (j+l-half_r_win&lt;0) or (j+l-half_r_win&gt;=rslc.shape[1]):\n        is_shp[i,j,k,l] = False\n\nshp_num = np.count_nonzero(is_shp,axis=(-2,-1))\nis_ds_can = shp_num &gt;= 3\nds_can_is_shp = is_shp[is_ds_can]\nds_can_idx = np.stack(np.where(is_ds_can),axis=-1)\n\nprint(rslc.shape,ds_can_idx.shape,ds_can_is_shp.shape)\n\n(5, 10, 17) (15, 2) (15, 3, 5)\n\n\nrslc is a stack of 17 rslc images. Each of the image has 5 pixel in azimuth dimention and 10 pixels in range dimention. ds_can_idx shows the index of the DS candidates and ds_can_is_shp shows the corrosponding SHPs.\n\nds_can_coh = emperical_co_pc(rslc,ds_can_idx,ds_can_is_shp)\n\n\nds_can_coh.shape\n\n(15, 136)\n\n\nThe shape of the coherence matrix is (17,17) while only the upper triangle of it is returned (136 elements).\nOr, we can specify the image pairs:\n\ntempnet = mr.TempNet.from_bandwidth(rslc.shape[0],bandwidth=3)\nprint(tempnet.image_pairs.shape) # 9 rslc image pairs\nds_can_coh = emperical_co_pc(rslc,ds_can_idx,ds_can_is_shp,image_pairs=tempnet.image_pairs)\nprint(ds_can_coh.shape)\n\n(9, 2)\n(15, 9)\n\n\nInput cupy.ndarray is also supported:\n\nif is_cuda_available():\n    rslc_cp = cp.asarray(rslc)\n    ds_can_idx_cp = cp.asarray(ds_can_idx)\n    ds_can_is_shp_cp = cp.asarray(ds_can_is_shp)\n    ds_can_coh_cp = emperical_co_pc(rslc_cp,ds_can_idx_cp,ds_can_is_shp_cp)\n\n\nsource\n\n\nuncompress_coh\n\n uncompress_coh (coh:numpy.ndarray, image_pairs:numpy.ndarray=None)\n\nuncompress coh matrix to a hermitian matrix\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ncoh\nndarray\n\ncompressed coherence stack, dtype: np.complex64, shape(…,n_image_pair)\n\n\nimage_pairs\nndarray\nNone\nimage pairs, dtype: np.int32, shape: (n_image_pair, 2), all pairs by default\n\n\nReturns\nndarray\n\nuncompressed, dtype:np.complex64, shape(…, n_image_pair)\n\n\n\nExample:\n\nnimages = 5\ntempnet = mr.TempNet.from_bandwidth(nimages,bandwidth=2)\nprint(tempnet.image_pairs.shape)\ncoh = np.random.rand(tempnet.image_pairs.shape[0]).astype(np.float32) + 1j*np.random.rand(tempnet.image_pairs.shape[0]).astype(np.float32)\nuncompressed_coh = uncompress_coh(coh,tempnet.image_pairs)\nuncompressed_coh.real\n\n(7, 2)\n\n\narray([[1.        , 0.85904425, 0.871597  , 0.        , 0.        ],\n       [0.85904425, 1.        , 0.42918256, 0.04774178, 0.        ],\n       [0.871597  , 0.42918256, 1.        , 0.95771843, 0.36339107],\n       [0.        , 0.04774178, 0.95771843, 1.        , 0.49459904],\n       [0.        , 0.        , 0.36339107, 0.49459904, 1.        ]],\n      dtype=float32)\n\n\n\nsource\n\n\nad_intf_pc\n\n ad_intf_pc (ref_rslc:numpy.ndarray, sec_rslc:numpy.ndarray,\n             idx:numpy.ndarray, pc_is_shp:numpy.ndarray,\n             block_size:int=128)\n\nAdaptive multilooking interferogram generation for point cloud data.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nref_rslc\nndarray\n\nreference rslc, dtype: np.complex64\n\n\nsec_rslc\nndarray\n\nsecondary rslc, dtype: np.complex64\n\n\nidx\nndarray\n\nindex of point target (azimuth_index, range_index), dtype: np.int32, shape: (n_pc, 2)\n\n\npc_is_shp\nndarray\n\nshp bool, dtype: bool\n\n\nblock_size\nint\n128\nthe CUDA block size, it only affects the calculation speed\n\n\nReturns\nndarray\n\ncoh, dtype:np.complex64, shape(n_pc, n_image_pair)\n\n\n\nadf_intf_pc is similar to emperical_co_pc but only one interferogram generated.\nExample:\n\n# synthetic data\nrslc = np.random.rand(5,10,17).astype(np.float32) + 1j*np.random.rand(5,10,17).astype(np.float32)\nhalf_az_win = 1;\nhalf_r_win = 2;\n\nis_shp = np.random.choice(a=[False, True], size=(5,10,2*half_az_win+1,2*half_r_win+1), p=[0.9, 0.1])\n# ensure the format of is_shp is correct:\nfor i, j, k, l in itertools.product(range(is_shp.shape[0]),range(is_shp.shape[1]),range(is_shp.shape[2]),range(is_shp.shape[3])):\n    if (k == half_az_win) and (l == half_r_win):\n        is_shp[i,j,k,l] = True\n    if (i+k-half_az_win&lt;0) or (i+k-half_az_win&gt;=rslc.shape[0]) or (j+l-half_r_win&lt;0) or (j+l-half_r_win&gt;=rslc.shape[1]):\n        is_shp[i,j,k,l] = False\n\nshp_num = np.count_nonzero(is_shp,axis=(-2,-1))\nis_ds_can = shp_num &gt;= 3\nds_can_is_shp = is_shp[is_ds_can]\nds_can_idx = np.stack(np.where(is_ds_can),axis=-1)\n\nprint(rslc.shape,ds_can_idx.shape,ds_can_is_shp.shape)\n\n(5, 10, 17) (15, 2) (15, 3, 5)\n\n\n\nds_can_coh = emperical_co_pc(rslc,ds_can_idx,ds_can_is_shp)\ninf = ad_intf_pc(rslc[:,:,0],rslc[:,:,1],ds_can_idx,ds_can_is_shp)\nnp.testing.assert_array_equal(ds_can_coh[:,0],inf)",
    "crumbs": [
      "API",
      "co"
    ]
  },
  {
    "objectID": "API/co.html#covariance-and-coherence-matrix-regularizer",
    "href": "API/co.html#covariance-and-coherence-matrix-regularizer",
    "title": "co",
    "section": "Covariance and Coherence Matrix Regularizer",
    "text": "Covariance and Coherence Matrix Regularizer\n\nsource\n\nisPD\n\n isPD (co:numpy.ndarray)\n\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nco\nndarray\nabsolute value of complex coherence/covariance stack\n\n\nReturns\nndarray\nbool array indicating wheather coherence/covariance is positive define\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nThis function is deprecated.\n\n\nThis function tells if the matrix is positive defined or not.\n\n\nCode for generating data for doc\nrslc = zarr.open('../../data/rslc.zarr/',mode='r')[600:650,600:650]\nif is_cuda_available():\n    rslc = cp.asarray(rslc)\n    \n    # SHP selection\n    az_half_win = 5; r_half_win = 5\n    az_win = 2*az_half_win+1; r_win = 2*r_half_win+1\n    \n    rmli = cp.abs(rslc)**2\n    sorted_rmli = cp.sort(rmli,axis=-1)\n    p = mr.ks_test(sorted_rmli,az_half_win=az_half_win,r_half_win=r_half_win)\n    is_shp = p &lt; 0.05\n    \n    # Select DS candidate\n    shp_num = cp.count_nonzero(is_shp,axis=(-2,-1))\n    is_ds_can = shp_num &gt;= 50\n    ds_can_is_shp = is_shp[is_ds_can]\n    ds_can_idx = cp.stack(cp.where(is_ds_can),axis=-1)\n    \n    ds_can_coh = uncompress_coh(emperical_co_pc(rslc,ds_can_idx,ds_can_is_shp))\n\n\n\nif is_cuda_available():\n    print(ds_can_coh.shape)\n\n(0, 17, 17)\n\n\n\nif is_cuda_available():\n    isPD_ds_can = isPD(ds_can_coh)\n    print(isPD_ds_can)\n\n[]\n\n\nAll coherence matrix are positive defined.\n\nsource\n\n\nnearestPD\n\n nearestPD (co:numpy.ndarray)\n\nFind the nearest positive-definite matrix to input matrix.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nco\nndarray\nstack of matrix with shape […,N,N]\n\n\nReturns\nndarray\nnearest positive definite matrix of input, shape […,N,N]\n\n\n\nnearest means the Frobenius norm of the difference is minimized.\n\nsource\n\n\nregularize_spectral\n\n regularize_spectral (coh:numpy.ndarray, beta:Union[float,numpy.ndarray])\n\nSpectral regularizer for coherence matrix.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ncoh\nndarray\nstack of matrix with shape […,N,N]\n\n\nbeta\nUnion\nthe regularization parameter, a float number or cupy ndarray with shape […]\n\n\nReturns\nndarray\nregularized matrix, shape […,N,N]\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nThis function is deprecated.\n\n\nregularize_spectral can regularize the absolute value of coherence matrix for better phase linking. It is first presented in (Zwieback 2022).\n\nZwieback, S. 2022. “Cheap, Valid Regularizers for Improved Interferometric Phase Linking.” IEEE Geoscience and Remote Sensing Letters 19: 1–4. https://doi.org/10.1109/LGRS.2022.3197423.\nExamples:\n\n\nCode for generating data for doc\nrslc = zarr.open('../../data/rslc.zarr/',mode='r')[600:605,600:610]\nif is_cuda_available():\n    rslc = cp.asarray(rslc)\n    \n    # SHP selection\n    az_half_win = 1; r_half_win = 2\n    az_win = 2*az_half_win+1; r_win = 2*r_half_win+1\n    \n    rmli = cp.abs(rslc)**2\n    sorted_rmli = cp.sort(rmli,axis=-1)\n    p = mr.ks_test(sorted_rmli,az_half_win=az_half_win,r_half_win=r_half_win)\n    is_shp = p &lt; 0.05\n    \n    cov,coh = emperical_co(rslc,is_shp)\n\n\n\nif is_cuda_available():\n    print(coh.shape)\n\n(5, 10, 17, 17)\n\n\n\nif is_cuda_available():\n    regularized_coh1 = regularize_spectral(coh,0.1)\n\nMore general, bata can be a cp.ndarray:\n\nif is_cuda_available():\n    beta = cp.ones(coh.shape[:-2])/10\n    regularized_coh2 = regularize_spectral(coh,beta)",
    "crumbs": [
      "API",
      "co"
    ]
  },
  {
    "objectID": "API/pqm.html",
    "href": "API/pqm.html",
    "title": "pqm",
    "section": "",
    "text": "import numpy as np\nimport zarr\nimport moraine as mr\nfrom moraine.utils_ import is_cuda_available\nif is_cuda_available():\n    import cupy as cp\nfrom matplotlib import pyplot as plt\n\n\nsource\n\ntemp_coh\n\n temp_coh (intf:numpy.ndarray, rslc:numpy.ndarray,\n           image_pairs:numpy.ndarray=None, block_size:int=128)\n\nEstimation of temporal coherence.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nintf\nndarray\n\ncomplex interferograms/coherence metrix, dtype cp/np.complex64, shape 2D(pc) or 3D(ras)\n\n\nrslc\nndarray\n\ncomplex rslc/phase history, dtype cp/np.complex64, shape 2D(pc) or 3D(ras)\n\n\nimage_pairs\nndarray\nNone\nimage pairs\n\n\nblock_size\nint\n128\nthe CUDA block size, only applied for cuda\n\n\n\nThis function estimate the temporal coherence of as\n\\[\\gamma = \\frac{1}{N_{IP}} \\left| \\sum_{n, k \\in IP} e^{i\\phi_{nk}} e^{-i(\\theta_n-\\theta_k)} \\right| \\]\nWhere \\(\\phi_{nk}\\) is the phase of complex interferogram/coherence matrix, \\(\\theta_{n}\\) is the phase of rslc or phase after phase linking, \\(IP\\) is the image pairs, \\(N_{IP}\\) is the number of image pairs.\nIf all image pairs are considered, then it is:\n\\[\\gamma = \\frac{2}{N^2-N} \\left| \\sum_{n=1}^{N} \\sum_{k=n+1}^{N} e^{i\\phi_{nk}} e^{-i(\\theta_n-\\theta_k)} \\right| \\]\nThis function applies to both raster data and point cloud data, an example for pc data is the estimation of temporal coherence for distributed scatterers after phase linking:\n\nrslc = zarr.open('../../data/rslc.zarr/',mode='r')[:]\n\n# SHP selection\naz_half_win = 5; r_half_win = 5\naz_win = 2*az_half_win+1; r_win = 2*r_half_win+1\n\nrmli = np.abs(rslc)**2\np = mr.ks_test(rmli,az_half_win=az_half_win,r_half_win=r_half_win)\nis_shp = p &lt; 0.05\n\n# Select DS candidate\nshp_num = np.count_nonzero(is_shp,axis=(-2,-1))\nis_ds_can = shp_num &gt;= 50\n\nds_can_is_shp = is_shp[is_ds_can]\nds_can_idx = np.stack(np.where(is_ds_can),axis=-1)\nds_can_coh = mr.emperical_co_pc(rslc,ds_can_idx,ds_can_is_shp)\nds_can_ph = mr.emi(ds_can_coh)[0]\nprint(ds_can_coh.shape,ds_can_ph.shape)\n\n(732727, 136) (732727, 17)\n\n\n\nds_can_temp_coh = temp_coh(ds_can_coh,ds_can_ph)\nif is_cuda_available():\n    ds_can_temp_coh_cp = temp_coh(cp.asarray(ds_can_coh), cp.asarray(ds_can_ph))\n    np.testing.assert_array_almost_equal(ds_can_temp_coh, ds_can_temp_coh_cp.get())\n\n\nds_can_temp_coh_2d = np.empty_like(is_ds_can,dtype=ds_can_temp_coh.dtype)\nds_can_temp_coh_2d[:] = np.nan\nds_can_temp_coh_2d[is_ds_can] = ds_can_temp_coh\n\n\nfig, ax = plt.subplots(1,1,figsize=(10,10))\npcm = ax.imshow(ds_can_temp_coh_2d,interpolation='nearest',vmin=0.0,vmax=1.0)\nax.set(title='DS Temporal Coherence',xlabel='Range Index',ylabel='Azimuth Index')\nfig.colorbar(pcm)\nfig.show()\n\n\n\n\n\n\n\n\nThe example for raster data is the estimation of temporal coherence for selection of PS candidates with n2f:\n\nrslc = zarr.open('../CLI/raw/rslc.zarr/',mode='r')[:]\nintf = zarr.open('../CLI/dl/n2f_intf.zarr',mode='r')[:]\nimage_pairs = mr.TempNet.from_bandwidth(rslc.shape[-1],1).image_pairs\n\n\nps_temp_coh = temp_coh(intf,rslc,image_pairs)\n\nor with gpu:\n\nrslc_cp = cp.asarray(rslc)\nintf_cp = cp.asarray(intf)\nps_temp_coh_cp = temp_coh(intf_cp,rslc_cp,image_pairs)\nps_temp_coh = ps_temp_coh_cp.get()\n\n\nfig, ax = plt.subplots(1,1,figsize=(10,10))\npcm = ax.imshow(ps_temp_coh,interpolation='nearest',vmin=0.0,vmax=1.0)\nax.set(title='PS Temporal Coherence',xlabel='Range Index',ylabel='Azimuth Index')\nfig.colorbar(pcm)\nfig.show()",
    "crumbs": [
      "API",
      "pqm"
    ]
  },
  {
    "objectID": "API/shp.html",
    "href": "API/shp.html",
    "title": "shp",
    "section": "",
    "text": "from scipy import stats\nimport numpy as np\nfrom moraine.utils_ import is_cuda_available\nif is_cuda_available():\n    import cupy as cp\nimport itertools",
    "crumbs": [
      "API",
      "shp"
    ]
  },
  {
    "objectID": "API/shp.html#kolmogorov-smirnov-ks-two-sample-test",
    "href": "API/shp.html#kolmogorov-smirnov-ks-two-sample-test",
    "title": "shp",
    "section": "Kolmogorov-Smirnov (KS) two-sample test",
    "text": "Kolmogorov-Smirnov (KS) two-sample test\n\nsource\n\nks_test\n\n ks_test (rmli:numpy.ndarray, az_half_win:int, r_half_win:int,\n          block_size:int=128, return_dist:bool=False)\n\nSHP identification based on Two-Sample Kolmogorov-Smirnov Test.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nrmli\nndarray\n\nthe rmli stack, dtype: cupy.floating\n\n\naz_half_win\nint\n\nSHP identification half search window size in azimuth direction\n\n\nr_half_win\nint\n\nSHP identification half search window size in range direction\n\n\nblock_size\nint\n128\nthe CUDA block size, it only affects the calculation speed, only applied if input is cupy.ndarray\n\n\nreturn_dist\nbool\nFalse\nif return the KS test statistics dist\n\n\nReturns\ntuple\n\nif return_dist == True, return dist and p value p. Otherwise, only p is returned.\n\n\n\nThe ks_test function apply the Two-Sample Kolmogorov-Smirnov Test on a stack of rmli images to identify SHPs candidate for further processing. This method is originally published in (Ferretti et al. 2011). This function is designed to run on GPU for high speed.\n\nFerretti, Alessandro, Alfio Fumagalli, Fabrizio Novali, Claudio Prati, Fabio Rocca, and Alessio Rucci. 2011. “A New Algorithm for Processing Interferometric Data-Stacks: SqueeSAR.” IEEE Transactions on Geoscience and Remote Sensing 49 (9): 3460–70. https://doi.org/10.1109/TGRS.2011.2124465.\nThe rmli is a three dimentional cupy/numpy ndarray. The dtype should be float. From outerest to innerest, the three dimentions are azimuth, range and image. For each pixel P, a search window centered at P is defined by az_half_win and r_half_win. All pixels in this search window is compared with P by KS test. They are refered here as secondary pixels. The total number of secondary pixels (including P) is (2*az_half_win+1)*(2*r_half_win+1).\nThe returns are the ks test statistic which is the maximum value of the absolute difference between the emperical cumulative distribution functions of the two samples, and p value. Both of them are 4 dimentional cupy/numpy ndarrays. From outerest ot innerest, they are azimuth, range, secondary pixel relative azimuth, secondary pixel relative range. For P at the corner of the image where part of the search window is out of the image, the result is nan.\nHere is a simplest example. First simulate rmli time series of two pixels from two correlated normal distributions:\n\nsample_size = 20\nrng = np.random.default_rng()\nsample1 = stats.uniform.rvs(size=sample_size, random_state=rng).astype(np.float32)\nsample2 = stats.norm.rvs(size=sample_size, random_state=rng).astype(np.float32)\n\nrmli_stack = np.stack((np.asarray(sample1), np.asarray(sample2))).reshape(1,2,sample_size)\nrmli_stack.shape\n\n(1, 2, 20)\n\n\nThe shape of rmli_stack shows it contains 20 images. Each of the image has 1 pixel in azimuth dimention and 2 pixels in range dimention. Set the az_half_win and r_half_win to 1 and apply the ks_test function:\n\ndist,p = ks_test(rmli_stack,1,1,return_dist=True)\nprint(dist.shape)\nprint(dist)\n\n(1, 2, 3, 3)\n[[[[ nan  nan  nan]\n   [ nan 0.   0.35]\n   [ nan  nan  nan]]\n\n  [[ nan  nan  nan]\n   [0.35 0.    nan]\n   [ nan  nan  nan]]]]\n\n\ndist is the ks test statistic. The shape of it shows for each pixel P in this 1*2 image, a 3*3 search window is defined and all pixels in this search window is test with P. The value 0 in dist is the ks test result of pixel P and pixel P itself. The value nan means the secondary pixel is out of the image and no ks test is applied.\n\nprint(p.shape)\nprint(p)\n\n(1, 2, 3, 3)\n[[[[       nan        nan        nan]\n   [       nan 0.         0.13494715]\n   [       nan        nan        nan]]\n\n  [[       nan        nan        nan]\n   [0.13494715 0.                nan]\n   [       nan        nan        nan]]]]\n\n\np is the ks test p value with same shape of dist.\n\nprint(stats.ks_2samp(sample1, sample2,method='asymp'))\n\nKstestResult(statistic=np.float64(0.35), pvalue=np.float64(0.1339605462624991), statistic_location=np.float32(-0.09756402), statistic_sign=np.int8(-1))\n\n\nBy comparing the result of ks_test and ks_2samp from scipy, the statistics are same which prove the correctness of ks_test. The difference in p value is because the approcimation method used are different but the orders of magnitudes are consistent.\nks_test also accept cupy array:\n\nif is_cuda_available():\n    rmli_stack_cp = cp.asarray(rmli_stack)\n    dist_cp,p_cp = ks_test(rmli_stack_cp,1,1,return_dist=True)\n    np.testing.assert_array_equal(dist,cp.asnumpy(dist_cp))\n    np.testing.assert_array_almost_equal(p,cp.asnumpy(p_cp))\n\n\nsource\n\n\nselect_shp\n\n select_shp (p, p_max)\n\n\n\n\n\nDetails\n\n\n\n\np\n4D (n_az,n_r,az_win,r_win)\n\n\np_max\n\n\n\n\n\np = np.random.rand(100*100*5*5).astype(np.float32)\ngix = np.random.choice(100*100*5*5,size=1000,replace=False)\np[gix] = np.nan\np = p.reshape(100,100,5,5)\np = (p+np.transpose(p,axes=(0,1,3,2)))/2\nfor i in range(5):\n    p[:,:,i,i] = 1\n\n\nis_shp, shp_num = select_shp(p, 0.05)\nnp.testing.assert_array_equal(is_shp,p&lt; 0.05)\nnp.testing.assert_array_equal(shp_num, np.count_nonzero(p &lt; 0.05, axis=(-2,-1)).astype(np.int32))",
    "crumbs": [
      "API",
      "shp"
    ]
  },
  {
    "objectID": "API/pu.html",
    "href": "API/pu.html",
    "title": "Phase Unwrapping",
    "section": "",
    "text": "import zarr\nimport moraine as mr\n\n\nsource\n\ngamma_mcf_pt\n\n gamma_mcf_pt (pc_x:numpy.ndarray, pc_y:numpy.ndarray, ph:numpy.ndarray,\n               ph_weight:numpy.ndarray=None, ref_point:int=1)\n\nA simple wrapper for mcf_pt in GAMMA software.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\npc_x\nndarray\n\nx coordinate, shape of (N,)\n\n\npc_y\nndarray\n\ny coordinate, shape of (N,)\n\n\nph\nndarray\n\nwrapped phase, shape of (N,) or (N,M)\n\n\nph_weight\nndarray\nNone\npoint weight, shape of (N,) or (N,M), optional\n\n\nref_point\nint\n1\nreference point, the first point by default\n\n\nReturns\nndarray\n\nunwrapped phase, shape of (N,) or (N,M)\n\n\n\nusage:\n\nrslc = zarr.open('../../data/rslc.zarr/',mode='r')[:]\n\n# SHP selection\naz_half_win = 5; r_half_win = 5\naz_win = 2*az_half_win+1; r_win = 2*r_half_win+1\n\nrmli = np.abs(rslc)**2\np = mr.ks_test(rmli,az_half_win=az_half_win,r_half_win=r_half_win)\nis_shp = p &lt; 0.05\n\n# Select DS candidate\nshp_num = np.count_nonzero(is_shp,axis=(-2,-1))\nis_ds_can = shp_num &gt;= 50\n\nds_can_is_shp = is_shp[is_ds_can]\nds_can_gix = np.stack(np.where(is_ds_can),axis=-1)\nds_can_ph, ds_can_emi_quality, ds_can_t_coh = mr.emperical_co_emi_temp_coh_pc(rslc,ds_can_gix,ds_can_is_shp,batch_size=1000)\n\n_is_ds_can_refined = (ds_can_emi_quality&gt;=1.0) & (ds_can_emi_quality &lt;1.2) & (ds_can_t_coh &gt; 0.7) & (ds_can_t_coh &lt;= 1.0)\n\nds_gix = ds_can_gix[_is_ds_can_refined]\nds_ph = ds_can_ph[_is_ds_can_refined]\n\nds_hix = mr.pc_hix(ds_gix,shape=rslc.shape[:2])\nhix_sort_key = mr.pc_sort(ds_hix)\n\nds_hix = ds_hix[hix_sort_key]\nds_gix = ds_gix[hix_sort_key]\nds_ph = ds_ph[hix_sort_key]\n\ne = zarr.open('../../data/e.zarr/',mode='r')[:]\nn = zarr.open('../../data/n.zarr/',mode='r')[:]\n\nds_e = mr.ras2pc(e,ds_gix)\nds_n = mr.ras2pc(n,ds_gix)\n\nds_ph = ds_ph*ds_ph[:,0:1].conj() # set the first image as secondary\n\nUnwrap one single interferogram:\n\nds_ph_ = ds_ph[:,14]*ds_ph[:,9].conj()\n\nunw = gamma_mcf_pt(ds_e, ds_n, ds_ph_)\n\n\ndef wrap(unw):\n    return np.mod(unw + np.pi, 2 * np.pi) - np.pi\n\n\nnp.testing.assert_array_almost_equal(wrap(unw),np.angle(ds_ph_),decimal=4)\n\nUnwrap multiple interferograms:\n\nunw2 = gamma_mcf_pt(ds_e, ds_n, ds_ph[:,2:4])\nnp.testing.assert_array_almost_equal(wrap(unw2),np.angle(ds_ph[:,2:4]),decimal=4)\n\n\nimport holoviews as hv\nimport numpy as np\nfrom holoviews import opts\nfrom bokeh.models import WheelZoomTool\n\n\nhv.extension('bokeh')\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n  \n  \n\n\n\n\n\n\n\n\nⓘ\n\n\n\n\n\nunw_plot = mr.pc_plot(unw,ds_n, ds_e)\nph_plot = mr.pc_plot(np.angle(ds_ph_), ds_n, ds_e)\n\n\nunw_plot = unw_plot.redim(\n    x=hv.Dimension('lon', label='Longitude'), y=hv.Dimension('lat',label='Latitude'),\n    z=hv.Dimension('unw',label='Unwrapped phase')\n)\nunw_plot.opts(\n    opts.Image(cmap='colorwheel',width=600, height=400, colorbar=True,\n               default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],\n               active_tools=['wheel_zoom']\n              ),\n    opts.Points(color='unw', cmap='colorwheel',width=600, height=400, colorbar=True,\n                default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],\n                active_tools=['wheel_zoom']\n               )\n)\n\n\n\n\n\n  \n\n\n\n\n\nph_plot = ph_plot.redim(\n    x=hv.Dimension('lon', label='Longitude'), y=hv.Dimension('lat',label='Latitude'),\n    z=hv.Dimension('ph',label='Wrapped phase')\n)\nph_plot.opts(\n    opts.Image(cmap='colorwheel',width=600, height=400, colorbar=True,\n               default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],\n               active_tools=['wheel_zoom']\n              ),\n    opts.Points(color='ph', cmap='colorwheel',width=600, height=400, colorbar=True,\n                default_tools=['pan',WheelZoomTool(zoom_on_axis=False),'save','reset','hover'],\n                active_tools=['wheel_zoom']\n               )\n)",
    "crumbs": [
      "API",
      "Phase Unwrapping"
    ]
  },
  {
    "objectID": "API/ps.html",
    "href": "API/ps.html",
    "title": "ps",
    "section": "",
    "text": "import zarr\nfrom matplotlib import pyplot as plt\nimport colorcet\nfrom moraine.utils_ import is_cuda_available\n\n\nsource\n\namp_disp\n\n amp_disp (rslc:numpy.ndarray)\n\ncalculation the amplitude dispersion index from SLC stack.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nrslc\nndarray\nrslc stack, 3D numpy array or cupy array\n\n\nReturns\nndarray\ndispersion index, 2D numpy array or cupy array\n\n\n\nUsing amplitude dispersion index (ADI) to identify persistent scatterers is first used in (Ferretti, Prati, and Rocca Jan./2001).\n\nFerretti, A., C. Prati, and F. Rocca. Jan./2001. “Permanent Scatterers in SAR Interferometry.” IEEE Transactions on Geoscience and Remote Sensing 39 (1): 8–20. https://doi.org/10.1109/36.898661.\nUsage:\n\nrslc = zarr.open('../CLI/raw/rslc.zarr/',mode='r')[:]\nadi_cpu = amp_disp(rslc)\nif is_cuda_available():\n    rslc_gpu = cp.asarray(rslc)\n    adi_gpu = amp_disp(rslc_gpu)\n    np.testing.assert_array_almost_equal(adi_cpu,adi_gpu.get())\n\n\nfig, ax = plt.subplots(1,1,figsize=(10,10))\npcm = ax.imshow(adi_cpu,vmin=0,vmax=1)\nax.set(title='Amplitude Dispersion Index',xlabel='Range Index',ylabel='Azimuth Index')\nfig.colorbar(pcm)\nfig.show()",
    "crumbs": [
      "API",
      "ps"
    ]
  },
  {
    "objectID": "API/rtree.html",
    "href": "API/rtree.html",
    "title": "rtree",
    "section": "",
    "text": "import moraine as mr\n\n\nsource\n\nHilbertRtree\n\n HilbertRtree (bounds_tree:numpy.ndarray, n_points:int, page_size=512)\n\n*This class provides a read-only Hilbert R-tree for spatial indexing.\nSee Hilbert_R-tree for more info on the Hilbert R-tree.\nThis implementation stores the R-tree as an array representation of a binary tree. See Binary_tree for more info on the array representation of a binary tree.*\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nbounds_tree\nndarray\n\nan array representation of a binary tree. shape [n_pages, 4]. Every row is a bounding box of a node: [x0, y0, xm, ym]\n\n\nn_points\nint\n\nnumber of total points\n\n\npage_size\nint\n512\nnumber of points in every leaf node.\n\n\n\n\nsource\n\n\nHilbertRtree.build\n\n HilbertRtree.build (x:numpy.ndarray, y:numpy.ndarray, page_size=512)\n\nclassmethod to build a HilbertRtree.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nx\nndarray\n\nx coordinates, e.g., lon, shape [n_points,]\n\n\ny\nndarray\n\ny coordinates, e.g., lat, shape [n_points,]\n\n\npage_size\nint\n512\nnumber of points in every leaf node. should be same as pc_chunk_size.\n\n\n\n\nsource\n\n\nHilbertRtree.save\n\n HilbertRtree.save (path:str)\n\nSave the HilbertRtree.\n\n\n\n\nType\nDetails\n\n\n\n\npath\nstr\nzarr path\n\n\n\n\nsource\n\n\nHilbertRtree.load\n\n HilbertRtree.load (zarr_path:str)\n\nclassmethod to load the saved HilbertRtree.\n\n\n\n\nType\nDetails\n\n\n\n\nzarr_path\nstr\nzarr path\n\n\n\n\nsource\n\n\nHilbertRtree.bbox_query\n\n HilbertRtree.bbox_query (bounds:tuple|list,\n                          x:numpy.ndarray|zarr.core.array.Array,\n                          y:numpy.ndarray|zarr.core.array.Array)\n\nget the index of points that are in the bounding box.\n\n\n\n\nType\nDetails\n\n\n\n\nbounds\ntuple | list\ndata query bounding box, [x0, y0, xm, ym]\n\n\nx\nnumpy.ndarray | zarr.core.array.Array\nx coordinate\n\n\ny\nnumpy.ndarray | zarr.core.array.Array\ny coordinate\n\n\n\nExample: create the data:\n\ngix = np.random.randint(0, 10000*10000-1, size=1000000)\ngix.sort()\ngix = np.stack(np.unravel_index(gix,shape=(10000,10000)),axis=-1).astype(np.int32)\nhix = mr.pc_hix(gix,shape=(10000,10000))\nkey = mr.pc_sort(hix)\n\nx = gix[:,1][key]/10000; y = gix[:,0][key]/10000 # any kind of coordinates\nprint(x.min(),y.min(),x.max(),y.max())\n\n0.0 0.0 0.9999 0.9999\n\n\nbuild r tree:\n\nrtree = HilbertRtree.build(x,y,page_size=4096)\n\ndata query:\n\nx0, y0, xm, ym = 0.9, 0.9, 1.0, 1.0\nbounds = [x0, y0, xm, ym]\nq_idx = rtree.bbox_query(bounds,x,y)\n\ncompare with the brute-force check:\n\nq_idx_ = np.where((x&gt;x0) & (x&lt;xm) & (y&gt;y0) & (y&lt;ym))[0]\nnp.testing.assert_array_equal(q_idx, q_idx_)\n\nspeed compare:\n\nq_idx = rtree.bbox_query(bounds,x,y)\n\n415 μs ± 3.52 μs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)\n\n\n\nq_idx_ = np.where((x&gt;x0) & (x&lt;xm) & (y&gt;y0) & (y&lt;ym))[0]\n\n1.36 ms ± 48.7 μs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)\n\n\nHilbertRtree is designed for query small amount of data from a big dataset. The bigger the dataset, the greater the improvement.\nfor data on the disk:\n\nx_zarr = zarr.open('rtree/x.zarr',mode='w',shape=x.shape,chunks=(4096,),dtype=x.dtype)\ny_zarr = zarr.open('rtree/y.zarr',mode='w',shape=x.shape,chunks=(4096,),dtype=x.dtype)\nx_zarr[:] = x; y_zarr[:] = y\n\n\nx_zarr = zarr.open('rtree/x.zarr',mode='r')\ny_zarr = zarr.open('rtree/y.zarr',mode='r')\n\n\nq_idx = rtree.bbox_query(bounds,x_zarr,y_zarr)\n\n4.77 ms ± 74.5 μs per loop (mean ± std. dev. of 7 runs, 100 loops each)\n\n\n\nx = x_zarr[:]; y = y_zarr[:]\nidx = np.where((x&gt;x0) & (x&lt;xm) & (y&gt;y0) & (y&lt;ym))[0]\n\n188 ms ± 585 μs per loop (mean ± std. dev. of 7 runs, 10 loops each)",
    "crumbs": [
      "API",
      "rtree"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Moraine",
    "section": "",
    "text": "Modern Radar Interferometry Environment; A simple, stupid InSAR postprocessing tool in big data era\nThis package provide functions for InSAR post-processing which refers as processing after SAR images co-registration and geocoding. The functions include PS/DS identification, coherence matrix estimation, phase linking etc.",
    "crumbs": [
      "Moraine"
    ]
  },
  {
    "objectID": "index.html#principle1",
    "href": "index.html#principle1",
    "title": "Moraine",
    "section": "Principle1",
    "text": "Principle1\n\nSimplicity\nThere is no perfect workflow that always generate satisfactory InSAR result, mostly due to decorrelation, strong atmospheric artifact and high deformation gradient. Different methods implemented in different packages need to be tried which is frustrating especially when the packages are over-encapsulated and no detailed documentations are provided. Furthermore, it brings more dirty work when users need to save intermediate data from one software and prepared them in a designated format and structure required by another software.\nMoraine defines simplicity as without complex data structure and over-encapsulation. Most data in Moraine is just the basic multi-dimentional array, i.e., NumPy array or CuPy array in memory, or Zarr on disk. Instead of providing a standard workflow as StamPS and MintPy, Moraine is designed as a collection of functions that implement specific InSAR processing techniques and data manipulation infrastructure.\n\n\nModernity\nMoraine strives to implement state-of-art InSAR techniques, including advanced PS/DS identification, phase linking and deep-learning-based methods.\nMoraine also emphasizes performance, especially in this big data era. Most Moraine functions are implemented with well-optimized GPU code or OpenMP code. Furthermore, with the support of Dask, Moraine can be runed on multi-GPUs to further accelerate the processing, get rid of the limitation of memory and achieve asynchronous IO.\n\n\nPragmatism\nMoraine is a pragmatic library rather than an ideological workflow. The large number of functions in MOraine offer free and open source implementation for many InSAR techniques. Ultimately, workflow designs are made on a case-by-case basis by the user. We provide the necessary infrastructure and your role is to be innovative!\n\n\nUser centrality\nWhereas many InSAR packages attempt to be more user-friendly, Moraine has always been, and shall always remain user-centric. This package is intended to fill the needs of those contributing to it, rather than trying to appeal to as many users as possible. It is targeted at the proficient InSAR user, or anyone with a do-it-yourself attitude who is willing to read the documentation, and solve their own problems.\nAll users are encouraged to participate and contribute to this package. Reporting bugs and requesting new features by raising a Github issue is highly valued and bugs fixing, documentation improving and features implementation by make a Github pull request are very appreciated. Users can also freely ask questions, provide technical assistance to others or just exchange opinions in the discussions.",
    "crumbs": [
      "Moraine"
    ]
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "Moraine",
    "section": "Install",
    "text": "Install\nBecause of GPU driver and CUDA Version Compatibility, there is no simple solution for CUDA related packages installation. Users need to successfully install cupy and dask_cuda first.\nHere is some tips for installing them. Generally, the cuda driver is alrealy installed and maintained by the system administrator. Users only need to determine the right cudatoolkit version. Frist run\nnvidia-smi\nIt will prints something like:\n...\n+-----------------------------------------------------------------------------+\n| NVIDIA-SMI 525.105.17   Driver Version: 525.105.17   CUDA Version: 12.0     |\n|-------------------------------+----------------------+----------------------+\n...\nThe CUDA Version is the maxminum cudatoolkit version that supported by the current CUDA driver. Here we use version 11.8 as an example. Then you can install the needed cudatoolkit, cupy, dask_cuda by:\nconda install -c \"nvidia/label/cuda-11.8.0\" cuda-toolkit\nconda install -c conda-forge cupy cuda-version=11.8\nconda install -c rapidsai -c conda-forge -c nvidia dask-cuda rmm cuda-version=11.8\npip install onnxruntime # or onnxruntime-gpu\nThen\nWith conda:\nconda install -c conda-forge moraine\nOr with pip:\npip install moraine\nIn development mode:\ngit clone git@github.com:kanglcn/moraine.git ./moraine\ncd ./moraine\npip install -e '.[dev]'",
    "crumbs": [
      "Moraine"
    ]
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "Moraine",
    "section": "How to use",
    "text": "How to use\nRead the software architecture for an overview of the software design. Refer to Tutorials for the examples. Refer to API and CLI for the detailed usage of every functions.",
    "crumbs": [
      "Moraine"
    ]
  },
  {
    "objectID": "index.html#contact-us",
    "href": "index.html#contact-us",
    "title": "Moraine",
    "section": "Contact us",
    "text": "Contact us\n\nMost discussion happens on GitHub. Feel free to open an issue or comment on any open issue or pull request.\nuse github discussions to ask questions or leave comments.",
    "crumbs": [
      "Moraine"
    ]
  },
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "Moraine",
    "section": "License",
    "text": "License\n\nThis package is opened under GPL-v3.\nThe deep learning models under moraine/dl_model/* are opened under CC BY-NC-SA 4.0.",
    "crumbs": [
      "Moraine"
    ]
  },
  {
    "objectID": "index.html#general-guidelines-for-making-a-pull-request-pr2",
    "href": "index.html#general-guidelines-for-making-a-pull-request-pr2",
    "title": "Moraine",
    "section": "General Guidelines for Making a Pull Request (PR)2",
    "text": "General Guidelines for Making a Pull Request (PR)2\nWe follow the git pull request workflow to make changes to our codebase.\nBefore you make a PR, have a quick look at the titles of all the existing issues first. If there is already an issue that matches your PR, leave a comment there to let us know what you plan to do. Otherwise, open an issue describing what you want to do.\nWhat should be included in a PR\n\nEach pull request should consist of a small and logical collection of changes; larger changes should be broken down into smaller parts and integrated separately.\nBug fixes should be submitted in separate PRs.\n\nHow to write and submit a PR\n\nThis package is developed with the nbdev, a notebook-driven development platform. Developers should write or edit the notebooks rather than the .py files. After than, run nbdev_export to export the code in the notebooks to .py files and run nbdev_clean to clean the notebooks.\nThe github bot to generate docs do not support GPU, so all GPU related packages (dask_cuda) should be prevented in import cells and export cells. cupy v13 now allow import cupy on a cpu-only machine. So it can be used now.\nDescribe what your PR changes and why this is a good thing. Be as specific as you can. The PR description is how we keep track of the changes made to the project over time.\nDo not commit changes to files that are irrelevant to your feature or bugfix (e.g.: .gitignore, IDE project files, etc).\nWrite descriptive commit messages. Chris Beams has written a guide on how to write good commit messages.\n\nPR review\nBe willing to accept criticism and work on improving your code; we don’t want to break other users’ code, so care must be taken not to introduce bugs.\nBe aware that the pull request review process is not immediate, and is generally proportional to the size of the pull request.",
    "crumbs": [
      "Moraine"
    ]
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "Moraine",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nThe pronciples are modified from the principle of Arch Linux.↩︎\nthis is modified from the Contributers Guide of PyGMT.↩︎",
    "crumbs": [
      "Moraine"
    ]
  }
]