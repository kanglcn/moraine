# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/API/pl.ipynb.

# %% auto 0
__all__ = ['emi', 'temp_coh']

# %% ../nbs/API/pl.ipynb 5
import cupy as cp

# %% ../nbs/API/pl.ipynb 8
def emi(coh:cp.ndarray, #complex coherence metrix,dtype cupy.complex
        ref:int=0, #index of reference image in the phase history output, optional. Default: 0
       )-> tuple[cp.ndarray,cp.ndarray]: # estimated phase history `ph`, dtype complex; quality (minimum eigvalue, dtype float)
    coh_mag = abs(coh)
    coh_mag_inv = cp.linalg.inv(coh_mag)
    min_eigval, min_eig = cp.linalg.eigh(coh_mag_inv*coh)
    min_eigval = min_eigval[...,0]
    # min_eig = min_eig[...,0]
    min_eig = min_eig[...,0]*min_eig[...,[ref],0].conj()

    return min_eig/abs(min_eig), min_eigval

# %% ../nbs/API/pl.ipynb 17
def temp_coh(coh:cp.ndarray,# complex coherence metrix, dtype cupy.complex
             ds_ph = cp.ndarray, # complex phase history, dtype cupy.complex
            ):
    nimages = ds_ph.shape[-1]
    assert coh.shape[-2:] == (nimages,nimages), "input dimension not match"
    ds_ph = ds_ph/abs(ds_ph)
    coh = coh/abs(coh)
    int_ph = ds_ph[...,None]*ds_ph[...,None,:].conj()
    diff_ph = coh*int_ph.conj()
    t_coh = (cp.sum(diff_ph,axis=(-2,-1))-cp.trace(diff_ph,axis1=-2,axis2=-1)).real/(nimages**2-nimages)
    return t_coh
